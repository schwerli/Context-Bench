{
  "instance_id": "Multi-SWE-Bench__cpp__maintenance__bugfix__41b108ee",
  "original_id": "simdjson__simdjson-2016",
  "1_model_selected_files": [
    "src/generic/stage1/find_next_document_index.h",
    "include/simdjson/generic/ondemand/document_stream-inl.h",
    "include/simdjson/generic/ondemand/parser-inl.h"
  ],
  "2_embedding_selected_files": [
    "include/simdjson/generic/ondemand/parser-inl.h",
    "src/generic/stage1/find_next_document_index.h",
    "include/simdjson/generic/ondemand/document_stream-inl.h",
    "include/simdjson/generic/ondemand/parser.h",
    "include/simdjson/generic/ondemand/document_stream.h",
    "include/simdjson/generic/ondemand/json_iterator.h",
    "include/simdjson/generic/ondemand/value_iterator-inl.h",
    "include/simdjson/generic/ondemand/document-inl.h",
    "include/simdjson/generic/ondemand/token_iterator.h",
    "include/simdjson/generic/ondemand/value_iterator.h",
    "src/generic/stage1/json_structural_indexer.h",
    "src/generic/stage1/json_string_scanner.h",
    "src/generic/stage1/json_scanner.h",
    "include/simdjson/generic/ondemand/document.h",
    "include/simdjson/generic/ondemand/array-inl.h",
    "include/simdjson/generic/ondemand/json_iterator-inl.h",
    "include/simdjson/generic/dom_parser_implementation.h",
    "src/generic/stage1/buf_block_reader.h",
    "include/simdjson/generic/ondemand/array_iterator.h",
    "src/generic/stage1/json_minifier.h",
    "include/simdjson/generic/numberparsing.h",
    "include/simdjson/generic/ondemand/object_iterator-inl.h",
    "src/generic/stage1/utf8_lookup4_algorithm.h"
  ],
  "3_final_combined_files": [
    "src/generic/stage1/find_next_document_index.h",
    "include/simdjson/generic/ondemand/document_stream-inl.h",
    "include/simdjson/generic/ondemand/parser-inl.h"
  ],
  "4_related_elements": {
    "src/generic/stage1/find_next_document_index.h": [
      "function: find_next_document_index"
    ],
    "include/simdjson/generic/ondemand/document_stream-inl.h": [
      "function: document_stream::start\nfunction: document_stream::next\nfunction: document_stream::next_document\nfunction: document_stream::iterator::source\nfunction: document_stream::truncated_bytes"
    ],
    "include/simdjson/generic/ondemand/parser-inl.h": [
      "function: parser::iterate_many\nclass: dom_parser_implementation\nfunction: dom_parser_implementation::stage1\nfunction: json_iterator::skip_child"
    ]
  },
  "5_sampled_edit_locs_and_patches": [
    {
      "sample_index": 0,
      "edit_locs": {
        "src/generic/stage1/find_next_document_index.h": [
          "function: find_next_document_index\nline: 38\nline: 39\nline: 40\nline: 41\nline: 55\nline: 56\nline: 57\nline: 58\nline: 59\nline: 60\nline: 61\nline: 62\nline: 63\nline: 64\nline: 65\nline: 66\nline: 67\nline: 69\nline: 70\nline: 84\nline: 85\nline: 86\nline: 87"
        ],
        "include/simdjson/generic/ondemand/document_stream-inl.h": [
          "function: simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_stream::next_document\nline: 288\nline: 289\nline: 290\nline: 291\nline: 292\nline: 293\nline: 294\nline: 295\nline: 296\nfunction: simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_stream::start"
        ],
        "include/simdjson/generic/ondemand/parser-inl.h": [
          ""
        ]
      },
      "patches": [
        "diff --git a/include/simdjson/generic/ondemand/document_stream-inl.h b/include/simdjson/generic/ondemand/document_stream-inl.h\nindex e495d50..9c1b2de 100644\n--- a/include/simdjson/generic/ondemand/document_stream-inl.h\n+++ b/include/simdjson/generic/ondemand/document_stream-inl.h\n@@ -1,3 +1,4 @@\n+\n #include <algorithm>\n #include <limits>\n #include <stdexcept>\n@@ -288,11 +289,25 @@ inline void document_stream::next_document() noexcept {\n   // Go to next place where depth=0 (document depth)\n   error = doc.iter.skip_child(0);\n   if (error) { return; }\n-  // Always set depth=1 at the start of document\n+\n+  // Skip any comma separators between documents (e.g., [..] , {...} , [..])\n+  const uint32_t *structurals = parser->implementation->structural_indexes.get();\n+  size_t n_structurals = parser->implementation->n_structural_indexes;\n+  const uint32_t *pos = doc.iter.position();\n+  size_t idx = static_cast<size_t>(pos - structurals);\n+\n+  while (idx < n_structurals &&\n+         buf[batch_start + parser->implementation->structural_indexes[idx]] == ',') {\n+    idx++;\n+    pos = structurals + idx;\n+  }\n+\n+  // Always set depth=1 at the start of the next document\n   doc.iter._depth = 1;\n   // Resets the string buffer at the beginning, thus invalidating the strings.\n   doc.iter._string_buf_loc = parser->string_buf.get();\n-  doc.iter._root = doc.iter.position();\n+  // Set root to the start of the next document (after any commas)\n+  doc.iter._root = pos;\n }\n \n inline size_t document_stream::next_batch_start() const noexcept {\n@@ -347,7 +362,8 @@ simdjson_inline std::string_view document_stream::iterator::source() const noexc\n     cur_struct_index++;\n   }\n \n-  return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), stream->parser->implementation->structural_indexes[cur_struct_index] - current_index() + stream->batch_start + 1);;\n+  size_t end = stream->batch_start + stream->parser->implementation->structural_indexes[cur_struct_index] + 1;\n+  return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), end - current_index());\n }\n \n inline error_code document_stream::iterator::error() const noexcept {\n@@ -404,4 +420,4 @@ simdjson_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stre\n {\n }\n \n-}\n+}\n",
        "diff --git a/include/simdjson/generic/ondemand/document_stream-inl.h b/include/simdjson/generic/ondemand/document_stream-inl.h\nindex e495d50..8b5fc21 100644\n--- a/include/simdjson/generic/ondemand/document_stream-inl.h\n+++ b/include/simdjson/generic/ondemand/document_stream-inl.h\n@@ -1,3 +1,4 @@\n+\n #include <algorithm>\n #include <limits>\n #include <stdexcept>\n@@ -288,11 +289,27 @@ inline void document_stream::next_document() noexcept {\n   // Go to next place where depth=0 (document depth)\n   error = doc.iter.skip_child(0);\n   if (error) { return; }\n+\n+  // After finishing a document, skip any top-level commas separating documents\n+  auto base = parser->implementation->structural_indexes.get();\n+  auto p = doc.iter.position();\n+  size_t n = parser->implementation->n_structural_indexes;\n+  while ((p - base) < static_cast<ptrdiff_t>(n)) {\n+    uint32_t idx = static_cast<uint32_t>(*p);\n+    char c = static_cast<char>(buf[batch_start + idx]);\n+    if (c == ',') {\n+      p++; // consume separator and keep looking\n+      continue;\n+    }\n+    break;\n+  }\n+\n   // Always set depth=1 at the start of document\n   doc.iter._depth = 1;\n   // Resets the string buffer at the beginning, thus invalidating the strings.\n   doc.iter._string_buf_loc = parser->string_buf.get();\n-  doc.iter._root = doc.iter.position();\n+  // Root should point at the beginning of the next document (after any commas)\n+  doc.iter._root = p;\n }\n \n inline size_t document_stream::next_batch_start() const noexcept {\n@@ -404,4 +421,4 @@ simdjson_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stre\n {\n }\n \n-}\n+}\n"
      ]
    },
    {
      "sample_index": 1,
      "edit_locs": {
        "src/generic/stage1/find_next_document_index.h": [
          "function: find_next_document_index\nline: 38\nline: 39\nline: 40\nline: 59\nline: 60\nline: 62\nline: 67\nline: 84\nline: 88"
        ],
        "include/simdjson/generic/ondemand/document_stream-inl.h": [
          "function: SIMDJSON_IMPLEMENTATION::ondemand::document_stream::next_document\nline: 288\nline: 289\nline: 290\nline: 291\nline: 292\nline: 293\nline: 294\nline: 295\nline: 296\nfunction: SIMDJSON_IMPLEMENTATION::ondemand::document_stream::iterator::source\nline: 330\nline: 331\nline: 332\nline: 333\nline: 338\nline: 349\nline: 350"
        ],
        "include/simdjson/generic/ondemand/parser-inl.h": [
          ""
        ]
      },
      "patches": [
        "diff --git a/include/simdjson/generic/ondemand/document_stream-inl.h b/include/simdjson/generic/ondemand/document_stream-inl.h\nindex e495d50..9836f86 100644\n--- a/include/simdjson/generic/ondemand/document_stream-inl.h\n+++ b/include/simdjson/generic/ondemand/document_stream-inl.h\n@@ -1,3 +1,4 @@\n+\n #include <algorithm>\n #include <limits>\n #include <stdexcept>\n@@ -288,11 +289,20 @@ inline void document_stream::next_document() noexcept {\n   // Go to next place where depth=0 (document depth)\n   error = doc.iter.skip_child(0);\n   if (error) { return; }\n+  // After finishing a document, skip any top-level commas that separate documents\n+  auto base_structurals = parser->implementation->structural_indexes.get();\n+  auto n = parser->implementation->n_structural_indexes;\n+  size_t cur_index = size_t(doc.iter.position() - base_structurals);\n+  while (cur_index < n &&\n+         buf[batch_start + parser->implementation->structural_indexes[cur_index]] == ',') {\n+    cur_index++;\n+  }\n   // Always set depth=1 at the start of document\n   doc.iter._depth = 1;\n   // Resets the string buffer at the beginning, thus invalidating the strings.\n   doc.iter._string_buf_loc = parser->string_buf.get();\n-  doc.iter._root = doc.iter.position();\n+  // Set the root to the next non-comma structural index\n+  doc.iter._root = base_structurals + cur_index;\n }\n \n inline size_t document_stream::next_batch_start() const noexcept {\n@@ -328,8 +338,11 @@ simdjson_inline std::string_view document_stream::iterator::source() const noexc\n         break;\n       default:    // Scalar value document\n         // TODO: Remove any trailing whitespaces\n-        // This returns a string spanning from start of value to the beginning of the next document (excluded)\n-        return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), stream->parser->implementation->structural_indexes[++cur_struct_index] - current_index() - 1);\n+        // Return from the start of the value up to (but not including) the next structural character\n+        return std::string_view(\n+          reinterpret_cast<const char*>(stream->buf) + current_index(),\n+          stream->batch_start + stream->parser->implementation->structural_indexes[++cur_struct_index] - current_index()\n+        );\n     }\n     cur_struct_index++;\n   }\n@@ -404,4 +417,4 @@ simdjson_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stre\n {\n }\n \n-}\n+}\n",
        "diff --git a/include/simdjson/generic/ondemand/document_stream-inl.h b/include/simdjson/generic/ondemand/document_stream-inl.h\nindex e495d50..6876e23 100644\n--- a/include/simdjson/generic/ondemand/document_stream-inl.h\n+++ b/include/simdjson/generic/ondemand/document_stream-inl.h\n@@ -1,3 +1,4 @@\n+\n #include <algorithm>\n #include <limits>\n #include <stdexcept>\n@@ -288,11 +289,24 @@ inline void document_stream::next_document() noexcept {\n   // Go to next place where depth=0 (document depth)\n   error = doc.iter.skip_child(0);\n   if (error) { return; }\n+  // Set the new root at the position after the previous document\n+  doc.iter._root = doc.iter.position();\n+  // Consume any commas separating documents at depth 0\n+  // This allows iterate_many/document_stream to handle comma-separated JSON documents.\n+  while (true) {\n+    auto cur_struct_index = doc.iter._root - parser->implementation->structural_indexes.get();\n+    if (cur_struct_index >= static_cast<int64_t>(parser->implementation->n_structural_indexes)) { break; }\n+    uint8_t ch = buf[batch_start + parser->implementation->structural_indexes[cur_struct_index]];\n+    if (ch == ',') {\n+      doc.iter._root++;\n+      continue;\n+    }\n+    break;\n+  }\n   // Always set depth=1 at the start of document\n   doc.iter._depth = 1;\n   // Resets the string buffer at the beginning, thus invalidating the strings.\n   doc.iter._string_buf_loc = parser->string_buf.get();\n-  doc.iter._root = doc.iter.position();\n }\n \n inline size_t document_stream::next_batch_start() const noexcept {\n@@ -404,4 +418,4 @@ simdjson_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stre\n {\n }\n \n-}\n+}\ndiff --git a/src/generic/stage1/find_next_document_index.h b/src/generic/stage1/find_next_document_index.h\nindex 2829c9e..21e2889 100644\n--- a/src/generic/stage1/find_next_document_index.h\n+++ b/src/generic/stage1/find_next_document_index.h\n@@ -52,11 +52,17 @@ simdjson_inline uint32_t find_next_document_index(dom_parser_implementation &par\n       break;\n     }\n     auto idxa = parser.structural_indexes[i - 1];\n-    switch (parser.buf[idxa]) {\n-    case '{':\n-    case '[':\n-    case ':':\n-    case ',':\n+    char prev = parser.buf[idxa];\n+    // Allow a comma between documents at depth 0:\n+    // treat \"][\", \"]{\", \"}[\", \"}{\" as boundaries as before,\n+    // and also \",{\" or \",[\" if the token before the comma is ']' or '}'.\n+    bool boundary = (prev == '}' || prev == ']');\n+    if (!boundary && prev == ',' && i >= 2) {\n+      auto idxa2 = parser.structural_indexes[i - 2];\n+      char prev2 = parser.buf[idxa2];\n+      boundary = (prev2 == '}' || prev2 == ']');\n+    }\n+    if (!boundary) {\n       continue;\n     }\n     // Last document is complete, so the next document will appear after!\n@@ -90,4 +96,4 @@ simdjson_inline uint32_t find_next_document_index(dom_parser_implementation &par\n \n } // unnamed namespace\n } // namespace SIMDJSON_IMPLEMENTATION\n-} // namespace simdjson\n+} // namespace simdjson\n"
      ]
    }
  ],
  "6_final_selected_patch": "diff --git a/include/simdjson/generic/ondemand/document_stream-inl.h b/include/simdjson/generic/ondemand/document_stream-inl.h\nindex e495d50..9c1b2de 100644\n--- a/include/simdjson/generic/ondemand/document_stream-inl.h\n+++ b/include/simdjson/generic/ondemand/document_stream-inl.h\n@@ -1,3 +1,4 @@\n+\n #include <algorithm>\n #include <limits>\n #include <stdexcept>\n@@ -288,11 +289,25 @@ inline void document_stream::next_document() noexcept {\n   // Go to next place where depth=0 (document depth)\n   error = doc.iter.skip_child(0);\n   if (error) { return; }\n-  // Always set depth=1 at the start of document\n+\n+  // Skip any comma separators between documents (e.g., [..] , {...} , [..])\n+  const uint32_t *structurals = parser->implementation->structural_indexes.get();\n+  size_t n_structurals = parser->implementation->n_structural_indexes;\n+  const uint32_t *pos = doc.iter.position();\n+  size_t idx = static_cast<size_t>(pos - structurals);\n+\n+  while (idx < n_structurals &&\n+         buf[batch_start + parser->implementation->structural_indexes[idx]] == ',') {\n+    idx++;\n+    pos = structurals + idx;\n+  }\n+\n+  // Always set depth=1 at the start of the next document\n   doc.iter._depth = 1;\n   // Resets the string buffer at the beginning, thus invalidating the strings.\n   doc.iter._string_buf_loc = parser->string_buf.get();\n-  doc.iter._root = doc.iter.position();\n+  // Set root to the start of the next document (after any commas)\n+  doc.iter._root = pos;\n }\n \n inline size_t document_stream::next_batch_start() const noexcept {\n@@ -347,7 +362,8 @@ simdjson_inline std::string_view document_stream::iterator::source() const noexc\n     cur_struct_index++;\n   }\n \n-  return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), stream->parser->implementation->structural_indexes[cur_struct_index] - current_index() + stream->batch_start + 1);;\n+  size_t end = stream->batch_start + stream->parser->implementation->structural_indexes[cur_struct_index] + 1;\n+  return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), end - current_index());\n }\n \n inline error_code document_stream::iterator::error() const noexcept {\n@@ -404,4 +420,4 @@ simdjson_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stre\n {\n }\n \n-}\n+}\n",
  "7_resolved": false
}