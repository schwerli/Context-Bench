{
  "instance_id": "Multi-SWE-Bench__c__maintenance__bugfix__5dc9809e",
  "original_id": "ponylang__ponyc-1057",
  "1_model_selected_files": [],
  "2_embedding_selected_files": [
    "src/libponyc/type/safeto.c",
    "src/libponyc/type/alias.c",
    "src/libponyc/expr/array.c",
    "src/libponyc/expr/call.c",
    "src/libponyc/pass/finalisers.c",
    "src/libponyc/expr/control.c",
    "src/libponyc/expr/reference.c",
    "src/libponyc/expr/operator.c",
    "src/libponyc/type/cap.c",
    "src/libponyc/type/reify.c",
    "src/libponyc/pass/traits.c",
    "src/libponyc/type/safeto.h",
    "src/libponyc/pass/names.c",
    "src/libponyc/pass/sugar.c",
    "src/libponyc/expr/array.h",
    "src/libponyc/pass/expr.c",
    "src/libponyc/pass/syntax.c",
    "src/libponyc/type/reify.h",
    "src/libponyc/expr/ffi.c",
    "src/libponyc/expr/postfix.c",
    "src/libponyc/type/viewpoint.c",
    "src/libponyc/expr/lambda.c",
    "src/libponyc/type/subtype.c",
    "src/libponyc/type/assemble.c",
    "src/libponyc/expr/reference.h",
    "src/libponyc/expr/literal.c"
  ],
  "3_final_combined_files": [
    "src/libponyc/type/safeto.c",
    "src/libponyc/type/alias.c",
    "src/libponyc/expr/array.c"
  ],
  "4_related_elements": {
    "src/libponyc/type/safeto.c": [
      "function: safe_field_write\nfunction: safe_to_write\nfunction: safe_to_autorecover"
    ],
    "src/libponyc/type/alias.c": [
      "function: sendable\nfunction: recover_type\nfunction: recover_single\nfunction: alias\nfunction: alias_single"
    ],
    "src/libponyc/expr/array.c": [
      ""
    ]
  },
  "5_sampled_edit_locs_and_patches": [
    {
      "sample_index": 0,
      "edit_locs": {
        "src/libponyc/type/safeto.c": [
          "line: 4\nfunction: safe_to_autorecover"
        ],
        "src/libponyc/type/alias.c": [
          ""
        ],
        "src/libponyc/expr/array.c": [
          ""
        ]
      },
      "patches": [
        "diff --git a/src/libponyc/type/alias.c b/src/libponyc/type/alias.c\nindex 7a3fb21..0401c5b 100644\n--- a/src/libponyc/type/alias.c\n+++ b/src/libponyc/type/alias.c\n@@ -415,14 +415,11 @@ bool sendable(ast_t* type)\n \n     case TK_ARROW:\n     {\n-      ast_t* lower = viewpoint_lower(type);\n-\n-      if(lower == NULL)\n-        return false;\n-\n-      bool ok = sendable(lower);\n-      ast_free_unattached(lower);\n-      return ok;\n+      // For viewpoint adapted types (e.g. tag->T), determine sendability\n+      // based on the target type itself. This allows accessing sendable\n+      // fields (like val) through a tag receiver in recover expressions.\n+      AST_GET_CHILDREN(type, left, right);\n+      return sendable(right);\n     }\n \n     case TK_NOMINAL:\n@@ -447,4 +444,4 @@ bool sendable(ast_t* type)\n \n   assert(0);\n   return false;\n-}\n+}\n",
        "diff --git a/src/libponyc/type/safeto.c b/src/libponyc/type/safeto.c\nindex 9c1d2ed..9ce025c 100644\n--- a/src/libponyc/type/safeto.c\n+++ b/src/libponyc/type/safeto.c\n@@ -1,3 +1,4 @@\n+\n #include \"safeto.h\"\n #include \"cap.h\"\n #include \"viewpoint.h\"\n@@ -159,9 +160,31 @@ bool safe_to_autorecover(ast_t* receiver_type, ast_t* type)\n     case TK_NOMINAL:\n     case TK_TYPEPARAMREF:\n     {\n+      token_id rcap = cap_single(receiver_type);\n+\n+      // If we are viewing the receiver through tag, allow reading sendable\n+      // fields (ie, val or tag) in a recover expression.\n+      if(rcap == TK_TAG)\n+      {\n+        switch(ast_id(type))\n+        {\n+          case TK_NOMINAL:\n+          case TK_TYPEPARAMREF:\n+          {\n+            token_id tcap = cap_single(type);\n+            if((tcap == TK_VAL) || (tcap == TK_TAG))\n+              return true;\n+            break;\n+          }\n+\n+          default:\n+            break;\n+        }\n+      }\n+\n       // An argument or result is safe for autorecover if it would be safe to\n       // write into the receiver.\n-      return safe_field_write(cap_single(receiver_type), type);\n+      return safe_field_write(rcap, type);\n     }\n \n     case TK_ARROW:\n"
      ]
    },
    {
      "sample_index": 1,
      "edit_locs": {
        "src/libponyc/type/alias.c": [
          "function: sendable\nline: 419\nline: 424"
        ],
        "src/libponyc/type/safeto.c": [
          ""
        ],
        "src/libponyc/expr/array.c": [
          ""
        ]
      },
      "patches": [
        "diff --git a/src/libponyc/type/alias.c b/src/libponyc/type/alias.c\nindex 7a3fb21..0acc932 100644\n--- a/src/libponyc/type/alias.c\n+++ b/src/libponyc/type/alias.c\n@@ -418,7 +418,38 @@ bool sendable(ast_t* type)\n       ast_t* lower = viewpoint_lower(type);\n \n       if(lower == NULL)\n+      {\n+        // If we cannot compute a lower type (eg. reading through a tag),\n+        // allow it if the viewpoint is tag and the referenced type itself\n+        // is sendable.\n+        ast_t* l = ast_child(type);\n+        ast_t* r = ast_sibling(l);\n+\n+        bool left_is_tag = false;\n+\n+        switch(ast_id(l))\n+        {\n+          case TK_NOMINAL:\n+          {\n+            AST_GET_CHILDREN(l, pkg, id, typeparams, cap, eph);\n+            left_is_tag = (ast_id(cap) == TK_TAG);\n+            break;\n+          }\n+          case TK_TYPEPARAMREF:\n+          {\n+            AST_GET_CHILDREN(l, id, cap, eph);\n+            left_is_tag = (ast_id(cap) == TK_TAG);\n+            break;\n+          }\n+          default:\n+            break;\n+        }\n+\n+        if(left_is_tag && (r != NULL) && sendable(r))\n+          return true;\n+\n         return false;\n+      }\n \n       bool ok = sendable(lower);\n       ast_free_unattached(lower);\n@@ -447,4 +478,4 @@ bool sendable(ast_t* type)\n \n   assert(0);\n   return false;\n-}\n+}\n"
      ]
    }
  ],
  "6_final_selected_patch": "diff --git a/src/libponyc/type/safeto.c b/src/libponyc/type/safeto.c\nindex 9c1d2ed..9ce025c 100644\n--- a/src/libponyc/type/safeto.c\n+++ b/src/libponyc/type/safeto.c\n@@ -1,3 +1,4 @@\n+\n #include \"safeto.h\"\n #include \"cap.h\"\n #include \"viewpoint.h\"\n@@ -159,9 +160,31 @@ bool safe_to_autorecover(ast_t* receiver_type, ast_t* type)\n     case TK_NOMINAL:\n     case TK_TYPEPARAMREF:\n     {\n+      token_id rcap = cap_single(receiver_type);\n+\n+      // If we are viewing the receiver through tag, allow reading sendable\n+      // fields (ie, val or tag) in a recover expression.\n+      if(rcap == TK_TAG)\n+      {\n+        switch(ast_id(type))\n+        {\n+          case TK_NOMINAL:\n+          case TK_TYPEPARAMREF:\n+          {\n+            token_id tcap = cap_single(type);\n+            if((tcap == TK_VAL) || (tcap == TK_TAG))\n+              return true;\n+            break;\n+          }\n+\n+          default:\n+            break;\n+        }\n+      }\n+\n       // An argument or result is safe for autorecover if it would be safe to\n       // write into the receiver.\n-      return safe_field_write(cap_single(receiver_type), type);\n+      return safe_field_write(rcap, type);\n     }\n \n     case TK_ARROW:\n",
  "7_resolved": false
}