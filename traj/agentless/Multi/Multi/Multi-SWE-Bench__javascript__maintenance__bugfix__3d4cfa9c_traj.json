{
  "instance_id": "Multi-SWE-Bench__javascript__maintenance__bugfix__3d4cfa9c",
  "original_id": "sveltejs__svelte-14276",
  "1_model_selected_files": [],
  "2_embedding_selected_files": [
    "packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js",
    "packages/svelte/src/compiler/phases/3-transform/css/index.js",
    "packages/svelte/src/compiler/phases/1-parse/read/style.js",
    "packages/svelte/src/compiler/phases/2-analyze/css/css-warn.js",
    "packages/svelte/src/compiler/warnings.js",
    "packages/svelte/src/compiler/errors.js",
    "packages/svelte/src/compiler/types/css.d.ts",
    "packages/svelte/src/compiler/phases/2-analyze/css/css-analyze.js",
    "packages/svelte/src/compiler/validate-options.js",
    "packages/svelte/src/internal/client/warnings.js",
    "packages/svelte/src/internal/shared/warnings.js",
    "packages/svelte/src/compiler/phases/2-analyze/visitors/shared/a11y.js",
    "packages/svelte/src/utils.js",
    "packages/svelte/src/compiler/phases/css.js",
    "packages/svelte/src/compiler/phases/1-parse/state/element.js",
    "packages/svelte/types/index.d.ts",
    "packages/svelte/src/compiler/phases/3-transform/server/visitors/shared/element.js",
    "packages/svelte/src/compiler/phases/3-transform/client/visitors/RegularElement.js",
    "packages/svelte/src/compiler/phases/2-analyze/visitors/shared/element.js",
    "packages/svelte/src/compiler/phases/2-analyze/visitors/shared/attribute.js",
    "packages/svelte/src/compiler/types/legacy-nodes.d.ts",
    "packages/svelte/src/compiler/phases/3-transform/client/visitors/SvelteElement.js",
    "packages/svelte/src/internal/client/errors.js",
    "packages/svelte/src/compiler/migrate/index.js",
    "packages/svelte/src/compiler/phases/2-analyze/visitors/StyleDirective.js",
    "packages/svelte/src/compiler/phases/2-analyze/visitors/BindDirective.js"
  ],
  "3_final_combined_files": [
    "packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js",
    "packages/svelte/src/compiler/phases/3-transform/css/index.js",
    "packages/svelte/src/compiler/phases/1-parse/read/style.js"
  ],
  "4_related_elements": {
    "packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js": [
      "function: prune\nfunction: get_relative_selectors\nfunction: truncate\nfunction: apply_selector\nfunction: apply_combinator\nfunction: relative_selector_might_apply_to_node\nfunction: attribute_matches\nfunction: test_attribute\nfunction: is_global\nfunction: mark\nfunction: unquote\nvariable: whitelist_attribute_selector\nvariable: regex_backslash_and_following_character"
    ],
    "packages/svelte/src/compiler/phases/3-transform/css/index.js": [
      "function: render_stylesheet\nfunction: is_used"
    ],
    "packages/svelte/src/compiler/phases/1-parse/read/style.js": [
      "function: read_selector\nfunction: read_attribute_value\nvariable: REGEX_MATCHER\nvariable: REGEX_ATTRIBUTE_FLAGS"
    ]
  },
  "5_sampled_edit_locs_and_patches": [
    {
      "sample_index": 0,
      "edit_locs": {
        "packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js": [
          "function: relative_selector_might_apply_to_node\nline: 609\nline: 610\nline: 611\nline: 612\nline: 613\nline: 614\nline: 615\nline: 616\nline: 617\nline: 618\nline: 619\nline: 620\nline: 621\nline: 622\nline: 623\nline: 624\nfunction: attribute_matches\nline: 765\nline: 766\nline: 767\nline: 768\nline: 769\nline: 770\nline: 771\nline: 772\nline: 773\nline: 774\nline: 775\nline: 776\nline: 777\nline: 778\nline: 779\nline: 780\nline: 781\nline: 782\nline: 783\nline: 784\nline: 785\nline: 786\nline: 787\nline: 788\nline: 789\nline: 790\nline: 791\nline: 792\nline: 793\nline: 794\nline: 795\nline: 796\nline: 797\nline: 798\nline: 799\nline: 800\nline: 801\nline: 802\nline: 803\nline: 804\nline: 805\nline: 806\nline: 807\nline: 808\nline: 809\nline: 810\nline: 811\nline: 812\nline: 813\nline: 814\nline: 815\nline: 816\nline: 817\nline: 818\nline: 819\nline: 820\nline: 821\nline: 822\nline: 823\nline: 824\nline: 825\nline: 826\nline: 827\nline: 828\nline: 829\nline: 830\nline: 831\nline: 832\nline: 833\nline: 834\nline: 835\nline: 836\nline: 837\nline: 838\nline: 839\nline: 840\nline: 841\nline: 842\nline: 843\nline: 844\nline: 845\nline: 846\nline: 847\nline: 848\nline: 849\nline: 850\nline: 851\nline: 852\nline: 853\nline: 854\nline: 855"
        ],
        "packages/svelte/src/compiler/phases/3-transform/css/index.js": [
          "function: is_used\nline: 418\nline: 419\nline: 420\nline: 421\nline: 422\nline: 423"
        ],
        "packages/svelte/src/compiler/phases/1-parse/read/style.js": [
          ""
        ]
      },
      "patches": [
        "diff --git a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\nindex f6cab50..4c0e179 100644\n--- a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n+++ b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n@@ -608,8 +608,13 @@ function relative_selector_might_apply_to_node(relative_selector, rule, element,\n \n \t\t\tcase 'AttributeSelector': {\n \t\t\t\tconst whitelisted = whitelist_attribute_selector.get(element.name.toLowerCase());\n+\t\t\t\tconst attr_lower = selector.name.toLowerCase();\n+\t\t\t\t// Relax matching for data-* and aria-* attributes since their values are often dynamic\n+\t\t\t\tconst is_relaxed_attr = attr_lower.startsWith('data-') || attr_lower.startsWith('aria-');\n+\n \t\t\t\tif (\n-\t\t\t\t\t!whitelisted?.includes(selector.name.toLowerCase()) &&\n+\t\t\t\t\t!is_relaxed_attr &&\n+\t\t\t\t\t!whitelisted?.includes(attr_lower) &&\n \t\t\t\t\t!attribute_matches(\n \t\t\t\t\t\telement,\n \t\t\t\t\t\tselector.name,\n",
        "diff --git a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\nindex f6cab50..a2f301a 100644\n--- a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n+++ b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n@@ -777,78 +777,9 @@ function attribute_matches(node, name, expected_value, operator, case_insensitiv\n \t\t\treturn test_attribute(operator, expected_value, case_insensitive, attribute.value[0].data);\n \t\t}\n \n-\t\tconst chunks = get_attribute_chunks(attribute.value);\n-\t\tconst possible_values = new Set();\n-\n-\t\t/** @type {string[]} */\n-\t\tlet prev_values = [];\n-\t\tfor (const chunk of chunks) {\n-\t\t\tconst current_possible_values = get_possible_values(chunk);\n-\n-\t\t\t// impossible to find out all combinations\n-\t\t\tif (!current_possible_values) return true;\n-\n-\t\t\tif (prev_values.length > 0) {\n-\t\t\t\t/** @type {string[]} */\n-\t\t\t\tconst start_with_space = [];\n-\n-\t\t\t\t/** @type {string[]} */\n-\t\t\t\tconst remaining = [];\n-\n-\t\t\t\tcurrent_possible_values.forEach((current_possible_value) => {\n-\t\t\t\t\tif (regex_starts_with_whitespace.test(current_possible_value)) {\n-\t\t\t\t\t\tstart_with_space.push(current_possible_value);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tremaining.push(current_possible_value);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\tif (remaining.length > 0) {\n-\t\t\t\t\tif (start_with_space.length > 0) {\n-\t\t\t\t\t\tprev_values.forEach((prev_value) => possible_values.add(prev_value));\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t/** @type {string[]} */\n-\t\t\t\t\tconst combined = [];\n-\n-\t\t\t\t\tprev_values.forEach((prev_value) => {\n-\t\t\t\t\t\tremaining.forEach((value) => {\n-\t\t\t\t\t\t\tcombined.push(prev_value + value);\n-\t\t\t\t\t\t});\n-\t\t\t\t\t});\n-\t\t\t\t\tprev_values = combined;\n-\t\t\t\t\tstart_with_space.forEach((value) => {\n-\t\t\t\t\t\tif (regex_ends_with_whitespace.test(value)) {\n-\t\t\t\t\t\t\tpossible_values.add(value);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tprev_values.push(value);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n-\t\t\t\t\tcontinue;\n-\t\t\t\t} else {\n-\t\t\t\t\tprev_values.forEach((prev_value) => possible_values.add(prev_value));\n-\t\t\t\t\tprev_values = [];\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcurrent_possible_values.forEach((current_possible_value) => {\n-\t\t\t\tif (regex_ends_with_whitespace.test(current_possible_value)) {\n-\t\t\t\t\tpossible_values.add(current_possible_value);\n-\t\t\t\t} else {\n-\t\t\t\t\tprev_values.push(current_possible_value);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tif (prev_values.length < current_possible_values.size) {\n-\t\t\t\tprev_values.push(' ');\n-\t\t\t}\n-\t\t\tif (prev_values.length > 20) {\n-\t\t\t\t// might grow exponentially, bail out\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\tprev_values.forEach((prev_value) => possible_values.add(prev_value));\n-\n-\t\tfor (const value of possible_values) {\n-\t\t\tif (test_attribute(operator, expected_value, case_insensitive, value)) return true;\n-\t\t}\n+\t\t// For non-text (dynamic) attributes, we can't reliably determine their runtime value.\n+\t\t// Be conservative and consider the selector a possible match to avoid false negatives.\n+\t\treturn true;\n \t}\n \n \treturn false;\n"
      ]
    },
    {
      "sample_index": 1,
      "edit_locs": {
        "packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js": [
          "function: relative_selector_might_apply_to_node\nfunction: attribute_matches"
        ],
        "packages/svelte/src/compiler/phases/3-transform/css/index.js": [
          ""
        ],
        "packages/svelte/src/compiler/phases/1-parse/read/style.js": [
          ""
        ]
      },
      "patches": [
        "diff --git a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\nindex f6cab50..1017ecb 100644\n--- a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n+++ b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n@@ -608,17 +608,30 @@ function relative_selector_might_apply_to_node(relative_selector, rule, element,\n \n \t\t\tcase 'AttributeSelector': {\n \t\t\t\tconst whitelisted = whitelist_attribute_selector.get(element.name.toLowerCase());\n-\t\t\t\tif (\n-\t\t\t\t\t!whitelisted?.includes(selector.name.toLowerCase()) &&\n-\t\t\t\t\t!attribute_matches(\n-\t\t\t\t\t\telement,\n-\t\t\t\t\t\tselector.name,\n-\t\t\t\t\t\tselector.value && unquote(selector.value),\n-\t\t\t\t\t\tselector.matcher,\n-\t\t\t\t\t\tselector.flags?.includes('i') ?? false\n-\t\t\t\t\t)\n-\t\t\t\t) {\n-\t\t\t\t\treturn false;\n+\t\t\t\tconst attr_name = selector.name.toLowerCase();\n+\t\t\t\tconst matches = attribute_matches(\n+\t\t\t\t\telement,\n+\t\t\t\t\tselector.name,\n+\t\t\t\t\tselector.value && unquote(selector.value),\n+\t\t\t\t\tselector.matcher,\n+\t\t\t\t\tselector.flags?.includes('i') ?? false\n+\t\t\t\t);\n+\n+\t\t\t\tif (!whitelisted?.includes(attr_name) && !matches) {\n+\t\t\t\t\t// Relax attribute verification: if the attribute exists on the element in the template\n+\t\t\t\t\t// (or via spread/bind), consider it a potential match even if the exact value can't be confirmed.\n+\t\t\t\t\tconst has_attribute =\n+\t\t\t\t\t\telement.attributes.some(\n+\t\t\t\t\t\t\t(attribute) =>\n+\t\t\t\t\t\t\t\t(attribute.type === 'Attribute' &&\n+\t\t\t\t\t\t\t\t\tattribute.name.toLowerCase() === attr_name) ||\n+\t\t\t\t\t\t\t\t(attribute.type === 'BindDirective' && attribute.name === attr_name) ||\n+\t\t\t\t\t\t\t\tattribute.type === 'SpreadAttribute'\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\tif (!has_attribute) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n",
        "diff --git a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\nindex f6cab50..358d8f3 100644\n--- a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n+++ b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n@@ -615,7 +615,8 @@ function relative_selector_might_apply_to_node(relative_selector, rule, element,\n \t\t\t\t\t\tselector.name,\n \t\t\t\t\t\tselector.value && unquote(selector.value),\n \t\t\t\t\t\tselector.matcher,\n-\t\t\t\t\t\tselector.flags?.includes('i') ?? false\n+\t\t\t\t\t\tselector.flags?.includes('i') ?? false,\n+\t\t\t\t\t\t/* relax_dynamic */ true\n \t\t\t\t\t)\n \t\t\t\t) {\n \t\t\t\t\treturn false;\n@@ -625,7 +626,7 @@ function relative_selector_might_apply_to_node(relative_selector, rule, element,\n \n \t\t\tcase 'ClassSelector': {\n \t\t\t\tif (\n-\t\t\t\t\t!attribute_matches(element, 'class', name, '~=', false) &&\n+\t\t\t\t\t!attribute_matches(element, 'class', name, '~=', false, /* relax_dynamic */ false) &&\n \t\t\t\t\t!element.attributes.some(\n \t\t\t\t\t\t(attribute) => attribute.type === 'ClassDirective' && attribute.name === name\n \t\t\t\t\t)\n@@ -637,7 +638,7 @@ function relative_selector_might_apply_to_node(relative_selector, rule, element,\n \t\t\t}\n \n \t\t\tcase 'IdSelector': {\n-\t\t\t\tif (!attribute_matches(element, 'id', name, '=', false)) {\n+\t\t\t\tif (!attribute_matches(element, 'id', name, '=', false, /* relax_dynamic */ false)) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \n@@ -761,8 +762,9 @@ function test_attribute(operator, expected_value, case_insensitive, value) {\n  * @param {string | null} expected_value\n  * @param {string | null} operator\n  * @param {boolean} case_insensitive\n+ * @param {boolean} [relax_dynamic=false] If true, treat non-text (dynamic) attribute values as potentially matching.\n  */\n-function attribute_matches(node, name, expected_value, operator, case_insensitive) {\n+function attribute_matches(node, name, expected_value, operator, case_insensitive, relax_dynamic = false) {\n \tfor (const attribute of node.attributes) {\n \t\tif (attribute.type === 'SpreadAttribute') return true;\n \t\tif (attribute.type === 'BindDirective' && attribute.name === name) return true;\n@@ -777,6 +779,12 @@ function attribute_matches(node, name, expected_value, operator, case_insensitiv\n \t\t\treturn test_attribute(operator, expected_value, case_insensitive, attribute.value[0].data);\n \t\t}\n \n+\t\t// For non-text (dynamic) attribute values, optionally relax matching to avoid false negatives.\n+\t\t// This is used for general attribute selectors like [data-foo=\"bar\"], but not for class/id selectors.\n+\t\tif (relax_dynamic) {\n+\t\t\treturn true;\n+\t\t}\n+\n \t\tconst chunks = get_attribute_chunks(attribute.value);\n \t\tconst possible_values = new Set();\n \n"
      ]
    }
  ],
  "6_final_selected_patch": "diff --git a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\nindex f6cab50..a2f301a 100644\n--- a/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n+++ b/packages/svelte/src/compiler/phases/2-analyze/css/css-prune.js\n@@ -777,78 +777,9 @@ function attribute_matches(node, name, expected_value, operator, case_insensitiv\n \t\t\treturn test_attribute(operator, expected_value, case_insensitive, attribute.value[0].data);\n \t\t}\n \n-\t\tconst chunks = get_attribute_chunks(attribute.value);\n-\t\tconst possible_values = new Set();\n-\n-\t\t/** @type {string[]} */\n-\t\tlet prev_values = [];\n-\t\tfor (const chunk of chunks) {\n-\t\t\tconst current_possible_values = get_possible_values(chunk);\n-\n-\t\t\t// impossible to find out all combinations\n-\t\t\tif (!current_possible_values) return true;\n-\n-\t\t\tif (prev_values.length > 0) {\n-\t\t\t\t/** @type {string[]} */\n-\t\t\t\tconst start_with_space = [];\n-\n-\t\t\t\t/** @type {string[]} */\n-\t\t\t\tconst remaining = [];\n-\n-\t\t\t\tcurrent_possible_values.forEach((current_possible_value) => {\n-\t\t\t\t\tif (regex_starts_with_whitespace.test(current_possible_value)) {\n-\t\t\t\t\t\tstart_with_space.push(current_possible_value);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tremaining.push(current_possible_value);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\tif (remaining.length > 0) {\n-\t\t\t\t\tif (start_with_space.length > 0) {\n-\t\t\t\t\t\tprev_values.forEach((prev_value) => possible_values.add(prev_value));\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t/** @type {string[]} */\n-\t\t\t\t\tconst combined = [];\n-\n-\t\t\t\t\tprev_values.forEach((prev_value) => {\n-\t\t\t\t\t\tremaining.forEach((value) => {\n-\t\t\t\t\t\t\tcombined.push(prev_value + value);\n-\t\t\t\t\t\t});\n-\t\t\t\t\t});\n-\t\t\t\t\tprev_values = combined;\n-\t\t\t\t\tstart_with_space.forEach((value) => {\n-\t\t\t\t\t\tif (regex_ends_with_whitespace.test(value)) {\n-\t\t\t\t\t\t\tpossible_values.add(value);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tprev_values.push(value);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n-\t\t\t\t\tcontinue;\n-\t\t\t\t} else {\n-\t\t\t\t\tprev_values.forEach((prev_value) => possible_values.add(prev_value));\n-\t\t\t\t\tprev_values = [];\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcurrent_possible_values.forEach((current_possible_value) => {\n-\t\t\t\tif (regex_ends_with_whitespace.test(current_possible_value)) {\n-\t\t\t\t\tpossible_values.add(current_possible_value);\n-\t\t\t\t} else {\n-\t\t\t\t\tprev_values.push(current_possible_value);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tif (prev_values.length < current_possible_values.size) {\n-\t\t\t\tprev_values.push(' ');\n-\t\t\t}\n-\t\t\tif (prev_values.length > 20) {\n-\t\t\t\t// might grow exponentially, bail out\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\tprev_values.forEach((prev_value) => possible_values.add(prev_value));\n-\n-\t\tfor (const value of possible_values) {\n-\t\t\tif (test_attribute(operator, expected_value, case_insensitive, value)) return true;\n-\t\t}\n+\t\t// For non-text (dynamic) attributes, we can't reliably determine their runtime value.\n+\t\t// Be conservative and consider the selector a possible match to avoid false negatives.\n+\t\treturn true;\n \t}\n \n \treturn false;\n",
  "7_resolved": false
}