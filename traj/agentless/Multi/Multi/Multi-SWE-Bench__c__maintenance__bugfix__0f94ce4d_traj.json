{
  "instance_id": "Multi-SWE-Bench__c__maintenance__bugfix__0f94ce4d",
  "original_id": "ponylang__ponyc-1124",
  "1_model_selected_files": [],
  "2_embedding_selected_files": [
    "src/libponyc/type/alias.c",
    "src/libponyc/type/safeto.c",
    "src/libponyc/expr/reference.c",
    "src/libponyc/expr/postfix.c",
    "src/libponyc/verify/fun.c",
    "src/libponyc/type/viewpoint.c",
    "src/libponyc/pass/sugar.c",
    "src/libponyc/type/cap.c",
    "src/libponyc/type/reify.c",
    "src/libponyc/expr/operator.c",
    "src/libponyc/pass/names.c",
    "src/libponyc/pass/finalisers.c",
    "src/libponyc/expr/match.c",
    "src/libponyc/type/reify.h",
    "src/libponyc/type/typeparam.c",
    "src/libponyc/expr/call.c",
    "src/libponyc/pass/syntax.c",
    "src/libponyc/type/assemble.c",
    "src/libponyc/expr/ffi.c",
    "src/libponyc/pass/traits.c",
    "src/libponyc/verify/call.c",
    "src/libponyc/type/subtype.c",
    "src/libponyc/expr/control.c",
    "src/libponyc/expr/lambda.c",
    "src/libponyc/type/compattype.c",
    "src/libponyc/pass/import.c",
    "src/libponyc/type/alias.h",
    "src/libponyc/pass/verify.c"
  ],
  "3_final_combined_files": [
    "src/libponyc/type/alias.c",
    "src/libponyc/type/safeto.c",
    "src/libponyc/expr/reference.c"
  ],
  "4_related_elements": {
    "src/libponyc/type/alias.c": [
      "function: alias_single\nfunction: recover_single\nfunction: recover_type\nfunction: alias\nfunction: consume_single\nfunction: consume_type\nfunction: sendable"
    ],
    "src/libponyc/type/safeto.c": [
      "function: safe_field_write\nfunction: safe_to_write\nfunction: safe_to_autorecover"
    ],
    "src/libponyc/expr/reference.c": [
      "function: expr_tuple\nfunction: expr_reference\nfunction: expr_fieldref"
    ]
  },
  "5_sampled_edit_locs_and_patches": [
    {
      "sample_index": 0,
      "edit_locs": {
        "src/libponyc/type/alias.c": [
          "function: recover_type\nfunction: alias"
        ],
        "src/libponyc/type/safeto.c": [
          "function: safe_to_autorecover"
        ],
        "src/libponyc/expr/reference.c": [
          "function: expr_tuple"
        ]
      },
      "patches": [
        "diff --git a/src/libponyc/type/safeto.c b/src/libponyc/type/safeto.c\nindex 9c1d2ed..d27ca48 100644\n--- a/src/libponyc/type/safeto.c\n+++ b/src/libponyc/type/safeto.c\n@@ -156,6 +156,32 @@ bool safe_to_autorecover(ast_t* receiver_type, ast_t* type)\n       return true;\n     }\n \n+    case TK_TUPLETYPE:\n+    {\n+      // For tuples, both the receiver and the type must be tuples of the same\n+      // arity, and each corresponding element must be safe to autorecover.\n+      if(ast_id(type) != TK_TUPLETYPE)\n+        return false;\n+\n+      ast_t* r_child = ast_child(receiver_type);\n+      ast_t* t_child = ast_child(type);\n+\n+      while((r_child != NULL) && (t_child != NULL))\n+      {\n+        if(!safe_to_autorecover(r_child, t_child))\n+          return false;\n+\n+        r_child = ast_sibling(r_child);\n+        t_child = ast_sibling(t_child);\n+      }\n+\n+      // Arity must match.\n+      if((r_child != NULL) || (t_child != NULL))\n+        return false;\n+\n+      return true;\n+    }\n+\n     case TK_NOMINAL:\n     case TK_TYPEPARAMREF:\n     {\n@@ -187,4 +213,4 @@ bool safe_to_autorecover(ast_t* receiver_type, ast_t* type)\n \n   assert(0);\n   return false;\n-}\n+}\n",
        "diff --git a/src/libponyc/type/alias.c b/src/libponyc/type/alias.c\nindex 7a3fb21..63ee045 100644\n--- a/src/libponyc/type/alias.c\n+++ b/src/libponyc/type/alias.c\n@@ -1,3 +1,4 @@\n+\n #include \"alias.h\"\n #include \"viewpoint.h\"\n #include \"cap.h\"\n@@ -15,7 +16,7 @@ static ast_t* alias_single(ast_t* type)\n     case TK_EPHEMERAL:\n       type = ast_dup(type);\n       ephemeral = ast_sibling(cap_fetch(type));\n-      ast_setid(ephemeral, TK_NONE);\n+      ast_setid(ephemeral, TK_BORROWED);\n       return type;\n \n     case TK_NONE:\n@@ -352,6 +353,9 @@ ast_t* recover_type(ast_t* type, token_id cap)\n           return NULL;\n         }\n \n+        // Alias each recovered element to avoid multiple mutable aliases\n+        r_right = alias(r_right);\n+\n         ast_append(r_type, r_right);\n         child = ast_sibling(child);\n       }\n@@ -447,4 +451,4 @@ bool sendable(ast_t* type)\n \n   assert(0);\n   return false;\n-}\n+}\n"
      ]
    },
    {
      "sample_index": 1,
      "edit_locs": {
        "src/libponyc/expr/reference.c": [
          "function: expr_tuple\nline: 1064\nline: 1104"
        ],
        "src/libponyc/type/alias.c": [
          "function: alias_single\nline: 8\nline: 49\nfunction: recover_type\nline: 333\nline: 392"
        ],
        "src/libponyc/type/safeto.c": [
          "function: safe_to_autorecover\nline: 124\nline: 190"
        ]
      },
      "patches": [
        "diff --git a/src/libponyc/type/alias.c b/src/libponyc/type/alias.c\nindex 7a3fb21..f3d3001 100644\n--- a/src/libponyc/type/alias.c\n+++ b/src/libponyc/type/alias.c\n@@ -1,3 +1,4 @@\n+\n #include \"alias.h\"\n #include \"viewpoint.h\"\n #include \"cap.h\"\n@@ -24,6 +25,7 @@ static ast_t* alias_single(ast_t* type)\n       {\n         case TK_ISO:\n         case TK_TRN:\n+        case TK_REF:\n         case TK_CAP_SEND:\n         case TK_CAP_ANY:\n         case TK_NONE:\n@@ -73,12 +75,19 @@ static ast_t* recover_single(ast_t* type, token_id rcap)\n \n     case TK_TRN:\n     case TK_REF:\n+    {\n+      // Borrowed references cannot be recovered to iso.\n+      ast_t* eph = ast_sibling(cap);\n+      if(ast_id(eph) == TK_BORROWED)\n+        return NULL;\n+\n       // These recover as iso, so any rcap is acceptable. We also set the rcap\n       // as ephemeral to allow direct recovery to iso or trn.\n       if(rcap == TK_NONE)\n         rcap = TK_ISO;\n       rec_eph = true;\n       break;\n+    }\n \n     case TK_VAL:\n     case TK_BOX:\n@@ -447,4 +456,4 @@ bool sendable(ast_t* type)\n \n   assert(0);\n   return false;\n-}\n+}\n",
        "diff --git a/src/libponyc/expr/reference.c b/src/libponyc/expr/reference.c\nindex 9e72bd9..e8867bc 100644\n--- a/src/libponyc/expr/reference.c\n+++ b/src/libponyc/expr/reference.c\n@@ -1094,7 +1094,7 @@ bool expr_tuple(pass_opt_t* opt, ast_t* ast)\n         return true;\n       }\n \n-      ast_append(type, c_type);\n+      ast_append(type, alias(c_type));\n       child = ast_sibling(child);\n     }\n   }\ndiff --git a/src/libponyc/type/alias.c b/src/libponyc/type/alias.c\nindex 7a3fb21..a0c2cf4 100644\n--- a/src/libponyc/type/alias.c\n+++ b/src/libponyc/type/alias.c\n@@ -1,3 +1,4 @@\n+\n #include \"alias.h\"\n #include \"viewpoint.h\"\n #include \"cap.h\"\n@@ -24,6 +25,7 @@ static ast_t* alias_single(ast_t* type)\n       {\n         case TK_ISO:\n         case TK_TRN:\n+        case TK_REF:\n         case TK_CAP_SEND:\n         case TK_CAP_ANY:\n         case TK_NONE:\n@@ -73,12 +75,21 @@ static ast_t* recover_single(ast_t* type, token_id rcap)\n \n     case TK_TRN:\n     case TK_REF:\n-      // These recover as iso, so any rcap is acceptable. We also set the rcap\n-      // as ephemeral to allow direct recovery to iso or trn.\n+    {\n+      // These recover as iso, so any rcap is acceptable in the non-aliased case.\n+      // If the reference is marked as borrowed (aliased), recovery is not allowed,\n+      // since uniqueness cannot be guaranteed across tuple elements.\n+      ast_t* eph = ast_sibling(cap);\n+\n+      if(ast_id(eph) == TK_BORROWED)\n+        return NULL;\n+\n       if(rcap == TK_NONE)\n         rcap = TK_ISO;\n+\n       rec_eph = true;\n       break;\n+    }\n \n     case TK_VAL:\n     case TK_BOX:\n@@ -336,7 +347,6 @@ ast_t* recover_type(ast_t* type, token_id cap)\n   {\n     case TK_UNIONTYPE:\n     case TK_ISECTTYPE:\n-    case TK_TUPLETYPE:\n     {\n       // recover each element\n       ast_t* r_type = ast_from(type, ast_id(type));\n@@ -359,6 +369,32 @@ ast_t* recover_type(ast_t* type, token_id cap)\n       return r_type;\n     }\n \n+    case TK_TUPLETYPE:\n+    {\n+      // Alias the tuple elements first to detect potential aliasing across members\n+      ast_t* r_type = ast_from(type, TK_TUPLETYPE);\n+      ast_t* aliased = alias(type);\n+      ast_t* child = ast_child(aliased);\n+\n+      while(child != NULL)\n+      {\n+        ast_t* r_right = recover_type(child, cap);\n+\n+        if(r_right == NULL)\n+        {\n+          ast_free_unattached(r_type);\n+          ast_free_unattached(aliased);\n+          return NULL;\n+        }\n+\n+        ast_append(r_type, r_right);\n+        child = ast_sibling(child);\n+      }\n+\n+      ast_free_unattached(aliased);\n+      return r_type;\n+    }\n+\n     case TK_NOMINAL:\n     case TK_TYPEPARAMREF:\n       return recover_single(type, cap);\n@@ -447,4 +483,4 @@ bool sendable(ast_t* type)\n \n   assert(0);\n   return false;\n-}\n+}\n"
      ]
    }
  ],
  "6_final_selected_patch": "diff --git a/src/libponyc/type/alias.c b/src/libponyc/type/alias.c\nindex 7a3fb21..63ee045 100644\n--- a/src/libponyc/type/alias.c\n+++ b/src/libponyc/type/alias.c\n@@ -1,3 +1,4 @@\n+\n #include \"alias.h\"\n #include \"viewpoint.h\"\n #include \"cap.h\"\n@@ -15,7 +16,7 @@ static ast_t* alias_single(ast_t* type)\n     case TK_EPHEMERAL:\n       type = ast_dup(type);\n       ephemeral = ast_sibling(cap_fetch(type));\n-      ast_setid(ephemeral, TK_NONE);\n+      ast_setid(ephemeral, TK_BORROWED);\n       return type;\n \n     case TK_NONE:\n@@ -352,6 +353,9 @@ ast_t* recover_type(ast_t* type, token_id cap)\n           return NULL;\n         }\n \n+        // Alias each recovered element to avoid multiple mutable aliases\n+        r_right = alias(r_right);\n+\n         ast_append(r_type, r_right);\n         child = ast_sibling(child);\n       }\n@@ -447,4 +451,4 @@ bool sendable(ast_t* type)\n \n   assert(0);\n   return false;\n-}\n+}\n",
  "7_resolved": false
}