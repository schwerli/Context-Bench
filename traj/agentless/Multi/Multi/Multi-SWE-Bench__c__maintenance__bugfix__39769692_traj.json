{
  "instance_id": "Multi-SWE-Bench__c__maintenance__bugfix__39769692",
  "original_id": "ponylang__ponyc-2168",
  "1_model_selected_files": [],
  "2_embedding_selected_files": [
    "src/libponyc/expr/lambda.c",
    "src/libponyc/pass/sugar.c",
    "src/libponyc/expr/array.c",
    "src/libponyc/pass/syntax.c",
    "src/libponyc/expr/lambda.h",
    "src/libponyc/expr/literal.c",
    "src/libponyc/type/reify.c",
    "src/libponyc/expr/operator.c",
    "src/libponyc/expr/ffi.c",
    "src/libponyc/expr/array.h",
    "src/libponyc/expr/reference.c",
    "src/libponyc/expr/call.c",
    "src/libponyc/expr/postfix.c",
    "src/libponyc/pass/traits.c",
    "src/libponyc/type/assemble.c",
    "src/libponyc/pass/flatten.c",
    "src/libponyc/type/reify.h",
    "src/libponyc/expr/literal.h",
    "src/libponyc/pass/expr.c",
    "src/libponyc/type/alias.c",
    "src/libponyc/type/subtype.c",
    "src/libponyc/pass/refer.c",
    "src/libponyc/expr/reference.h"
  ],
  "3_final_combined_files": [
    "src/libponyc/expr/lambda.c",
    "src/libponyc/pass/sugar.c",
    "src/libponyc/expr/array.c"
  ],
  "4_related_elements": {
    "src/libponyc/expr/lambda.c": [
      "function: make_capture_field\nfunction: expr_lambda\nfunction: capture_from_reference\nfunction: capture_from_expr\nfunction: capture_from_type\nfunction: add_field_to_object\nfunction: catch_up_provides\nfunction: expr_object"
    ],
    "src/libponyc/pass/sugar.c": [
      "function: sugar_lambdatype\nfunction: sugar_barelambda\nfunction: sugar_fun\nfunction: fun_defaults\nfunction: check_params"
    ],
    "src/libponyc/expr/array.c": [
      "function: expr_array"
    ]
  },
  "5_sampled_edit_locs_and_patches": [
    {
      "sample_index": 0,
      "edit_locs": {
        "src/libponyc/expr/array.c": [
          "function: expr_array\nline: 68\nline: 79\nline: 83\nline: 88"
        ],
        "src/libponyc/expr/lambda.c": [
          "function: expr_lambda\nline: 206\nline: 218"
        ],
        "src/libponyc/pass/sugar.c": [
          "function: check_params\nfunction: sugar_lambdatype"
        ]
      },
      "patches": [
        "diff --git a/src/libponyc/expr/lambda.c b/src/libponyc/expr/lambda.c\nindex ece6b97..d552766 100644\n--- a/src/libponyc/expr/lambda.c\n+++ b/src/libponyc/expr/lambda.c\n@@ -212,7 +212,9 @@ bool expr_lambda(pass_opt_t* opt, ast_t** astp)\n     else\n       printbuf(buf, \", \");\n \n-    printbuf(buf, \"%s\", ast_print_type(ast_childidx(p, 1)));\n+    ast_t* p_type = ast_childidx(p, 1);\n+    if(ast_id(p_type) != TK_NONE)\n+      printbuf(buf, \"%s\", ast_print_type(p_type));\n   }\n \n   printbuf(buf, \")\");\ndiff --git a/src/libponyc/pass/sugar.c b/src/libponyc/pass/sugar.c\nindex 4e5aac4..7c4a8a1 100644\n--- a/src/libponyc/pass/sugar.c\n+++ b/src/libponyc/pass/sugar.c\n@@ -309,8 +309,14 @@ static ast_result_t check_params(pass_opt_t* opt, ast_t* params)\n \n     if(ast_id(type) == TK_NONE)\n     {\n-      ast_error(opt->check.errors, type, \"expected parameter type\");\n-      result = AST_ERROR;\n+      // Allow omitted parameter types for lambdas; they may be inferred\n+      ast_t* parent = ast_parent(params);\n+      token_id p_id = ast_id(parent);\n+      if((p_id != TK_LAMBDA) && (p_id != TK_BARELAMBDA))\n+      {\n+        ast_error(opt->check.errors, type, \"expected parameter type\");\n+        result = AST_ERROR;\n+      }\n     }\n   }\n \n",
        "diff --git a/src/libponyc/pass/sugar.c b/src/libponyc/pass/sugar.c\nindex 4e5aac4..225ec51 100644\n--- a/src/libponyc/pass/sugar.c\n+++ b/src/libponyc/pass/sugar.c\n@@ -309,8 +309,27 @@ static ast_result_t check_params(pass_opt_t* opt, ast_t* params)\n \n     if(ast_id(type) == TK_NONE)\n     {\n-      ast_error(opt->check.errors, type, \"expected parameter type\");\n-      result = AST_ERROR;\n+      // Allow omitted parameter types for functions defined inside an object\n+      // literal (eg, lambdas), so they can be inferred from the LHS type.\n+      bool allow_infer = false;\n+\n+      ast_t* fun = ast_parent(params);\n+      if(fun != NULL)\n+      {\n+        ast_t* members = ast_parent(fun);\n+        if((members != NULL) && (ast_id(members) == TK_MEMBERS))\n+        {\n+          ast_t* container = ast_parent(members);\n+          if((container != NULL) && (ast_id(container) == TK_OBJECT))\n+            allow_infer = true;\n+        }\n+      }\n+\n+      if(!allow_infer)\n+      {\n+        ast_error(opt->check.errors, type, \"expected parameter type\");\n+        result = AST_ERROR;\n+      }\n     }\n   }\n \n"
      ]
    },
    {
      "sample_index": 1,
      "edit_locs": {
        "src/libponyc/expr/lambda.c": [
          "function: expr_lambda"
        ],
        "src/libponyc/pass/sugar.c": [
          "line: 300\nline: 315"
        ],
        "src/libponyc/expr/array.c": [
          "function: expr_array"
        ]
      },
      "patches": [
        "diff --git a/src/libponyc/expr/array.c b/src/libponyc/expr/array.c\nindex 817a7f7..fb9c3a3 100644\n--- a/src/libponyc/expr/array.c\n+++ b/src/libponyc/expr/array.c\n@@ -1,3 +1,4 @@\n+\n #include \"array.h\"\n #include \"reference.h\"\n #include \"postfix.h\"\n@@ -81,6 +82,15 @@ bool expr_array(pass_opt_t* opt, ast_t** astp)\n \n   if(!told_type)\n   {\n+    // If there is no type specified and the array is empty, treat the array\n+    // as a literal type so it can be coerced based on the left-hand side.\n+    if(size == 0)\n+    {\n+      ast_free_unattached(type);\n+      make_literal_type(ast);\n+      return true;\n+    }\n+\n     ast_t* aliasable_type = type;\n     type = alias(aliasable_type);\n     ast_free_unattached(aliasable_type);\n@@ -141,4 +151,4 @@ bool expr_array(pass_opt_t* opt, ast_t** astp)\n \n   ast_free_unattached(ast);\n   return true;\n-}\n+}\ndiff --git a/src/libponyc/expr/lambda.c b/src/libponyc/expr/lambda.c\nindex ece6b97..a2eb554 100644\n--- a/src/libponyc/expr/lambda.c\n+++ b/src/libponyc/expr/lambda.c\n@@ -212,7 +212,11 @@ bool expr_lambda(pass_opt_t* opt, ast_t** astp)\n     else\n       printbuf(buf, \", \");\n \n-    printbuf(buf, \"%s\", ast_print_type(ast_childidx(p, 1)));\n+    ast_t* ptype = ast_childidx(p, 1);\n+    if(ast_id(ptype) == TK_NONE)\n+      printbuf(buf, \"_\");\n+    else\n+      printbuf(buf, \"%s\", ast_print_type(ptype));\n   }\n \n   printbuf(buf, \")\");\n",
        "diff --git a/src/libponyc/expr/array.c b/src/libponyc/expr/array.c\nindex 817a7f7..8439edf 100644\n--- a/src/libponyc/expr/array.c\n+++ b/src/libponyc/expr/array.c\n@@ -1,3 +1,4 @@\n+\n #include \"array.h\"\n #include \"reference.h\"\n #include \"postfix.h\"\n@@ -67,9 +68,14 @@ bool expr_array(pass_opt_t* opt, ast_t** astp)\n     }\n     else\n     {\n-      if(is_type_literal(c_type))\n+      // If any element is a literal or a lambda expression, defer typing of the\n+      // entire array to the expected type on the left-hand side.\n+      if(is_type_literal(c_type) ||\n+        (ast_id(ele) == TK_LAMBDA) ||\n+        (ast_id(ele) == TK_BARELAMBDA))\n       {\n-        // At least one array element is literal, so whole array is\n+        // At least one array element is context-dependent; make the array a\n+        // literal type so it can be coerced later.\n         ast_free_unattached(type);\n         make_literal_type(ast);\n         return true;\n@@ -141,4 +147,4 @@ bool expr_array(pass_opt_t* opt, ast_t** astp)\n \n   ast_free_unattached(ast);\n   return true;\n-}\n+}\n"
      ]
    }
  ],
  "6_final_selected_patch": "diff --git a/src/libponyc/pass/sugar.c b/src/libponyc/pass/sugar.c\nindex 4e5aac4..225ec51 100644\n--- a/src/libponyc/pass/sugar.c\n+++ b/src/libponyc/pass/sugar.c\n@@ -309,8 +309,27 @@ static ast_result_t check_params(pass_opt_t* opt, ast_t* params)\n \n     if(ast_id(type) == TK_NONE)\n     {\n-      ast_error(opt->check.errors, type, \"expected parameter type\");\n-      result = AST_ERROR;\n+      // Allow omitted parameter types for functions defined inside an object\n+      // literal (eg, lambdas), so they can be inferred from the LHS type.\n+      bool allow_infer = false;\n+\n+      ast_t* fun = ast_parent(params);\n+      if(fun != NULL)\n+      {\n+        ast_t* members = ast_parent(fun);\n+        if((members != NULL) && (ast_id(members) == TK_MEMBERS))\n+        {\n+          ast_t* container = ast_parent(members);\n+          if((container != NULL) && (ast_id(container) == TK_OBJECT))\n+            allow_infer = true;\n+        }\n+      }\n+\n+      if(!allow_infer)\n+      {\n+        ast_error(opt->check.errors, type, \"expected parameter type\");\n+        result = AST_ERROR;\n+      }\n     }\n   }\n \n",
  "7_resolved": false
}