{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__d9d9c3a6",
    "original_id": "instance_internetarchive__openlibrary-77c16d530b4d5c0f33d68bead2c6b329aee9b996-ve8c8d62a2b60610a3c4631f5f23ed866bada9818",
    "1_model_selected_files": [
        "openlibrary/plugins/upstream/table_of_contents.py",
        "openlibrary/core/olmarkdown.py",
        "openlibrary/plugins/openlibrary/schema.py",
        "openlibrary/plugins/openlibrary/api.py",
        "openlibrary/core/models.py"
    ],
    "2_embedding_selected_files": [
        "openlibrary/plugins/upstream/utils.py",
        "openlibrary/catalog/marc/parse.py",
        "openlibrary/plugins/upstream/table_of_contents.py",
        "openlibrary/plugins/upstream/merge_authors.py",
        "openlibrary/core/olmarkdown.py",
        "openlibrary/catalog/utils/edit.py",
        "openlibrary/plugins/upstream/recentchanges.py",
        "openlibrary/utils/lcc.py",
        "openlibrary/plugins/books/dynlinks.py",
        "openlibrary/plugins/upstream/addtag.py",
        "openlibrary/utils/bulkimport.py",
        "openlibrary/utils/ddc.py",
        "openlibrary/plugins/upstream/addbook.py",
        "openlibrary/catalog/add_book/__init__.py",
        "openlibrary/views/showmarc.py",
        "openlibrary/plugins/upstream/models.py",
        "openlibrary/catalog/utils/__init__.py",
        "openlibrary/plugins/upstream/code.py",
        "openlibrary/records/functions.py",
        "openlibrary/plugins/books/readlinks.py",
        "openlibrary/catalog/marc/get_subjects.py",
        "openlibrary/data/sitemap.py",
        "openlibrary/plugins/openlibrary/home.py",
        "openlibrary/plugins/upstream/account.py",
        "openlibrary/core/processors/readableurls.py",
        "openlibrary/plugins/upstream/mybooks.py",
        "openlibrary/catalog/marc/marc_base.py",
        "openlibrary/core/bookshelves.py",
        "openlibrary/plugins/admin/code.py",
        "openlibrary/data/__init__.py",
        "openlibrary/plugins/openlibrary/code.py",
        "openlibrary/core/observations.py",
        "openlibrary/plugins/openlibrary/opds.py",
        "openlibrary/catalog/marc/marc_xml.py",
        "openlibrary/catalog/add_book/match.py",
        "scripts/detect_missing_i18n.py",
        "scripts/generate-api-docs.py",
        "openlibrary/solr/updater/work.py",
        "openlibrary/core/models.py",
        "scripts/sitemaps/sitemap.py",
        "openlibrary/plugins/importapi/import_opds.py",
        "openlibrary/plugins/worksearch/code.py",
        "openlibrary/core/sponsorships.py",
        "openlibrary/plugins/importapi/code.py",
        "openlibrary/plugins/upstream/checkins.py",
        "openlibrary/plugins/upstream/edits.py",
        "openlibrary/data/dump.py",
        "openlibrary/core/processors/__init__.py",
        "openlibrary/core/__init__.py"
    ],
    "3_final_combined_files": [
        "openlibrary/plugins/upstream/table_of_contents.py",
        "openlibrary/core/olmarkdown.py",
        "openlibrary/plugins/openlibrary/schema.py",
        "openlibrary/plugins/upstream/utils.py",
        "openlibrary/catalog/marc/parse.py"
    ],
    "4_related_elements": {
        "openlibrary/plugins/upstream/table_of_contents.py": [
            "class: AuthorRecord\nfunction: TocEntry.from_dict\nfunction: TocEntry.is_empty"
        ],
        "openlibrary/core/olmarkdown.py": [
            "variable: AUTOLINK_RE\nvariable: LINK_REFERENCE_RE\nfunction: LineBreaksPreprocessor.run\nvariable: LINE_BREAKS_PREPROCESSOR\nfunction: AutolinkPreprocessor.run\nvariable: AUTOLINK_PREPROCESSOR\nfunction: OLMarkdown.__init__\nfunction: OLMarkdown._patch\nfunction: OLMarkdown.convert"
        ],
        "openlibrary/plugins/openlibrary/schema.py": [
            "variable: table_of_contents"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "openlibrary/plugins/upstream/table_of_contents.py": [
                    "class: TocEntry\nfunction: TocEntry.from_dict\nfunction: TocEntry.is_empty\nfunction: TocEntry.to_dict\nfunction: parse_toc_markdown\nfunction: render_toc_markdown"
                ],
                "openlibrary/core/olmarkdown.py": [
                    ""
                ],
                "openlibrary/plugins/openlibrary/schema.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 2223606..2c9e598 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -22,19 +22,62 @@ class TocEntry:\n \n     @staticmethod\n     def from_dict(d: dict) -> 'TocEntry':\n+        # Normalize strings to None if empty/whitespace\n+        def norm_str(v):\n+            if isinstance(v, str):\n+                s = v.strip()\n+                return s or None\n+            return None\n+\n+        # Normalize authors list to a structured list of AuthorRecord dicts.\n+        # Invalid or empty items are dropped; empty lists become None.\n+        def norm_authors(v):\n+            normalized = []\n+            if isinstance(v, list):\n+                for item in v:\n+                    if not isinstance(item, dict):\n+                        continue\n+                    name = norm_str(item.get('name'))\n+                    if not name:\n+                        continue\n+                    author_ref = item.get('author')\n+                    if isinstance(author_ref, dict) and author_ref.get('key'):\n+                        # Keep only the reference dict fields that matter\n+                        # to avoid leaking malformed structures.\n+                        author = {'key': author_ref.get('key')}\n+                    else:\n+                        author = None\n+                    normalized.append({'name': name, 'author': author})\n+            return normalized or None\n+\n+        lvl = d.get('level', 0)\n+        try:\n+            lvl = int(lvl)\n+        except (TypeError, ValueError):\n+            lvl = 0\n+\n         return TocEntry(\n-            level=d.get('level', 0),\n-            label=d.get('label'),\n-            title=d.get('title'),\n-            pagenum=d.get('pagenum'),\n-            authors=d.get('authors'),\n-            subtitle=d.get('subtitle'),\n-            description=d.get('description'),\n+            level=lvl,\n+            label=norm_str(d.get('label')),\n+            title=norm_str(d.get('title')),\n+            pagenum=norm_str(d.get('pagenum')),\n+            authors=norm_authors(d.get('authors')),\n+            subtitle=norm_str(d.get('subtitle')),\n+            description=norm_str(d.get('description')),\n         )\n \n     def is_empty(self) -> bool:\n-        return all(\n-            getattr(self, field) is None\n-            for field in self.__annotations__\n-            if field != 'level'\n-        )\n+        # Consider strings with only whitespace and empty lists as empty.\n+        for field in self.__annotations__:\n+            if field == 'level':\n+                continue\n+            val = getattr(self, field)\n+            if isinstance(val, str):\n+                if val.strip():\n+                    return False\n+            elif isinstance(val, list):\n+                if len(val) > 0:\n+                    return False\n+            elif val is not None:\n+                return False\n+        return True\n",
                "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 2223606..8bf501e 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -1,3 +1,4 @@\n+\n from dataclasses import dataclass\n from typing import TypedDict\n \n@@ -22,19 +23,78 @@ class TocEntry:\n \n     @staticmethod\n     def from_dict(d: dict) -> 'TocEntry':\n+        def norm_str(x):\n+            if x is None:\n+                return None\n+            if not isinstance(x, str):\n+                try:\n+                    x = str(x)\n+                except Exception:\n+                    return None\n+            x = x.strip()\n+            return x or None\n+\n+        def normalize_authors(raw) -> list[AuthorRecord]:\n+            if raw is None:\n+                return []\n+            normalized: list[AuthorRecord] = []\n+            if isinstance(raw, list):\n+                for a in raw:\n+                    if isinstance(a, str):\n+                        name = a.strip()\n+                        if name:\n+                            normalized.append({'name': name, 'author': None})\n+                    elif isinstance(a, dict):\n+                        # Support various shapes, e.g., {'name': 'X', 'author': {'key': '/authors/OL...'}} or {'label': 'X', 'key': '/authors/...'}\n+                        name = a.get('name') or a.get('label') or ''\n+                        name = name.strip() if isinstance(name, str) else ''\n+                        ref = a.get('author') or a.get('key') or a.get('author_key') or a.get('ref')\n+                        if isinstance(ref, str) and ref.strip():\n+                            ref = {'key': ref.strip()}\n+                        # Only include if we have at least a name or a reference\n+                        if name or ref:\n+                            normalized.append({'name': name, 'author': ref})\n+            elif isinstance(raw, str):\n+                name = raw.strip()\n+                if name:\n+                    normalized.append({'name': name, 'author': None})\n+            # Drop entries with completely empty names and refs\n+            normalized = [ar for ar in normalized if (ar.get('name') or ar.get('author'))]\n+            return normalized\n+\n+        # Normalize level to int, defaulting to 0 on invalid input\n+        level_raw = d.get('level', 0)\n+        try:\n+            level = int(level_raw)\n+        except (TypeError, ValueError):\n+            level = 0\n+\n+        page = d.get('pagenum') or d.get('page') or d.get('page_number')\n+\n+        authors_list = normalize_authors(d.get('authors'))\n+\n         return TocEntry(\n-            level=d.get('level', 0),\n-            label=d.get('label'),\n-            title=d.get('title'),\n-            pagenum=d.get('pagenum'),\n-            authors=d.get('authors'),\n-            subtitle=d.get('subtitle'),\n-            description=d.get('description'),\n+            level=level,\n+            label=norm_str(d.get('label')),\n+            title=norm_str(d.get('title')),\n+            pagenum=norm_str(page),\n+            authors=authors_list if authors_list else None,\n+            subtitle=norm_str(d.get('subtitle')),\n+            description=norm_str(d.get('description')),\n         )\n \n     def is_empty(self) -> bool:\n+        def empty(value):\n+            if value is None:\n+                return True\n+            if isinstance(value, str):\n+                return not value.strip()\n+            if isinstance(value, (list, tuple, set, dict)):\n+                return len(value) == 0\n+            return False\n+\n         return all(\n-            getattr(self, field) is None\n+            empty(getattr(self, field))\n             for field in self.__annotations__\n             if field != 'level'\n-        )\n+        )\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "openlibrary/plugins/upstream/table_of_contents.py": [
                    "class: TocEntry\nfunction: TocEntry.from_dict\nfunction: TocEntry.is_empty\nclass: AuthorRecord"
                ],
                "openlibrary/core/olmarkdown.py": [
                    "class: OLMarkdown\nfunction: OLMarkdown._patch\nfunction: OLMarkdown.convert"
                ],
                "openlibrary/plugins/openlibrary/schema.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 2223606..3530ff0 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -20,21 +20,101 @@ class TocEntry:\n     subtitle: str | None = None\n     description: str | None = None\n \n+    @staticmethod\n+    def _clean_str(value) -> str | None:\n+        if value is None:\n+            return None\n+        if isinstance(value, str):\n+            s = value.strip()\n+            return s if s else None\n+        # Fallback for non-string values that can be stringified (e.g., numbers)\n+        s = str(value).strip()\n+        return s if s else None\n+\n+    @staticmethod\n+    def _normalize_authors(value) -> list[AuthorRecord] | None:\n+        if value is None:\n+            return None\n+        normalized: list[AuthorRecord] = []\n+        entries = value if isinstance(value, list) else [value]\n+        for entry in entries:\n+            if isinstance(entry, str):\n+                name = TocEntry._clean_str(entry)\n+                if name:\n+                    normalized.append({'name': name, 'author': None})\n+            elif isinstance(entry, dict):\n+                # Accept {'name': '...', 'author': {...}} or {'author': {...}} or {'name': '...'}\n+                name = TocEntry._clean_str(entry.get('name'))\n+                author_field = entry.get('author')\n+                author_ref = author_field if isinstance(author_field, dict) else None\n+                # If name not provided but a string 'author' was given, treat it as name\n+                if name is None and isinstance(author_field, str):\n+                    name = TocEntry._clean_str(author_field)\n+                    author_ref = None\n+                if name or author_ref:\n+                    normalized.append({'name': name or '', 'author': author_ref})\n+        return normalized or None\n+\n     @staticmethod\n     def from_dict(d: dict) -> 'TocEntry':\n+        # Ensure level is a non-negative integer\n+        raw_level = d.get('level', 0)\n+        try:\n+            level = int(raw_level)\n+            if level < 0:\n+                level = 0\n+        except (TypeError, ValueError):\n+            level = 0\n+\n+        label = TocEntry._clean_str(d.get('label'))\n+        title = TocEntry._clean_str(d.get('title'))\n+        subtitle = TocEntry._clean_str(d.get('subtitle'))\n+        description = TocEntry._clean_str(d.get('description'))\n+\n+        # Normalize page number to string if provided\n+        p_raw = d.get('pagenum')\n+        if isinstance(p_raw, (int, float)):\n+            pagenum = str(int(p_raw))\n+        elif isinstance(p_raw, str):\n+            pagenum = TocEntry._clean_str(p_raw)\n+        else:\n+            pagenum = None\n+\n+        authors = TocEntry._normalize_authors(d.get('authors'))\n+\n         return TocEntry(\n-            level=d.get('level', 0),\n-            label=d.get('label'),\n-            title=d.get('title'),\n-            pagenum=d.get('pagenum'),\n-            authors=d.get('authors'),\n-            subtitle=d.get('subtitle'),\n-            description=d.get('description'),\n+            level=level,\n+            label=label,\n+            title=title,\n+            pagenum=pagenum,\n+            authors=authors,\n+            subtitle=subtitle,\n+            description=description,\n         )\n \n     def is_empty(self) -> bool:\n-        return all(\n-            getattr(self, field) is None\n-            for field in self.__annotations__\n-            if field != 'level'\n-        )\n+        # Treat None, empty strings, empty lists, and authors with no data as empty\n+        for field in self.__annotations__:\n+            if field == 'level':\n+                continue\n+            value = getattr(self, field)\n+            if value is None:\n+                continue\n+            if isinstance(value, str) and not value.strip():\n+                continue\n+            if isinstance(value, list):\n+                if field == 'authors':\n+                    # Authors are empty if all records have no name and no author reference\n+                    nonempty = any(\n+                        (rec.get('name') and rec.get('name').strip()) or rec.get('author')\n+                        for rec in value\n+                        if isinstance(rec, dict)\n+                    )\n+                    if not nonempty:\n+                        continue\n+                else:\n+                    if len(value) == 0:\n+                        continue\n+            # If we reach here, there's meaningful content\n+            return False\n+        return True\n",
                "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 2223606..1067b01 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -1,3 +1,4 @@\n+\n from dataclasses import dataclass\n from typing import TypedDict\n \n@@ -20,21 +21,95 @@ class TocEntry:\n     subtitle: str | None = None\n     description: str | None = None\n \n+    @staticmethod\n+    def _clean_str(val) -> str | None:\n+        if val is None:\n+            return None\n+        s = str(val).strip()\n+        return s or None\n+\n     @staticmethod\n     def from_dict(d: dict) -> 'TocEntry':\n+        # Normalize level to a non-negative integer\n+        raw_level = d.get('level', 0)\n+        try:\n+            level = int(raw_level)\n+            if level < 0:\n+                level = 0\n+        except (ValueError, TypeError):\n+            level = 0\n+\n+        label = TocEntry._clean_str(d.get('label'))\n+        title = TocEntry._clean_str(d.get('title'))\n+        pagenum = TocEntry._clean_str(d.get('pagenum'))\n+        subtitle = TocEntry._clean_str(d.get('subtitle'))\n+        description = TocEntry._clean_str(d.get('description'))\n+\n+        # Normalize authors list: drop malformed/empty entries\n+        norm_authors = None\n+        raw_authors = d.get('authors')\n+        if isinstance(raw_authors, list):\n+            cleaned = []\n+            for a in raw_authors:\n+                if not isinstance(a, dict):\n+                    continue\n+                name = TocEntry._clean_str(a.get('name'))\n+                author_ref = a.get('author')\n+                # Drop entries that have neither a name nor a reference\n+                if (name is None or name == '') and author_ref is None:\n+                    continue\n+                cleaned.append({'name': name or '', 'author': author_ref})\n+            if cleaned:\n+                norm_authors = cleaned\n+\n         return TocEntry(\n-            level=d.get('level', 0),\n-            label=d.get('label'),\n-            title=d.get('title'),\n-            pagenum=d.get('pagenum'),\n-            authors=d.get('authors'),\n-            subtitle=d.get('subtitle'),\n-            description=d.get('description'),\n+            level=level,\n+            label=label,\n+            title=title,\n+            pagenum=pagenum,\n+            authors=norm_authors,\n+            subtitle=subtitle,\n+            description=description,\n         )\n \n     def is_empty(self) -> bool:\n-        return all(\n-            getattr(self, field) is None\n-            for field in self.__annotations__\n-            if field != 'level'\n-        )\n+        # Treat empty strings and empty lists/dicts as empty; ignore level\n+        for field in self.__dataclass_fields__:\n+            if field == 'level':\n+                continue\n+            val = getattr(self, field)\n+            if val is None:\n+                continue\n+            if isinstance(val, str):\n+                if val.strip():\n+                    return False\n+                else:\n+                    continue\n+            if isinstance(val, (list, tuple, set, dict)):\n+                # Special-case authors: ignore if all entries are empty\n+                if field == 'authors':\n+                    if not val:\n+                        continue\n+                    has_nonempty = False\n+                    for a in val:\n+                        if isinstance(a, dict):\n+                            name = a.get('name')\n+                            author_ref = a.get('author')\n+                            if (isinstance(name, str) and name.strip()) or author_ref:\n+                                has_nonempty = True\n+                                break\n+                        else:\n+                            # Non-dict entries are considered non-empty\n+                            has_nonempty = True\n+                            break\n+                    if has_nonempty:\n+                        return False\n+                    else:\n+                        continue\n+                if len(val) > 0:\n+                    return False\n+                else:\n+                    continue\n+            # Any other non-None value counts as non-empty\n+            return False\n+        return True\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 2223606..2c9e598 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -22,19 +22,62 @@ class TocEntry:\n \n     @staticmethod\n     def from_dict(d: dict) -> 'TocEntry':\n+        # Normalize strings to None if empty/whitespace\n+        def norm_str(v):\n+            if isinstance(v, str):\n+                s = v.strip()\n+                return s or None\n+            return None\n+\n+        # Normalize authors list to a structured list of AuthorRecord dicts.\n+        # Invalid or empty items are dropped; empty lists become None.\n+        def norm_authors(v):\n+            normalized = []\n+            if isinstance(v, list):\n+                for item in v:\n+                    if not isinstance(item, dict):\n+                        continue\n+                    name = norm_str(item.get('name'))\n+                    if not name:\n+                        continue\n+                    author_ref = item.get('author')\n+                    if isinstance(author_ref, dict) and author_ref.get('key'):\n+                        # Keep only the reference dict fields that matter\n+                        # to avoid leaking malformed structures.\n+                        author = {'key': author_ref.get('key')}\n+                    else:\n+                        author = None\n+                    normalized.append({'name': name, 'author': author})\n+            return normalized or None\n+\n+        lvl = d.get('level', 0)\n+        try:\n+            lvl = int(lvl)\n+        except (TypeError, ValueError):\n+            lvl = 0\n+\n         return TocEntry(\n-            level=d.get('level', 0),\n-            label=d.get('label'),\n-            title=d.get('title'),\n-            pagenum=d.get('pagenum'),\n-            authors=d.get('authors'),\n-            subtitle=d.get('subtitle'),\n-            description=d.get('description'),\n+            level=lvl,\n+            label=norm_str(d.get('label')),\n+            title=norm_str(d.get('title')),\n+            pagenum=norm_str(d.get('pagenum')),\n+            authors=norm_authors(d.get('authors')),\n+            subtitle=norm_str(d.get('subtitle')),\n+            description=norm_str(d.get('description')),\n         )\n \n     def is_empty(self) -> bool:\n-        return all(\n-            getattr(self, field) is None\n-            for field in self.__annotations__\n-            if field != 'level'\n-        )\n+        # Consider strings with only whitespace and empty lists as empty.\n+        for field in self.__annotations__:\n+            if field == 'level':\n+                continue\n+            val = getattr(self, field)\n+            if isinstance(val, str):\n+                if val.strip():\n+                    return False\n+            elif isinstance(val, list):\n+                if len(val) > 0:\n+                    return False\n+            elif val is not None:\n+                return False\n+        return True\n"
}