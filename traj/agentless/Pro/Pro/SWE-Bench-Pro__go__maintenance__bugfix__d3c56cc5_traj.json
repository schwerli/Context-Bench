{
    "instance_id": "SWE-Bench-Pro__go__maintenance__bugfix__d3c56cc5",
    "original_id": "instance_navidrome__navidrome-d8e794317f788198227e10fb667e10496b3eb99a",
    "1_model_selected_files": [
        "core/artwork/artwork.go",
        "core/artwork/sources.go",
        "server/public/handle_images.go",
        "server/subsonic/media_retrieval.go",
        "core/artwork/reader_emptyid.go"
    ],
    "2_embedding_selected_files": [
        "core/artwork/artwork_internal_test.go",
        "core/artwork/artwork_test.go",
        "core/artwork/artwork.go",
        "core/artwork/reader_emptyid.go",
        "core/artwork/reader_album.go",
        "core/artwork/reader_playlist.go",
        "core/artwork/sources.go",
        "core/artwork/reader_artist.go",
        "server/subsonic/media_retrieval_test.go",
        "core/artwork/cache_warmer.go",
        "core/artwork/reader_mediafile.go",
        "core/artwork/artwork_suite_test.go",
        "core/agents/agents_test.go",
        "core/artwork/reader_resized.go",
        "model/artwork_id.go",
        "model/artwork_id_test.go",
        "core/artwork/image_cache.go",
        "server/subsonic/media_retrieval.go",
        "core/agents/lastfm/agent_test.go",
        "model/mediafile_internal_test.go",
        "consts/consts.go",
        "model/mediafile_test.go",
        "server/public/handle_images.go",
        "core/external_metadata.go",
        "server/public/encode_id_test.go",
        "db/migration/20221219140528_remove_cover_art_id.go",
        "server/public/encode_id.go",
        "core/artwork/wire_providers.go",
        "server/subsonic/responses/responses_test.go",
        "db/migration/20200326090707_fix_album_artists_importing.go",
        "scanner/playlist_importer_test.go",
        "model/artist.go",
        "scanner/metadata/ffmpeg/ffmpeg_test.go",
        "model/mediafile.go",
        "persistence/artist_repository.go",
        "server/subsonic/browsing.go",
        "core/agents/spotify/client_test.go",
        "persistence/artist_repository_test.go",
        "server/serve_index_test.go",
        "server/backgrounds/handler.go",
        "core/agents/lastfm/client_test.go",
        "core/agents/lastfm/agent.go",
        "core/scrobbler/play_tracker_test.go",
        "server/subsonic/media_annotation_test.go",
        "core/agents/agents.go",
        "persistence/mediafile_repository_test.go",
        "server/subsonic/helpers_test.go",
        "core/agents/lastfm/responses_test.go",
        "db/migration/20211105162746_remove_invalid_artist_ids.go",
        "core/agents/spotify/responses.go",
        "server/subsonic/api.go",
        "core/agents/interfaces.go",
        "server/subsonic/album_lists_test.go",
        "core/media_streamer_Internal_test.go",
        "core/agents/listenbrainz/agent_test.go",
        "core/media_streamer_test.go",
        "scanner/metadata/taglib/taglib_test.go",
        "db/migration/20201030162009_add_artist_info_table.go",
        "model/album_test.go",
        "model/artist_info.go",
        "scanner/metadata/metadata.go",
        "scanner/mapping.go",
        "db/migration/20201213124814_add_all_artist_ids_to_album.go",
        "persistence/persistence_suite_test.go",
        "scanner/metadata/metadata_test.go",
        "scanner/mapping_internal_test.go",
        "core/agents/listenbrainz/client_test.go"
    ],
    "3_final_combined_files": [
        "core/artwork/artwork.go",
        "core/artwork/sources.go",
        "server/public/handle_images.go",
        "core/artwork/artwork_internal_test.go",
        "core/artwork/artwork_test.go"
    ],
    "4_related_elements": {
        "core/artwork/artwork.go": [
            "class: Artwork\nclass: artwork\nfunction: artwork.Get\nfunction: artwork.getArtworkReader\nfunction: artwork.getArtworkId"
        ],
        "core/artwork/sources.go": [
            "function: selectImageReader\nfunction: fromAlbum\nfunction: fromAlbumPlaceholder\nfunction: fromArtistPlaceholder\nfunction: fromArtistExternalSource\nfunction: fromAlbumExternalSource\nfunction: fromURL"
        ],
        "server/public/handle_images.go": [
            "function: Router.handleImages\nvariable: PlaceholderAlbumArt\nvariable: PlaceholderArtistArt\nvariable: ErrNotFound\nfunction: ExternalMetadata.ArtistImage\nfunction: ExternalMetadata.AlbumImage"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "core/artwork/artwork.go": [
                    "line: 18\nline: 19\nline: 20\nfunction: artwork.Get\nfunction: artwork.GetOrPlaceholder"
                ],
                "core/artwork/sources.go": [
                    "function: fromAlbum\nfunction: fromAlbumPlaceholder\nfunction: fromArtistPlaceholder"
                ],
                "server/public/handle_images.go": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/core/artwork/artwork.go b/core/artwork/artwork.go\nindex 9b88d8c..e90e373 100644\n--- a/core/artwork/artwork.go\n+++ b/core/artwork/artwork.go\n@@ -11,18 +11,40 @@ import (\n \t\"github.com/navidrome/navidrome/core/ffmpeg\"\n \t\"github.com/navidrome/navidrome/log\"\n \t\"github.com/navidrome/navidrome/model\"\n+\t\"github.com/navidrome/navidrome/resources\"\n+\t\"github.com/navidrome/navidrome/consts\"\n \t\"github.com/navidrome/navidrome/utils/cache\"\n \t_ \"golang.org/x/image/webp\"\n )\n \n type Artwork interface {\n+\t// Get retrieves artwork strictly; returns an error when not available.\n \tGet(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n+\t// GetOrPlaceholder retrieves artwork, or returns a built-in placeholder when unavailable.\n+\tGetOrPlaceholder(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n }\n \n func NewArtwork(ds model.DataStore, cache cache.FileCache, ffmpeg ffmpeg.FFmpeg, em core.ExternalMetadata) Artwork {\n \treturn &artwork{ds: ds, cache: cache, ffmpeg: ffmpeg, em: em}\n }\n \n+func (a *artwork) GetOrPlaceholder(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error) {\n+\tr, ts, err := a.Get(ctx, id, size)\n+\tif err == nil && r != nil {\n+\t\treturn r, ts, nil\n+\t}\n+\t// Fallback to built-in placeholder when artwork is unavailable\n+\tpr, perr := resources.FS().Open(consts.PlaceholderAlbumArt)\n+\tif perr != nil {\n+\t\t// If placeholder is not available, propagate the original error if present\n+\t\tif err != nil {\n+\t\t\treturn nil, time.Time{}, err\n+\t\t}\n+\t\treturn nil, time.Time{}, perr\n+\t}\n+\treturn pr, time.Time{}, nil\n+}\n+\n type artwork struct {\n \tds     model.DataStore\n \tcache  cache.FileCache\ndiff --git a/core/artwork/sources.go b/core/artwork/sources.go\nindex cc0c486..4dd6f82 100644\n--- a/core/artwork/sources.go\n+++ b/core/artwork/sources.go\n@@ -120,11 +120,15 @@ func fromFFmpegTag(ctx context.Context, ffmpeg ffmpeg.FFmpeg, path string) sourc\n \n func fromAlbum(ctx context.Context, a *artwork, id model.ArtworkID) sourceFunc {\n \treturn func() (io.ReadCloser, string, error) {\n-\t\tr, _, err := a.Get(ctx, id.String(), 0)\n+\t\tr, ts, err := a.GetOrPlaceholder(ctx, id.String(), 0)\n \t\tif err != nil {\n \t\t\treturn nil, \"\", err\n \t\t}\n-\t\treturn r, id.String(), nil\n+\t\tpath := id.String()\n+\t\tif ts.IsZero() {\n+\t\t\tpath = consts.PlaceholderAlbumArt\n+\t\t}\n+\t\treturn r, path, nil\n \t}\n }\n \n",
                "diff --git a/core/artwork/artwork.go b/core/artwork/artwork.go\nindex 9b88d8c..6e8a5e9 100644\n--- a/core/artwork/artwork.go\n+++ b/core/artwork/artwork.go\n@@ -1,3 +1,4 @@\n+\n package artwork\n \n import (\n@@ -5,24 +6,50 @@ import (\n \t\"errors\"\n \t_ \"image/gif\"\n \t\"io\"\n+\t\"strings\"\n \t\"time\"\n \n+\t\"github.com/navidrome/navidrome/consts\"\n \t\"github.com/navidrome/navidrome/core\"\n \t\"github.com/navidrome/navidrome/core/ffmpeg\"\n \t\"github.com/navidrome/navidrome/log\"\n \t\"github.com/navidrome/navidrome/model\"\n+\t\"github.com/navidrome/navidrome/resources\"\n \t\"github.com/navidrome/navidrome/utils/cache\"\n \t_ \"golang.org/x/image/webp\"\n )\n \n type Artwork interface {\n+\t// Get returns the requested artwork strictly. If artwork is unavailable, it returns an error.\n \tGet(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n+\t// GetOrPlaceholder returns the requested artwork or a built-in placeholder when unavailable.\n+\tGetOrPlaceholder(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n }\n \n func NewArtwork(ds model.DataStore, cache cache.FileCache, ffmpeg ffmpeg.FFmpeg, em core.ExternalMetadata) Artwork {\n \treturn &artwork{ds: ds, cache: cache, ffmpeg: ffmpeg, em: em}\n }\n \n+func (a *artwork) GetOrPlaceholder(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error) {\n+\tr, modTime, err := a.Get(ctx, id, size)\n+\tif err == nil && r != nil {\n+\t\treturn r, modTime, nil\n+\t}\n+\tplaceholderPath := consts.PlaceholderAlbumArt\n+\tif strings.Contains(strings.ToLower(id), \"artist\") {\n+\t\tplaceholderPath = consts.PlaceholderArtistArt\n+\t}\n+\tpr, err2 := resources.FS().Open(placeholderPath)\n+\tif err2 != nil {\n+\t\tlog.Debug(ctx, \"Failed to open placeholder artwork\", \"id\", id, \"path\", placeholderPath, err2)\n+\t\tif err == nil {\n+\t\t\terr = errors.New(\"artwork unavailable and placeholder not found\")\n+\t\t}\n+\t\treturn nil, time.Time{}, err\n+\t}\n+\treturn pr, time.Time{}, nil\n+}\n+\n type artwork struct {\n \tds     model.DataStore\n \tcache  cache.FileCache\ndiff --git a/core/artwork/sources.go b/core/artwork/sources.go\nindex cc0c486..905fd2e 100644\n--- a/core/artwork/sources.go\n+++ b/core/artwork/sources.go\n@@ -120,7 +120,7 @@ func fromFFmpegTag(ctx context.Context, ffmpeg ffmpeg.FFmpeg, path string) sourc\n \n func fromAlbum(ctx context.Context, a *artwork, id model.ArtworkID) sourceFunc {\n \treturn func() (io.ReadCloser, string, error) {\n-\t\tr, _, err := a.Get(ctx, id.String(), 0)\n+\t\tr, _, err := a.GetOrPlaceholder(ctx, id.String(), 0)\n \t\tif err != nil {\n \t\t\treturn nil, \"\", err\n \t\t}\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "core/artwork/artwork.go": [
                    "line: 18\nline: 19\nline: 20\nfunction: artwork.Get\nfunction: artwork.GetOrPlaceholder\nline: 10\nline: 11\nline: 12\nline: 13\nline: 14\nline: 15"
                ],
                "core/artwork/sources.go": [
                    "function: fromAlbumPlaceholder\nfunction: fromArtistPlaceholder\nline: 40"
                ],
                "server/public/handle_images.go": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/core/artwork/artwork.go b/core/artwork/artwork.go\nindex 9b88d8c..6fc40d4 100644\n--- a/core/artwork/artwork.go\n+++ b/core/artwork/artwork.go\n@@ -17,6 +17,38 @@ import (\n \n type Artwork interface {\n \tGet(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n+\t// GetOrPlaceholder returns the artwork if available, otherwise a built-in placeholder.\n+\t// The returned time will be zero if a placeholder is served, allowing callers to\n+\t// identify and adjust behavior (e.g., caching key or logging) without re-implementing fallback logic.\n+\tGetOrPlaceholder(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n+}\n+\n+// GetOrPlaceholder centralizes fallback handling, providing a placeholder image when strict retrieval fails.\n+// It attempts a strict Get first; if it fails, it selects a placeholder based on the artwork ID type.\n+// A zero time is returned when the placeholder is served, signaling callers that this is a fallback.\n+func (a *artwork) GetOrPlaceholder(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error) {\n+\tr, ts, err := a.Get(ctx, id, size)\n+\tif err == nil && r != nil {\n+\t\treturn r, ts, nil\n+\t}\n+\n+\tvar placeholder string\n+\tif strings.HasPrefix(id, \"artist:\") {\n+\t\tplaceholder = consts.PlaceholderArtistArt\n+\t} else {\n+\t\tplaceholder = consts.PlaceholderAlbumArt\n+\t}\n+\n+\tpr, perr := resources.FS().Open(placeholder)\n+\tif perr != nil {\n+\t\t// If we can't serve a placeholder, propagate the original error if present.\n+\t\tif err != nil {\n+\t\t\treturn nil, time.Time{}, err\n+\t\t}\n+\t\treturn nil, time.Time{}, perr\n+\t}\n+\t// Zero mtime signals placeholder to callers\n+\treturn pr, time.Time{}, nil\n }\n \n func NewArtwork(ds model.DataStore, cache cache.FileCache, ffmpeg ffmpeg.FFmpeg, em core.ExternalMetadata) Artwork {\ndiff --git a/core/artwork/sources.go b/core/artwork/sources.go\nindex cc0c486..64b6328 100644\n--- a/core/artwork/sources.go\n+++ b/core/artwork/sources.go\n@@ -120,10 +120,14 @@ func fromFFmpegTag(ctx context.Context, ffmpeg ffmpeg.FFmpeg, path string) sourc\n \n func fromAlbum(ctx context.Context, a *artwork, id model.ArtworkID) sourceFunc {\n \treturn func() (io.ReadCloser, string, error) {\n-\t\tr, _, err := a.Get(ctx, id.String(), 0)\n+\t\tr, ts, err := a.GetOrPlaceholder(ctx, id.String(), 0)\n \t\tif err != nil {\n \t\t\treturn nil, \"\", err\n \t\t}\n+\t\t// If timestamp is zero, we are serving a placeholder, set path accordingly\n+\t\tif ts.IsZero() {\n+\t\t\treturn r, consts.PlaceholderAlbumArt, nil\n+\t\t}\n \t\treturn r, id.String(), nil\n \t}\n }\n",
                "diff --git a/core/artwork/artwork.go b/core/artwork/artwork.go\nindex 9b88d8c..368d08b 100644\n--- a/core/artwork/artwork.go\n+++ b/core/artwork/artwork.go\n@@ -1,3 +1,4 @@\n+\n package artwork\n \n import (\n@@ -11,18 +12,44 @@ import (\n \t\"github.com/navidrome/navidrome/core/ffmpeg\"\n \t\"github.com/navidrome/navidrome/log\"\n \t\"github.com/navidrome/navidrome/model\"\n+\t\"github.com/navidrome/navidrome/resources\"\n+\t\"github.com/navidrome/navidrome/conf/consts\"\n \t\"github.com/navidrome/navidrome/utils/cache\"\n \t_ \"golang.org/x/image/webp\"\n )\n \n type Artwork interface {\n \tGet(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n+\t// GetOrPlaceholder returns either the actual artwork or a built-in placeholder when unavailable.\n+\t// kind should be \"album\" or \"artist\" to decide which placeholder to use.\n+\tGetOrPlaceholder(ctx context.Context, id string, size int, kind string) (io.ReadCloser, string, time.Time, error)\n }\n \n func NewArtwork(ds model.DataStore, cache cache.FileCache, ffmpeg ffmpeg.FFmpeg, em core.ExternalMetadata) Artwork {\n \treturn &artwork{ds: ds, cache: cache, ffmpeg: ffmpeg, em: em}\n }\n \n+// GetOrPlaceholder returns either the actual artwork or a built-in placeholder when unavailable.\n+func (a *artwork) GetOrPlaceholder(ctx context.Context, id string, size int, kind string) (io.ReadCloser, string, time.Time, error) {\n+\tr, mod, err := a.Get(ctx, id, size)\n+\tif err == nil && r != nil {\n+\t\treturn r, id, mod, nil\n+\t}\n+\tvar placeholderPath string\n+\tswitch kind {\n+\tcase \"artist\":\n+\t\tplaceholderPath = consts.PlaceholderArtistArt\n+\tdefault:\n+\t\tplaceholderPath = consts.PlaceholderAlbumArt\n+\t}\n+\tpr, _ := resources.FS().Open(placeholderPath)\n+\tif pr == nil {\n+\t\treturn nil, \"\", time.Time{}, errors.New(\"placeholder artwork not available\")\n+\t}\n+\tlog.Debug(ctx, \"Returning placeholder artwork\", \"artID\", id, \"kind\", kind)\n+\treturn pr, placeholderPath, time.Time{}, nil\n+}\n+\n type artwork struct {\n \tds     model.DataStore\n \tcache  cache.FileCache\ndiff --git a/core/artwork/sources.go b/core/artwork/sources.go\nindex cc0c486..1344370 100644\n--- a/core/artwork/sources.go\n+++ b/core/artwork/sources.go\n@@ -120,25 +120,23 @@ func fromFFmpegTag(ctx context.Context, ffmpeg ffmpeg.FFmpeg, path string) sourc\n \n func fromAlbum(ctx context.Context, a *artwork, id model.ArtworkID) sourceFunc {\n \treturn func() (io.ReadCloser, string, error) {\n-\t\tr, _, err := a.Get(ctx, id.String(), 0)\n+\t\tr, path, _, err := a.GetOrPlaceholder(ctx, id.String(), 0, id.Kind)\n \t\tif err != nil {\n \t\t\treturn nil, \"\", err\n \t\t}\n-\t\treturn r, id.String(), nil\n+\t\treturn r, path, nil\n \t}\n }\n \n func fromAlbumPlaceholder() sourceFunc {\n \treturn func() (io.ReadCloser, string, error) {\n-\t\tr, _ := resources.FS().Open(consts.PlaceholderAlbumArt)\n-\t\treturn r, consts.PlaceholderAlbumArt, nil\n+\t\treturn nil, \"\", fmt.Errorf(\"album placeholder is handled centrally in the Artwork interface\")\n \t}\n }\n \n func fromArtistPlaceholder() sourceFunc {\n \treturn func() (io.ReadCloser, string, error) {\n-\t\tr, _ := resources.FS().Open(consts.PlaceholderArtistArt)\n-\t\treturn r, consts.PlaceholderArtistArt, nil\n+\t\treturn nil, \"\", fmt.Errorf(\"artist placeholder is handled centrally in the Artwork interface\")\n \t}\n }\n \n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/core/artwork/artwork.go b/core/artwork/artwork.go\nindex 9b88d8c..e90e373 100644\n--- a/core/artwork/artwork.go\n+++ b/core/artwork/artwork.go\n@@ -11,18 +11,40 @@ import (\n \t\"github.com/navidrome/navidrome/core/ffmpeg\"\n \t\"github.com/navidrome/navidrome/log\"\n \t\"github.com/navidrome/navidrome/model\"\n+\t\"github.com/navidrome/navidrome/resources\"\n+\t\"github.com/navidrome/navidrome/consts\"\n \t\"github.com/navidrome/navidrome/utils/cache\"\n \t_ \"golang.org/x/image/webp\"\n )\n \n type Artwork interface {\n+\t// Get retrieves artwork strictly; returns an error when not available.\n \tGet(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n+\t// GetOrPlaceholder retrieves artwork, or returns a built-in placeholder when unavailable.\n+\tGetOrPlaceholder(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error)\n }\n \n func NewArtwork(ds model.DataStore, cache cache.FileCache, ffmpeg ffmpeg.FFmpeg, em core.ExternalMetadata) Artwork {\n \treturn &artwork{ds: ds, cache: cache, ffmpeg: ffmpeg, em: em}\n }\n \n+func (a *artwork) GetOrPlaceholder(ctx context.Context, id string, size int) (io.ReadCloser, time.Time, error) {\n+\tr, ts, err := a.Get(ctx, id, size)\n+\tif err == nil && r != nil {\n+\t\treturn r, ts, nil\n+\t}\n+\t// Fallback to built-in placeholder when artwork is unavailable\n+\tpr, perr := resources.FS().Open(consts.PlaceholderAlbumArt)\n+\tif perr != nil {\n+\t\t// If placeholder is not available, propagate the original error if present\n+\t\tif err != nil {\n+\t\t\treturn nil, time.Time{}, err\n+\t\t}\n+\t\treturn nil, time.Time{}, perr\n+\t}\n+\treturn pr, time.Time{}, nil\n+}\n+\n type artwork struct {\n \tds     model.DataStore\n \tcache  cache.FileCache\ndiff --git a/core/artwork/sources.go b/core/artwork/sources.go\nindex cc0c486..4dd6f82 100644\n--- a/core/artwork/sources.go\n+++ b/core/artwork/sources.go\n@@ -120,11 +120,15 @@ func fromFFmpegTag(ctx context.Context, ffmpeg ffmpeg.FFmpeg, path string) sourc\n \n func fromAlbum(ctx context.Context, a *artwork, id model.ArtworkID) sourceFunc {\n \treturn func() (io.ReadCloser, string, error) {\n-\t\tr, _, err := a.Get(ctx, id.String(), 0)\n+\t\tr, ts, err := a.GetOrPlaceholder(ctx, id.String(), 0)\n \t\tif err != nil {\n \t\t\treturn nil, \"\", err\n \t\t}\n-\t\treturn r, id.String(), nil\n+\t\tpath := id.String()\n+\t\tif ts.IsZero() {\n+\t\t\tpath = consts.PlaceholderAlbumArt\n+\t\t}\n+\t\treturn r, path, nil\n \t}\n }\n \n"
}