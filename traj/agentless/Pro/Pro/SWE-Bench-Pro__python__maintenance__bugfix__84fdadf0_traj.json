{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__84fdadf0",
    "original_id": "instance_ansible__ansible-bf98f031f3f5af31a2d78dc2f0a58fe92ebae0bb-v1055803c3a812189a1133297f7f5468579283f86",
    "1_model_selected_files": [
        "lib/ansible/utils/display.py",
        "lib/ansible/module_utils/basic.py",
        "lib/ansible/executor/task_result.py",
        "lib/ansible/utils/helpers.py",
        "lib/ansible/plugins/callback/default.py"
    ],
    "2_embedding_selected_files": [
        "lib/ansible/module_utils/basic.py",
        "lib/ansible/module_utils/common/parameters.py",
        "lib/ansible/vars/clean.py",
        "lib/ansible/utils/encrypt.py",
        "lib/ansible/galaxy/token.py",
        "lib/ansible/parsing/vault/__init__.py",
        "lib/ansible/module_utils/common/dict_transformations.py",
        "lib/ansible/utils/unsafe_proxy.py",
        "lib/ansible/utils/hashing.py",
        "lib/ansible/modules/known_hosts.py",
        "lib/ansible/utils/vars.py",
        "lib/ansible/module_utils/json_utils.py",
        "lib/ansible/plugins/lookup/password.py",
        "lib/ansible/parsing/yaml/objects.py",
        "lib/ansible/module_utils/common/json.py",
        "lib/ansible/module_utils/common/validation.py",
        "lib/ansible/template/safe_eval.py",
        "lib/ansible/cli/vault.py",
        "hacking/return_skeleton_generator.py",
        "lib/ansible/playbook/role/__init__.py",
        "lib/ansible/utils/helpers.py",
        "lib/ansible/errors/yaml_strings.py",
        "lib/ansible/utils/py3compat.py",
        "lib/ansible/plugins/callback/default.py",
        "lib/ansible/constants.py",
        "lib/ansible/cli/arguments/option_helpers.py",
        "lib/ansible/plugins/doc_fragments/decrypt.py",
        "lib/ansible/utils/path.py",
        "lib/ansible/template/vars.py",
        "lib/ansible/template/__init__.py",
        "lib/ansible/executor/action_write_locks.py",
        "hacking/build_library/build_ansible/command_plugins/dump_keywords.py",
        "lib/ansible/parsing/utils/__init__.py",
        "lib/ansible/parsing/yaml/dumper.py",
        "lib/ansible/inventory/group.py",
        "lib/ansible/utils/__init__.py",
        "lib/ansible/utils/context_objects.py",
        "lib/ansible/parsing/mod_args.py",
        "lib/ansible/vars/reserved.py",
        "hacking/fix_test_syntax.py",
        "lib/ansible/utils/display.py",
        "lib/ansible/parsing/ajson.py",
        "lib/ansible/plugins/doc_fragments/template_common.py",
        "lib/ansible/utils/sentinel.py",
        "lib/ansible/utils/ssh_functions.py",
        "lib/ansible/galaxy/login.py",
        "lib/ansible/plugins/filter/mathstuff.py",
        "lib/ansible/plugins/filter/core.py",
        "lib/ansible/cli/__init__.py",
        "lib/ansible/modules/raw.py",
        "lib/ansible/parsing/dataloader.py",
        "lib/ansible/parsing/splitter.py",
        "lib/ansible/executor/task_executor.py",
        "lib/ansible/plugins/doc_fragments/shell_common.py"
    ],
    "3_final_combined_files": [
        "lib/ansible/module_utils/basic.py",
        "lib/ansible/utils/display.py",
        "lib/ansible/executor/task_result.py",
        "lib/ansible/module_utils/common/parameters.py",
        "lib/ansible/vars/clean.py"
    ],
    "4_related_elements": {
        "lib/ansible/module_utils/basic.py": [
            "variable: PASSWORD_MATCH\nvariable: PASSWD_ARG_RE\nvariable: SEQUENCETYPE\nfunction: _remove_values_conditions\nfunction: remove_values\nfunction: heuristic_log_sanitize\nfunction: AnsibleModule._handle_no_log_values\nfunction: AnsibleModule._log_invocation\nfunction: AnsibleModule.log\nfunction: AnsibleModule.jsonify\nfunction: AnsibleModule.exit_json\nfunction: AnsibleModule.fail_json"
        ],
        "lib/ansible/utils/display.py": [
            "class: Display"
        ],
        "lib/ansible/executor/task_result.py": [
            "variable: _IGNORE\nvariable: _PRESERVE\nvariable: _SUB_PRESERVE\nvariable: CLEAN_EXCEPTIONS\nfunction: TaskResult._check_key\nfunction: TaskResult.clean_copy"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "lib/ansible/module_utils/basic.py": [
                    "function: _remove_values_conditions\nfunction: remove_values\nfunction: heuristic_log_sanitize\nfunction: AnsibleModule.log\nfunction: redact_no_log_string"
                ],
                "lib/ansible/utils/display.py": [
                    ""
                ],
                "lib/ansible/executor/task_result.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/module_utils/basic.py b/lib/ansible/module_utils/basic.py\nindex 03457e1..7e94262 100644\n--- a/lib/ansible/module_utils/basic.py\n+++ b/lib/ansible/module_utils/basic.py\n@@ -1,3 +1,4 @@\n+\n # Copyright (c), Michael DeHaan <michael.dehaan@gmail.com>, 2012-2013\n # Copyright (c), Toshio Kuratomi <tkuratomi@ansible.com> 2016\n # Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)\n@@ -399,32 +400,72 @@ def _remove_values_conditions(value, no_log_strings, deferred_removals):\n     return value\n \n \n-def remove_values(value, no_log_strings):\n-    \"\"\" Remove strings in no_log_strings from value.  If value is a container\n-    type, then remove a lot more\"\"\"\n-    deferred_removals = deque()\n-\n-    no_log_strings = [to_native(s, errors='surrogate_or_strict') for s in no_log_strings]\n-    new_value = _remove_values_conditions(value, no_log_strings, deferred_removals)\n+def remove_values(value, no_log_strings, ignore_keys=None):\n+    \"\"\"\n+    Sanitize mapping keys by masking sensitive tokens in the keys.\n+\n+    Behavior:\n+    - Non-mapping values (strings, numbers, lists, sets, None, etc.) are returned unchanged.\n+    - For mapping keys:\n+        * If a key exactly matches a sensitive token, the key is replaced with 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'.\n+        * If a key contains a sensitive token as a substring, that substring is replaced with '********'.\n+        * Keys listed in ignore_keys are left untouched even if they contain sensitive substrings.\n+    - Values are not modified, except nested mappings are processed recursively in the same manner.\n+    \"\"\"\n+    tokens = [to_native(s, errors='surrogate_or_strict') for s in no_log_strings] if no_log_strings else []\n+    # Provide a sensible default ignore list if none is supplied\n+    default_ignores = ('changed', 'rc', 'status')\n+    ignore_iterable = ignore_keys if ignore_keys is not None else default_ignores\n+    ignore_set = set([to_native(k, errors='surrogate_or_strict') for k in ignore_iterable])\n+\n+    if isinstance(value, Mapping):\n+        new_value = type(value)() if isinstance(value, MutableMapping) else {}\n+        for old_key, old_val in value.items():\n+            new_key = old_key\n+            if isinstance(old_key, (text_type, binary_type)):\n+                key_native = to_native(old_key, errors='surrogate_or_strict')\n+                if key_native in ignore_set:\n+                    new_key = old_key\n+                elif tokens:\n+                    if key_native in tokens:\n+                        new_key = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'\n+                    else:\n+                        redacted_key = key_native\n+                        for t in tokens:\n+                            if t and t in redacted_key:\n+                                redacted_key = redacted_key.replace(t, '*' * 8)\n+                        new_key = redacted_key\n+            # Recurse only into mappings\n+            if isinstance(old_val, Mapping):\n+                new_val = remove_values(old_val, tokens, ignore_set)\n+            else:\n+                new_val = old_val\n+            new_value[new_key] = new_val\n+        return new_value\n+    else:\n+        return value\n \n-    while deferred_removals:\n-        old_data, new_data = deferred_removals.popleft()\n-        if isinstance(new_data, Mapping):\n-            for old_key, old_elem in old_data.items():\n-                new_key = _remove_values_conditions(old_key, no_log_strings, deferred_removals)\n-                new_elem = _remove_values_conditions(old_elem, no_log_strings, deferred_removals)\n-                new_data[new_key] = new_elem\n-        else:\n-            for elem in old_data:\n-                new_elem = _remove_values_conditions(elem, no_log_strings, deferred_removals)\n-                if isinstance(new_data, MutableSequence):\n-                    new_data.append(new_elem)\n-                elif isinstance(new_data, MutableSet):\n-                    new_data.add(new_elem)\n-                else:\n-                    raise TypeError('Unknown container type encountered when removing private values from output')\n \n-    return new_value\n+def redact_string(data, no_log_strings):\n+    \"\"\"\n+    Redact occurrences of any sensitive token in a plain string with '********'.\n+    Non-string inputs are returned unchanged.\n+    \"\"\"\n+    if not isinstance(data, (text_type, binary_type)):\n+        return data\n+\n+    native = to_native(data, errors='surrogate_or_strict')\n+    tokens = [to_native(s, errors='surrogate_or_strict') for s in no_log_strings] if no_log_strings else []\n+    for t in tokens:\n+        native = native.replace(t, '*' * 8)\n+\n+    # Return the same type as input\n+    if isinstance(data, binary_type) and PY3:\n+        return to_bytes(native, encoding='utf-8', errors='surrogate_then_replace')\n+    elif isinstance(data, text_type) and PY2:\n+        return to_text(native, encoding='utf-8', errors='surrogate_then_replace')\n+    else:\n+        return native\n \n \n def heuristic_log_sanitize(data, no_log_values=None):\n@@ -488,7 +529,7 @@ def heuristic_log_sanitize(data, no_log_values=None):\n \n     output = ''.join(output)\n     if no_log_values:\n-        output = remove_values(output, no_log_values)\n+        output = redact_string(output, no_log_values)\n     return output\n \n \n@@ -1916,10 +1957,10 @@ class AnsibleModule(object):\n             # We want journal to always take text type\n             # syslog takes bytes on py2, text type on py3\n             if isinstance(msg, binary_type):\n-                journal_msg = remove_values(msg.decode('utf-8', 'replace'), self.no_log_values)\n+                journal_msg = redact_string(msg.decode('utf-8', 'replace'), self.no_log_values)\n             else:\n                 # TODO: surrogateescape is a danger here on Py3\n-                journal_msg = remove_values(msg, self.no_log_values)\n+                journal_msg = redact_string(msg, self.no_log_values)\n \n             if PY3:\n                 syslog_msg = journal_msg\n@@ -2737,4 +2778,4 @@ class AnsibleModule(object):\n \n \n def get_module_path():\n-    return os.path.dirname(os.path.realpath(__file__))\n+    return os.path.dirname(os.path.realpath(__file__))\n",
                "diff --git a/lib/ansible/module_utils/basic.py b/lib/ansible/module_utils/basic.py\nindex 03457e1..a925c9a 100644\n--- a/lib/ansible/module_utils/basic.py\n+++ b/lib/ansible/module_utils/basic.py\n@@ -1,3 +1,4 @@\n+\n # Copyright (c), Michael DeHaan <michael.dehaan@gmail.com>, 2012-2013\n # Copyright (c), Toshio Kuratomi <tkuratomi@ansible.com> 2016\n # Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)\n@@ -427,6 +428,74 @@ def remove_values(value, no_log_strings):\n     return new_value\n \n \n+def redact_string(data, no_log_strings=None):\n+    \"\"\"\n+    Replace occurrences of sensitive tokens in a plain string with ********.\n+    Returns the string unchanged if no tokens are provided.\n+    \"\"\"\n+    if data is None:\n+        return data\n+    # normalize to text for replacement\n+    s = data if isinstance(data, text_type) else to_text(data, errors='surrogate_or_strict')\n+    if not no_log_strings:\n+        return s\n+    tokens = [to_text(tok, errors='surrogate_or_strict') for tok in no_log_strings]\n+    for tok in tokens:\n+        if not tok:\n+            continue\n+        s = s.replace(tok, '*' * 8)\n+    return s\n+\n+\n+def sanitize_keys(data, no_log_strings=None, ignore_keys=None):\n+    \"\"\"\n+    Recursively sanitize mapping keys in data.\n+    - Non-mapping values are returned unchanged.\n+    - Mapping keys that exactly match a sensitive token are replaced with VALUE_SPECIFIED_IN_NO_LOG_PARAMETER.\n+    - Mapping keys that contain a sensitive token as a substring will have that substring redacted as ********.\n+    - Keys listed in ignore_keys are left untouched (exact match).\n+    Values are not modified. Nested mappings are processed recursively.\n+    \"\"\"\n+    if not isinstance(data, Mapping):\n+        return data\n+    if no_log_strings is None:\n+        no_log_strings = []\n+    if ignore_keys is None:\n+        ignore_keys = set()\n+\n+    tokens = [to_text(t, errors='surrogate_or_strict') for t in no_log_strings]\n+    ignore = set(to_text(k, errors='surrogate_or_strict') for k in ignore_keys)\n+\n+    new_map = type(data)() if isinstance(data, MutableMapping) else {}\n+    for k, v in data.items():\n+        new_k = k\n+        if isinstance(k, (text_type, binary_type)):\n+            # convert key to text for processing\n+            k_text = k if isinstance(k, text_type) else to_text(k, errors='surrogate_or_strict')\n+\n+            if k_text in ignore:\n+                redacted_text = k_text\n+            elif k_text in tokens:\n+                redacted_text = u'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'\n+            else:\n+                redacted_text = k_text\n+                for tok in tokens:\n+                    if tok and tok in redacted_text:\n+                        redacted_text = redacted_text.replace(tok, u'*' * 8)\n+\n+            # convert back to original type\n+            if isinstance(k, binary_type):\n+                new_k = to_bytes(redacted_text, encoding='utf-8', errors='surrogate_then_replace')\n+            else:\n+                new_k = redacted_text\n+\n+        if isinstance(v, Mapping):\n+            new_map[new_k] = sanitize_keys(v, no_log_strings=no_log_strings, ignore_keys=ignore_keys)\n+        else:\n+            new_map[new_k] = v\n+    return new_map\n+\n+\n def heuristic_log_sanitize(data, no_log_values=None):\n     ''' Remove strings that look like passwords from log messages '''\n     # Currently filters:\n@@ -488,7 +557,7 @@ def heuristic_log_sanitize(data, no_log_values=None):\n \n     output = ''.join(output)\n     if no_log_values:\n-        output = remove_values(output, no_log_values)\n+        output = redact_string(output, no_log_values)\n     return output\n \n \n@@ -1916,10 +1985,10 @@ class AnsibleModule(object):\n             # We want journal to always take text type\n             # syslog takes bytes on py2, text type on py3\n             if isinstance(msg, binary_type):\n-                journal_msg = remove_values(msg.decode('utf-8', 'replace'), self.no_log_values)\n+                journal_msg = redact_string(msg.decode('utf-8', 'replace'), self.no_log_values)\n             else:\n                 # TODO: surrogateescape is a danger here on Py3\n-                journal_msg = remove_values(msg, self.no_log_values)\n+                journal_msg = redact_string(msg, self.no_log_values)\n \n             if PY3:\n                 syslog_msg = journal_msg\n@@ -2086,7 +2155,7 @@ class AnsibleModule(object):\n         if deprecations:\n             kwargs['deprecations'] = deprecations\n \n-        kwargs = remove_values(kwargs, self.no_log_values)\n+        kwargs = sanitize_keys(kwargs, self.no_log_values, ignore_keys={'changed', 'rc', 'status'})\n         print('\\n%s' % self.jsonify(kwargs))\n \n     def exit_json(self, **kwargs):\n@@ -2737,4 +2806,4 @@ class AnsibleModule(object):\n \n \n def get_module_path():\n-    return os.path.dirname(os.path.realpath(__file__))\n+    return os.path.dirname(os.path.realpath(__file__))\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "lib/ansible/module_utils/basic.py": [
                    "function: _remove_values_conditions\nfunction: remove_values\nfunction: heuristic_log_sanitize\nline: 491\nline: 492\nfunction: AnsibleModule.log\nline: 1919\nline: 1922\nfunction: AnsibleModule._return_formatted\nline: 2089\nfunction: redact_string\nfunction: sanitize_mapping_keys"
                ],
                "lib/ansible/utils/display.py": [
                    ""
                ],
                "lib/ansible/executor/task_result.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/module_utils/basic.py b/lib/ansible/module_utils/basic.py\nindex 03457e1..d69c74d 100644\n--- a/lib/ansible/module_utils/basic.py\n+++ b/lib/ansible/module_utils/basic.py\n@@ -1,3 +1,4 @@\n+\n # Copyright (c), Michael DeHaan <michael.dehaan@gmail.com>, 2012-2013\n # Copyright (c), Toshio Kuratomi <tkuratomi@ansible.com> 2016\n # Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)\n@@ -427,6 +428,110 @@ def remove_values(value, no_log_strings):\n     return new_value\n \n \n+def redact_string(value, no_log_strings):\n+    \"\"\"\n+    Helper to redact occurrences of sensitive tokens in plain strings.\n+    Only replaces substrings with '********' and preserves the original type.\n+    \"\"\"\n+    if not isinstance(value, (text_type, binary_type)):\n+        return value\n+\n+    native_str_value = value\n+    if isinstance(value, text_type):\n+        value_is_text = True\n+        if PY2:\n+            native_str_value = to_bytes(value, errors='surrogate_or_strict')\n+    else:\n+        value_is_text = False\n+        if PY3:\n+            native_str_value = to_text(value, errors='surrogate_or_strict')\n+\n+    no_log_native = [to_native(s, errors='surrogate_or_strict') for s in no_log_strings]\n+    for omit_me in no_log_native:\n+        native_str_value = native_str_value.replace(omit_me, '*' * 8)\n+\n+    if value_is_text and isinstance(native_str_value, binary_type):\n+        return to_text(native_str_value, encoding='utf-8', errors='surrogate_then_replace')\n+    elif not value_is_text and isinstance(native_str_value, text_type):\n+        return to_bytes(native_str_value, encoding='utf-8', errors='surrogate_then_replace')\n+    else:\n+        return native_str_value\n+\n+\n+def sanitize_keys(obj, no_log_strings, ignore_keys=None):\n+    \"\"\"\n+    Sanitize mapping keys in arbitrary data:\n+      - Non-mapping values (strings, booleans, numbers, lists, sets, None) are returned unchanged\n+      - Dictionaries are processed recursively:\n+          * If a key exactly matches a sensitive token, replace the key with 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'\n+          * If a key contains a sensitive token as a substring, mask that substring with '********'\n+      - An optional ignore list allows specific exact keys to remain untouched\n+    \"\"\"\n+    no_log_native = set(to_native(s, errors='surrogate_or_strict') for s in no_log_strings)\n+    ignore_native = set(to_native(s, errors='surrogate_or_strict') for s in (ignore_keys or set()))\n+\n+    def _sanitize_key(k):\n+        if isinstance(k, (text_type, binary_type)):\n+            native_k = k\n+            if isinstance(k, text_type):\n+                value_is_text = True\n+                if PY2:\n+                    native_k = to_bytes(k, errors='surrogate_or_strict')\n+            else:\n+                value_is_text = False\n+                if PY3:\n+                    native_k = to_text(k, errors='surrogate_or_strict')\n+\n+            if native_k in ignore_native:\n+                new_native = native_k\n+            elif native_k in no_log_native:\n+                new_native = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'\n+            else:\n+                new_native = native_k\n+                for omit_me in no_log_native:\n+                    new_native = new_native.replace(omit_me, '*' * 8)\n+\n+            if value_is_text and isinstance(new_native, binary_type):\n+                return to_text(new_native, encoding='utf-8', errors='surrogate_then_replace')\n+            elif not value_is_text and isinstance(new_native, text_type):\n+                return to_bytes(new_native, encoding='utf-8', errors='surrogate_then_replace')\n+            else:\n+                return new_native\n+        return k\n+\n+    def _process(o):\n+        if isinstance(o, Mapping):\n+            if isinstance(o, MutableMapping):\n+                new_map = type(o)()\n+            else:\n+                new_map = {}\n+            for old_key, old_val in o.items():\n+                new_key = _sanitize_key(old_key)\n+                new_val = _process(old_val)\n+                new_map[new_key] = new_val\n+            return new_map\n+        elif isinstance(o, Sequence) and not isinstance(o, (text_type, binary_type)):\n+            if isinstance(o, MutableSequence):\n+                new_seq = type(o)()\n+            else:\n+                new_seq = []\n+            for elem in o:\n+                new_seq.append(_process(elem))\n+            return new_seq\n+        elif isinstance(o, Set):\n+            if isinstance(o, MutableSet):\n+                new_set = type(o)()\n+            else:\n+                new_set = set()\n+            for elem in o:\n+                new_set.add(_process(elem))\n+            return new_set\n+        else:\n+            return o\n+\n+    return _process(obj)\n+\n+\n def heuristic_log_sanitize(data, no_log_values=None):\n     ''' Remove strings that look like passwords from log messages '''\n     # Currently filters:\n@@ -488,7 +593,7 @@ def heuristic_log_sanitize(data, no_log_values=None):\n \n     output = ''.join(output)\n     if no_log_values:\n-        output = remove_values(output, no_log_values)\n+        output = redact_string(output, no_log_values)\n     return output\n \n \n@@ -1916,10 +2021,10 @@ class AnsibleModule(object):\n             # We want journal to always take text type\n             # syslog takes bytes on py2, text type on py3\n             if isinstance(msg, binary_type):\n-                journal_msg = remove_values(msg.decode('utf-8', 'replace'), self.no_log_values)\n+                journal_msg = redact_string(msg.decode('utf-8', 'replace'), self.no_log_values)\n             else:\n                 # TODO: surrogateescape is a danger here on Py3\n-                journal_msg = remove_values(msg, self.no_log_values)\n+                journal_msg = redact_string(msg, self.no_log_values)\n \n             if PY3:\n                 syslog_msg = journal_msg\n@@ -2086,7 +2191,7 @@ class AnsibleModule(object):\n         if deprecations:\n             kwargs['deprecations'] = deprecations\n \n-        kwargs = remove_values(kwargs, self.no_log_values)\n+        kwargs = sanitize_keys(kwargs, self.no_log_values, ignore_keys={'changed', 'rc', 'status'})\n         print('\\n%s' % self.jsonify(kwargs))\n \n     def exit_json(self, **kwargs):\n@@ -2737,4 +2842,4 @@ class AnsibleModule(object):\n \n \n def get_module_path():\n-    return os.path.dirname(os.path.realpath(__file__))\n+    return os.path.dirname(os.path.realpath(__file__))\n",
                "diff --git a/lib/ansible/module_utils/basic.py b/lib/ansible/module_utils/basic.py\nindex 03457e1..3ed62ce 100644\n--- a/lib/ansible/module_utils/basic.py\n+++ b/lib/ansible/module_utils/basic.py\n@@ -1,3 +1,4 @@\n+\n # Copyright (c), Michael DeHaan <michael.dehaan@gmail.com>, 2012-2013\n # Copyright (c), Toshio Kuratomi <tkuratomi@ansible.com> 2016\n # Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)\n@@ -427,6 +428,64 @@ def remove_values(value, no_log_strings):\n     return new_value\n \n \n+def _redact_sensitive_string(data, no_log_values):\n+    \"\"\"\n+    Replace occurrences of sensitive tokens in a plain string with asterisks.\n+    Does not change non-matching strings and never replaces the whole string\n+    with a sentinel. Returns a text string.\n+    \"\"\"\n+    native = to_native(data)\n+    if not no_log_values:\n+        return native\n+    tokens = [to_native(s, errors='surrogate_or_strict') for s in no_log_values]\n+    for token in tokens:\n+        if token:\n+            native = native.replace(token, '*' * 8)\n+    return native\n+\n+\n+def _sanitize_mapping_keys(obj, no_log_values, ignore_keys=None):\n+    \"\"\"\n+    Return a copy of obj where only mapping keys are sanitized:\n+      - If a key exactly matches a sensitive token, it is replaced with\n+        'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'.\n+      - If a key name contains a sensitive token as a substring, that\n+        substring is replaced with '********'.\n+      - Keys listed in ignore_keys are left untouched.\n+    Non-mapping values are returned unchanged. Dictionaries are processed\n+    recursively; values that are themselves mappings are sanitized in the\n+    same manner. Other container types (lists, sets, tuples) are left as-is.\n+    \"\"\"\n+    if not isinstance(obj, Mapping):\n+        return obj\n+\n+    tokens = [to_native(s, errors='surrogate_or_strict') for s in (no_log_values or ())]\n+    ignore_native = set(to_native(k, errors='surrogate_or_strict') for k in (ignore_keys or set()))\n+\n+    def _sanitize_key(key):\n+        if isinstance(key, (text_type, binary_type)):\n+            key_native = to_native(key, errors='surrogate_or_strict')\n+            if key_native in ignore_native:\n+                return key_native\n+            if key_native in tokens:\n+                return 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'\n+            masked = key_native\n+            for t in tokens:\n+                if t and t in masked:\n+                    masked = masked.replace(t, '*' * 8)\n+            return masked\n+        return key\n+\n+    new_obj = {}\n+    for k, v in obj.items():\n+        new_k = _sanitize_key(k)\n+        if isinstance(v, Mapping):\n+            new_obj[new_k] = _sanitize_mapping_keys(v, tokens, ignore_keys)\n+        else:\n+            new_obj[new_k] = v\n+    return new_obj\n+\n+\n def heuristic_log_sanitize(data, no_log_values=None):\n     ''' Remove strings that look like passwords from log messages '''\n     # Currently filters:\n@@ -488,7 +547,7 @@ def heuristic_log_sanitize(data, no_log_values=None):\n \n     output = ''.join(output)\n     if no_log_values:\n-        output = remove_values(output, no_log_values)\n+        output = _redact_sensitive_string(output, no_log_values)\n     return output\n \n \n@@ -1916,10 +1975,10 @@ class AnsibleModule(object):\n             # We want journal to always take text type\n             # syslog takes bytes on py2, text type on py3\n             if isinstance(msg, binary_type):\n-                journal_msg = remove_values(msg.decode('utf-8', 'replace'), self.no_log_values)\n+                journal_msg = _redact_sensitive_string(msg.decode('utf-8', 'replace'), self.no_log_values)\n             else:\n                 # TODO: surrogateescape is a danger here on Py3\n-                journal_msg = remove_values(msg, self.no_log_values)\n+                journal_msg = _redact_sensitive_string(msg, self.no_log_values)\n \n             if PY3:\n                 syslog_msg = journal_msg\n@@ -1928,8 +1987,9 @@ class AnsibleModule(object):\n \n             if has_journal:\n                 journal_args = [(\"MODULE\", os.path.basename(__file__))]\n-                for arg in log_args:\n-                    journal_args.append((arg.upper(), str(log_args[arg])))\n+                sanitized_log_args = _sanitize_mapping_keys(log_args, self.no_log_values, ignore_keys={'changed', 'rc', 'status'})\n+                for arg in sanitized_log_args:\n+                    journal_args.append((to_native(arg).upper(), str(sanitized_log_args[arg])))\n                 try:\n                     if HAS_SYSLOG:\n                         # If syslog_facility specified, it needs to convert\n@@ -2086,7 +2146,7 @@ class AnsibleModule(object):\n         if deprecations:\n             kwargs['deprecations'] = deprecations\n \n-        kwargs = remove_values(kwargs, self.no_log_values)\n+        kwargs = _sanitize_mapping_keys(kwargs, self.no_log_values, ignore_keys={'changed', 'rc', 'status'})\n         print('\\n%s' % self.jsonify(kwargs))\n \n     def exit_json(self, **kwargs):\n@@ -2737,4 +2797,4 @@ class AnsibleModule(object):\n \n \n def get_module_path():\n-    return os.path.dirname(os.path.realpath(__file__))\n+    return os.path.dirname(os.path.realpath(__file__))\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/lib/ansible/module_utils/basic.py b/lib/ansible/module_utils/basic.py\nindex 03457e1..7e94262 100644\n--- a/lib/ansible/module_utils/basic.py\n+++ b/lib/ansible/module_utils/basic.py\n@@ -1,3 +1,4 @@\n+\n # Copyright (c), Michael DeHaan <michael.dehaan@gmail.com>, 2012-2013\n # Copyright (c), Toshio Kuratomi <tkuratomi@ansible.com> 2016\n # Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)\n@@ -399,32 +400,72 @@ def _remove_values_conditions(value, no_log_strings, deferred_removals):\n     return value\n \n \n-def remove_values(value, no_log_strings):\n-    \"\"\" Remove strings in no_log_strings from value.  If value is a container\n-    type, then remove a lot more\"\"\"\n-    deferred_removals = deque()\n-\n-    no_log_strings = [to_native(s, errors='surrogate_or_strict') for s in no_log_strings]\n-    new_value = _remove_values_conditions(value, no_log_strings, deferred_removals)\n+def remove_values(value, no_log_strings, ignore_keys=None):\n+    \"\"\"\n+    Sanitize mapping keys by masking sensitive tokens in the keys.\n+\n+    Behavior:\n+    - Non-mapping values (strings, numbers, lists, sets, None, etc.) are returned unchanged.\n+    - For mapping keys:\n+        * If a key exactly matches a sensitive token, the key is replaced with 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'.\n+        * If a key contains a sensitive token as a substring, that substring is replaced with '********'.\n+        * Keys listed in ignore_keys are left untouched even if they contain sensitive substrings.\n+    - Values are not modified, except nested mappings are processed recursively in the same manner.\n+    \"\"\"\n+    tokens = [to_native(s, errors='surrogate_or_strict') for s in no_log_strings] if no_log_strings else []\n+    # Provide a sensible default ignore list if none is supplied\n+    default_ignores = ('changed', 'rc', 'status')\n+    ignore_iterable = ignore_keys if ignore_keys is not None else default_ignores\n+    ignore_set = set([to_native(k, errors='surrogate_or_strict') for k in ignore_iterable])\n+\n+    if isinstance(value, Mapping):\n+        new_value = type(value)() if isinstance(value, MutableMapping) else {}\n+        for old_key, old_val in value.items():\n+            new_key = old_key\n+            if isinstance(old_key, (text_type, binary_type)):\n+                key_native = to_native(old_key, errors='surrogate_or_strict')\n+                if key_native in ignore_set:\n+                    new_key = old_key\n+                elif tokens:\n+                    if key_native in tokens:\n+                        new_key = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'\n+                    else:\n+                        redacted_key = key_native\n+                        for t in tokens:\n+                            if t and t in redacted_key:\n+                                redacted_key = redacted_key.replace(t, '*' * 8)\n+                        new_key = redacted_key\n+            # Recurse only into mappings\n+            if isinstance(old_val, Mapping):\n+                new_val = remove_values(old_val, tokens, ignore_set)\n+            else:\n+                new_val = old_val\n+            new_value[new_key] = new_val\n+        return new_value\n+    else:\n+        return value\n \n-    while deferred_removals:\n-        old_data, new_data = deferred_removals.popleft()\n-        if isinstance(new_data, Mapping):\n-            for old_key, old_elem in old_data.items():\n-                new_key = _remove_values_conditions(old_key, no_log_strings, deferred_removals)\n-                new_elem = _remove_values_conditions(old_elem, no_log_strings, deferred_removals)\n-                new_data[new_key] = new_elem\n-        else:\n-            for elem in old_data:\n-                new_elem = _remove_values_conditions(elem, no_log_strings, deferred_removals)\n-                if isinstance(new_data, MutableSequence):\n-                    new_data.append(new_elem)\n-                elif isinstance(new_data, MutableSet):\n-                    new_data.add(new_elem)\n-                else:\n-                    raise TypeError('Unknown container type encountered when removing private values from output')\n \n-    return new_value\n+def redact_string(data, no_log_strings):\n+    \"\"\"\n+    Redact occurrences of any sensitive token in a plain string with '********'.\n+    Non-string inputs are returned unchanged.\n+    \"\"\"\n+    if not isinstance(data, (text_type, binary_type)):\n+        return data\n+\n+    native = to_native(data, errors='surrogate_or_strict')\n+    tokens = [to_native(s, errors='surrogate_or_strict') for s in no_log_strings] if no_log_strings else []\n+    for t in tokens:\n+        native = native.replace(t, '*' * 8)\n+\n+    # Return the same type as input\n+    if isinstance(data, binary_type) and PY3:\n+        return to_bytes(native, encoding='utf-8', errors='surrogate_then_replace')\n+    elif isinstance(data, text_type) and PY2:\n+        return to_text(native, encoding='utf-8', errors='surrogate_then_replace')\n+    else:\n+        return native\n \n \n def heuristic_log_sanitize(data, no_log_values=None):\n@@ -488,7 +529,7 @@ def heuristic_log_sanitize(data, no_log_values=None):\n \n     output = ''.join(output)\n     if no_log_values:\n-        output = remove_values(output, no_log_values)\n+        output = redact_string(output, no_log_values)\n     return output\n \n \n@@ -1916,10 +1957,10 @@ class AnsibleModule(object):\n             # We want journal to always take text type\n             # syslog takes bytes on py2, text type on py3\n             if isinstance(msg, binary_type):\n-                journal_msg = remove_values(msg.decode('utf-8', 'replace'), self.no_log_values)\n+                journal_msg = redact_string(msg.decode('utf-8', 'replace'), self.no_log_values)\n             else:\n                 # TODO: surrogateescape is a danger here on Py3\n-                journal_msg = remove_values(msg, self.no_log_values)\n+                journal_msg = redact_string(msg, self.no_log_values)\n \n             if PY3:\n                 syslog_msg = journal_msg\n@@ -2737,4 +2778,4 @@ class AnsibleModule(object):\n \n \n def get_module_path():\n-    return os.path.dirname(os.path.realpath(__file__))\n+    return os.path.dirname(os.path.realpath(__file__))\n"
}