{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__e2b70931",
    "original_id": "instance_ansible__ansible-5640093f1ca63fd6af231cc8a7fb7d40e1907b8c-vba6da65a0f3baefda7a058ebbd0a8dcafb8512f5",
    "1_model_selected_files": [
        "lib/ansible/plugins/action/gather_facts.py",
        "lib/ansible/plugins/action/package.py",
        "lib/ansible/plugins/action/service.py",
        "lib/ansible/plugins/action/__init__.py",
        "lib/ansible/plugins/loader.py"
    ],
    "2_embedding_selected_files": [
        "lib/ansible/plugins/action/gather_facts.py",
        "lib/ansible/plugins/action/service.py",
        "lib/ansible/executor/module_common.py",
        "lib/ansible/plugins/action/set_fact.py",
        "lib/ansible/plugins/doc_fragments/action_common_attributes.py",
        "lib/ansible/plugins/action/__init__.py",
        "lib/ansible/plugins/action/normal.py",
        "lib/ansible/plugins/action/async_status.py",
        "lib/ansible/modules/service_facts.py",
        "lib/ansible/modules/gather_facts.py",
        "lib/ansible/plugins/action/package.py",
        "lib/ansible/plugins/action/raw.py",
        "lib/ansible/plugins/action/yum.py",
        "lib/ansible/plugins/action/include_vars.py",
        "lib/ansible/plugins/action/set_stats.py",
        "lib/ansible/plugins/callback/default.py",
        "lib/ansible/modules/setup.py",
        "lib/ansible/module_utils/facts/compat.py",
        "lib/ansible/plugins/action/template.py",
        "lib/ansible/plugins/action/command.py",
        "lib/ansible/modules/meta.py",
        "lib/ansible/plugins/action/script.py",
        "examples/scripts/my_test_facts.py",
        "lib/ansible/plugins/doc_fragments/default_callback.py",
        "lib/ansible/plugins/action/shell.py",
        "lib/ansible/plugins/action/reboot.py",
        "lib/ansible/plugins/action/validate_argument_spec.py",
        "lib/ansible/executor/task_executor.py",
        "lib/ansible/modules/package_facts.py",
        "lib/ansible/modules/set_fact.py",
        "lib/ansible/plugins/doc_fragments/return_common.py",
        "lib/ansible/modules/template.py",
        "lib/ansible/parsing/mod_args.py",
        "lib/ansible/executor/action_write_locks.py",
        "lib/ansible/module_utils/facts/system/service_mgr.py",
        "lib/ansible/module_utils/facts/default_collectors.py",
        "lib/ansible/plugins/become/sudo.py",
        "lib/ansible/plugins/action/unarchive.py",
        "lib/ansible/modules/dnf.py",
        "lib/ansible/plugins/action/copy.py",
        "lib/ansible/plugins/action/debug.py",
        "lib/ansible/modules/service.py",
        "lib/ansible/plugins/action/uri.py",
        "lib/ansible/plugins/doc_fragments/template_common.py",
        "lib/ansible/executor/powershell/module_manifest.py",
        "lib/ansible/plugins/become/runas.py",
        "lib/ansible/plugins/action/assemble.py",
        "lib/ansible/modules/apt.py",
        "lib/ansible/plugins/action/group_by.py",
        "hacking/build_library/build_ansible/command_plugins/dump_config.py",
        "lib/ansible/plugins/action/fetch.py",
        "lib/ansible/plugins/doc_fragments/shell_common.py",
        "lib/ansible/modules/systemd.py",
        "lib/ansible/vars/clean.py",
        "lib/ansible/module_utils/facts/other/__init__.py",
        "lib/ansible/module_utils/facts/__init__.py"
    ],
    "3_final_combined_files": [
        "lib/ansible/plugins/action/gather_facts.py",
        "lib/ansible/plugins/action/service.py",
        "lib/ansible/plugins/action/package.py",
        "lib/ansible/executor/module_common.py"
    ],
    "4_related_elements": {
        "lib/ansible/plugins/action/gather_facts.py": [
            "function: ActionModule._get_module_args\nfunction: ActionModule._combine_task_result\nfunction: ActionModule.run"
        ],
        "lib/ansible/plugins/action/service.py": [
            "class: ActionModule\nfunction: ActionModule.run"
        ],
        "lib/ansible/plugins/action/package.py": [
            "class: ActionModule\nfunction: ActionModule.run\nvariable: display\nvariable: PKG_MGRS"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "lib/ansible/plugins/action/gather_facts.py": [
                    "function: ActionModule._get_module_args\nline: 44\nfunction: ActionModule.run\nline: 65"
                ],
                "lib/ansible/plugins/action/service.py": [
                    "function: ActionModule.run\nline: 82\nline: 83\nline: 84\nline: 87\nline: 88\nline: 89"
                ],
                "lib/ansible/plugins/action/package.py": [
                    "function: ActionModule.run\nline: 75\nline: 76\nline: 78\nline: 79\nline: 80\nline: 81"
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/plugins/action/gather_facts.py b/lib/ansible/plugins/action/gather_facts.py\nindex 1b577e7..3277b89 100644\n--- a/lib/ansible/plugins/action/gather_facts.py\n+++ b/lib/ansible/plugins/action/gather_facts.py\n@@ -62,13 +62,16 @@ class ActionModule(ActionBase):\n         result = super(ActionModule, self).run(tmp, task_vars)\n         result['ansible_facts'] = {}\n \n-        modules = C.config.get_config_value('FACTS_MODULES', variables=task_vars)\n+        # work on a copy to avoid mutating the original configuration\n+        modules = list(C.config.get_config_value('FACTS_MODULES', variables=task_vars) or [])\n         parallel = task_vars.pop('ansible_facts_parallel', self._task.args.pop('parallel', None))\n         if 'smart' in modules:\n             connection_map = C.config.get_config_value('CONNECTION_FACTS_MODULES', variables=task_vars)\n             network_os = self._task.args.get('network_os', task_vars.get('ansible_network_os', task_vars.get('ansible_facts', {}).get('network_os')))\n-            modules.extend([connection_map.get(network_os or self._connection._load_name, 'ansible.legacy.setup')])\n-            modules.pop(modules.index('smart'))\n+            resolved_module = connection_map.get(network_os or self._connection._load_name, 'ansible.legacy.setup')\n+            # replace any 'smart' entries with the resolved facts module\n+            modules = [m for m in modules if m != 'smart']\n+            modules.append(resolved_module)\n \n         failed = {}\n         skipped = {}\n@@ -135,4 +138,4 @@ class ActionModule(ActionBase):\n         # hack to keep --verbose from showing all the setup module result\n         result['_ansible_verbose_override'] = True\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/package.py b/lib/ansible/plugins/action/package.py\nindex ecef676..a5650a4 100644\n--- a/lib/ansible/plugins/action/package.py\n+++ b/lib/ansible/plugins/action/package.py\n@@ -70,15 +70,15 @@ class ActionModule(ActionBase):\n                     if 'use' in new_module_args:\n                         del new_module_args['use']\n \n-                    # get defaults for specific module\n-                    new_module_args = get_action_args_with_defaults(\n-                        module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                    )\n-\n                     if module in self.BUILTIN_PKG_MGR_MODULES:\n                         # prefix with ansible.legacy to eliminate external collisions while still allowing library/ override\n                         module = 'ansible.legacy.' + module\n \n+                    # get defaults for the actually executed module (after any redirection/prefixing)\n+                    new_module_args = get_action_args_with_defaults(\n+                        module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+                    )\n+\n                     display.vvvv(\"Running %s\" % module)\n                     result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n             else:\n@@ -91,4 +91,4 @@ class ActionModule(ActionBase):\n                 # remove a temporary path we created\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/service.py b/lib/ansible/plugins/action/service.py\nindex 340c9bb..418a18e 100644\n--- a/lib/ansible/plugins/action/service.py\n+++ b/lib/ansible/plugins/action/service.py\n@@ -78,15 +78,15 @@ class ActionModule(ActionBase):\n                             del new_module_args[unused]\n                             self._display.warning('Ignoring \"%s\" as it is not used in \"%s\"' % (unused, module))\n \n-                # get defaults for specific module\n-                new_module_args = get_action_args_with_defaults(\n-                    module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                )\n-\n                 # collection prefix known internal modules to avoid collisions from collections search, while still allowing library/ overrides\n                 if module in self.BUILTIN_SVC_MGR_MODULES:\n                     module = 'ansible.legacy.' + module\n \n+                # get defaults for the actually executed module (after any redirection/prefixing)\n+                new_module_args = get_action_args_with_defaults(\n+                    module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+                )\n+\n                 self._display.vvvv(\"Running %s\" % module)\n                 result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n             else:\n@@ -98,4 +98,4 @@ class ActionModule(ActionBase):\n             if not self._task.async_val:\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\n",
                "diff --git a/lib/ansible/plugins/action/gather_facts.py b/lib/ansible/plugins/action/gather_facts.py\nindex 1b577e7..0b69385 100644\n--- a/lib/ansible/plugins/action/gather_facts.py\n+++ b/lib/ansible/plugins/action/gather_facts.py\n@@ -41,7 +41,17 @@ class ActionModule(ActionBase):\n         mod_args = dict((k, v) for k, v in mod_args.items() if v is not None)\n \n         # handle module defaults\n-        mod_args = get_action_args_with_defaults(fact_module, mod_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list)\n+        # Build a redirection list for the underlying facts module so module_defaults\n+        # are applied consistently regardless of short name, FQCN, or ansible.legacy/builtin aliases.\n+        redirect_list = [fact_module]\n+        if isinstance(fact_module, str):\n+            if fact_module.startswith('ansible.legacy.') or fact_module.startswith('ansible.builtin.'):\n+                short_name = fact_module.split('.')[-1]\n+                redirect_list = [fact_module, short_name, 'ansible.legacy.%s' % short_name, 'ansible.builtin.%s' % short_name]\n+            elif '.' not in fact_module:\n+                short_name = fact_module\n+                redirect_list = [short_name, 'ansible.legacy.%s' % short_name, 'ansible.builtin.%s' % short_name]\n+        mod_args = get_action_args_with_defaults(fact_module, mod_args, self._task.module_defaults, self._templar, redirect_list)\n \n         return mod_args\n \n@@ -62,7 +72,8 @@ class ActionModule(ActionBase):\n         result = super(ActionModule, self).run(tmp, task_vars)\n         result['ansible_facts'] = {}\n \n-        modules = C.config.get_config_value('FACTS_MODULES', variables=task_vars)\n+        # Work on a copy to avoid mutating the original configuration when using smart mode\n+        modules = list(C.config.get_config_value('FACTS_MODULES', variables=task_vars))\n         parallel = task_vars.pop('ansible_facts_parallel', self._task.args.pop('parallel', None))\n         if 'smart' in modules:\n             connection_map = C.config.get_config_value('CONNECTION_FACTS_MODULES', variables=task_vars)\n@@ -135,4 +146,4 @@ class ActionModule(ActionBase):\n         # hack to keep --verbose from showing all the setup module result\n         result['_ansible_verbose_override'] = True\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/package.py b/lib/ansible/plugins/action/package.py\nindex ecef676..e0d242c 100644\n--- a/lib/ansible/plugins/action/package.py\n+++ b/lib/ansible/plugins/action/package.py\n@@ -70,15 +70,24 @@ class ActionModule(ActionBase):\n                     if 'use' in new_module_args:\n                         del new_module_args['use']\n \n-                    # get defaults for specific module\n-                    new_module_args = get_action_args_with_defaults(\n-                        module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                    )\n-\n                     if module in self.BUILTIN_PKG_MGR_MODULES:\n                         # prefix with ansible.legacy to eliminate external collisions while still allowing library/ override\n                         module = 'ansible.legacy.' + module\n \n+                    # get defaults for specific module, using a redirect list that covers short/FQCN/legacy/builtin names\n+                    redirect_list = [module]\n+                    if isinstance(module, str):\n+                        if module.startswith('ansible.legacy.') or module.startswith('ansible.builtin.'):\n+                            short_name = module.split('.')[-1]\n+                            redirect_list = [module, short_name, 'ansible.legacy.%s' % short_name, 'ansible.builtin.%s' % short_name]\n+                        elif '.' not in module:\n+                            short_name = module\n+                            redirect_list = [short_name, 'ansible.legacy.%s' % short_name, 'ansible.builtin.%s' % short_name]\n+\n+                    new_module_args = get_action_args_with_defaults(\n+                        module, new_module_args, self._task.module_defaults, self._templar, redirect_list\n+                    )\n+\n                     display.vvvv(\"Running %s\" % module)\n                     result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n             else:\n@@ -91,4 +100,4 @@ class ActionModule(ActionBase):\n                 # remove a temporary path we created\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/service.py b/lib/ansible/plugins/action/service.py\nindex 340c9bb..9f35268 100644\n--- a/lib/ansible/plugins/action/service.py\n+++ b/lib/ansible/plugins/action/service.py\n@@ -78,15 +78,24 @@ class ActionModule(ActionBase):\n                             del new_module_args[unused]\n                             self._display.warning('Ignoring \"%s\" as it is not used in \"%s\"' % (unused, module))\n \n-                # get defaults for specific module\n-                new_module_args = get_action_args_with_defaults(\n-                    module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                )\n-\n                 # collection prefix known internal modules to avoid collisions from collections search, while still allowing library/ overrides\n                 if module in self.BUILTIN_SVC_MGR_MODULES:\n                     module = 'ansible.legacy.' + module\n \n+                # get defaults for specific module, using a redirect list that covers short/FQCN/legacy/builtin names\n+                redirect_list = [module]\n+                if isinstance(module, str):\n+                    if module.startswith('ansible.legacy.') or module.startswith('ansible.builtin.'):\n+                        short_name = module.split('.')[-1]\n+                        redirect_list = [module, short_name, 'ansible.legacy.%s' % short_name, 'ansible.builtin.%s' % short_name]\n+                    elif '.' not in module:\n+                        short_name = module\n+                        redirect_list = [short_name, 'ansible.legacy.%s' % short_name, 'ansible.builtin.%s' % short_name]\n+\n+                new_module_args = get_action_args_with_defaults(\n+                    module, new_module_args, self._task.module_defaults, self._templar, redirect_list\n+                )\n+\n                 self._display.vvvv(\"Running %s\" % module)\n                 result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n             else:\n@@ -98,4 +107,4 @@ class ActionModule(ActionBase):\n             if not self._task.async_val:\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "lib/ansible/plugins/action/gather_facts.py": [
                    "function: ActionModule._get_module_args\nline: 44\nfunction: ActionModule.run\nline: 65\nline: 66\nline: 67\nline: 68\nline: 69\nline: 70\nline: 71"
                ],
                "lib/ansible/plugins/action/service.py": [
                    "function: ActionModule.run\nline: 81\nline: 82\nline: 83\nline: 84\nline: 85\nline: 87\nline: 88\nline: 89"
                ],
                "lib/ansible/plugins/action/package.py": [
                    "function: ActionModule.run\nline: 73\nline: 74\nline: 75\nline: 76\nline: 77\nline: 79\nline: 80\nline: 81"
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/plugins/action/gather_facts.py b/lib/ansible/plugins/action/gather_facts.py\nindex 1b577e7..48e9f65 100644\n--- a/lib/ansible/plugins/action/gather_facts.py\n+++ b/lib/ansible/plugins/action/gather_facts.py\n@@ -62,7 +62,7 @@ class ActionModule(ActionBase):\n         result = super(ActionModule, self).run(tmp, task_vars)\n         result['ansible_facts'] = {}\n \n-        modules = C.config.get_config_value('FACTS_MODULES', variables=task_vars)\n+        modules = list(C.config.get_config_value('FACTS_MODULES', variables=task_vars) or [])\n         parallel = task_vars.pop('ansible_facts_parallel', self._task.args.pop('parallel', None))\n         if 'smart' in modules:\n             connection_map = C.config.get_config_value('CONNECTION_FACTS_MODULES', variables=task_vars)\n@@ -135,4 +135,4 @@ class ActionModule(ActionBase):\n         # hack to keep --verbose from showing all the setup module result\n         result['_ansible_verbose_override'] = True\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/package.py b/lib/ansible/plugins/action/package.py\nindex ecef676..36a4778 100644\n--- a/lib/ansible/plugins/action/package.py\n+++ b/lib/ansible/plugins/action/package.py\n@@ -61,29 +61,32 @@ class ActionModule(ActionBase):\n                 display.debug(\"Facts %s\" % facts)\n                 module = facts.get('ansible_facts', {}).get('ansible_pkg_mgr', 'auto')\n \n-            if module != 'auto':\n-                if not self._shared_loader_obj.module_loader.has_plugin(module):\n-                    raise AnsibleActionFail('Could not find a module for %s.' % module)\n-                else:\n-                    # run the 'package' module\n-                    new_module_args = self._task.args.copy()\n-                    if 'use' in new_module_args:\n-                        del new_module_args['use']\n-\n-                    # get defaults for specific module\n-                    new_module_args = get_action_args_with_defaults(\n-                        module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                    )\n-\n-                    if module in self.BUILTIN_PKG_MGR_MODULES:\n-                        # prefix with ansible.legacy to eliminate external collisions while still allowing library/ override\n-                        module = 'ansible.legacy.' + module\n-\n-                    display.vvvv(\"Running %s\" % module)\n-                    result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n-            else:\n+            if module == 'auto':\n                 raise AnsibleActionFail('Could not detect which package manager to use. Try gathering facts or setting the \"use\" option.')\n \n+            # Resolve the actual module to execute, prefer ansible.legacy.* for built-ins\n+            if module in self.BUILTIN_PKG_MGR_MODULES:\n+                final_module = 'ansible.legacy.' + module\n+            else:\n+                final_module = module\n+\n+            # Validate existence for non-builtin modules\n+            if module not in self.BUILTIN_PKG_MGR_MODULES and not self._shared_loader_obj.module_loader.has_plugin(final_module):\n+                raise AnsibleActionFail('Could not find a module for %s.' % module)\n+\n+            # run the resolved package manager module\n+            new_module_args = self._task.args.copy()\n+            if 'use' in new_module_args:\n+                del new_module_args['use']\n+\n+            # get defaults for the resolved module\n+            new_module_args = get_action_args_with_defaults(\n+                final_module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+            )\n+\n+            display.vvvv(\"Running %s\" % final_module)\n+            result.update(self._execute_module(module_name=final_module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n+\n         except AnsibleAction as e:\n             result.update(e.result)\n         finally:\n@@ -91,4 +94,4 @@ class ActionModule(ActionBase):\n                 # remove a temporary path we created\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/service.py b/lib/ansible/plugins/action/service.py\nindex 340c9bb..c3218c2 100644\n--- a/lib/ansible/plugins/action/service.py\n+++ b/lib/ansible/plugins/action/service.py\n@@ -63,34 +63,34 @@ class ActionModule(ActionBase):\n                 self._display.debug(\"Facts %s\" % facts)\n                 module = facts.get('ansible_facts', {}).get('ansible_service_mgr', 'auto')\n \n-            if not module or module == 'auto' or not self._shared_loader_obj.module_loader.has_plugin(module):\n-                module = 'ansible.legacy.service'\n-\n-            if module != 'auto':\n-                # run the 'service' module\n-                new_module_args = self._task.args.copy()\n-                if 'use' in new_module_args:\n-                    del new_module_args['use']\n-\n-                if module in self.UNUSED_PARAMS:\n-                    for unused in self.UNUSED_PARAMS[module]:\n-                        if unused in new_module_args:\n-                            del new_module_args[unused]\n-                            self._display.warning('Ignoring \"%s\" as it is not used in \"%s\"' % (unused, module))\n-\n-                # get defaults for specific module\n-                new_module_args = get_action_args_with_defaults(\n-                    module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                )\n-\n-                # collection prefix known internal modules to avoid collisions from collections search, while still allowing library/ overrides\n-                if module in self.BUILTIN_SVC_MGR_MODULES:\n-                    module = 'ansible.legacy.' + module\n-\n-                self._display.vvvv(\"Running %s\" % module)\n-                result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n+            # Determine the actual module to execute, preferring ansible.legacy.* for built-ins to avoid collisions\n+            if module in self.BUILTIN_SVC_MGR_MODULES:\n+                final_module = 'ansible.legacy.' + module\n+            elif not module or module == 'auto' or not self._shared_loader_obj.module_loader.has_plugin(module):\n+                final_module = 'ansible.legacy.service'\n             else:\n-                raise AnsibleActionFail('Could not detect which service manager to use. Try gathering facts or setting the \"use\" option.')\n+                final_module = module\n+\n+            # run the resolved service manager module\n+            new_module_args = self._task.args.copy()\n+            if 'use' in new_module_args:\n+                del new_module_args['use']\n+\n+            # Drop parameters unused by the selected service manager\n+            short_name = final_module.split('.')[-1]\n+            if short_name in self.UNUSED_PARAMS:\n+                for unused in self.UNUSED_PARAMS[short_name]:\n+                    if unused in new_module_args:\n+                        del new_module_args[unused]\n+                        self._display.warning('Ignoring \"%s\" as it is not used in \"%s\"' % (unused, final_module))\n+\n+            # get defaults for the resolved module\n+            new_module_args = get_action_args_with_defaults(\n+                final_module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+            )\n+\n+            self._display.vvvv(\"Running %s\" % final_module)\n+            result.update(self._execute_module(module_name=final_module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n \n         except AnsibleAction as e:\n             result.update(e.result)\n@@ -98,4 +98,4 @@ class ActionModule(ActionBase):\n             if not self._task.async_val:\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\n",
                "diff --git a/lib/ansible/plugins/action/gather_facts.py b/lib/ansible/plugins/action/gather_facts.py\nindex 1b577e7..8ec819c 100644\n--- a/lib/ansible/plugins/action/gather_facts.py\n+++ b/lib/ansible/plugins/action/gather_facts.py\n@@ -18,30 +18,37 @@ class ActionModule(ActionBase):\n \n     def _get_module_args(self, fact_module, task_vars):\n \n+        # Normalize the module name to the actually executed plugin so defaults defined via FQCN are applied consistently\n+        executed_module = fact_module\n+        if fact_module == 'setup':\n+            executed_module = 'ansible.legacy.setup'\n+\n         mod_args = self._task.args.copy()\n \n         # deal with 'setup specific arguments'\n-        if fact_module not in C._ACTION_SETUP:\n+        if fact_module not in C._ACTION_SETUP and executed_module != 'ansible.legacy.setup':\n             # network facts modules must support gather_subset\n             if self._connection._load_name not in ('network_cli', 'httpapi', 'netconf'):\n                 subset = mod_args.pop('gather_subset', None)\n                 if subset not in ('all', ['all']):\n-                    self._display.warning('Ignoring subset(%s) for %s' % (subset, fact_module))\n+                    self._display.warning('Ignoring subset(%s) for %s' % (subset, executed_module))\n \n             timeout = mod_args.pop('gather_timeout', None)\n             if timeout is not None:\n-                self._display.warning('Ignoring timeout(%s) for %s' % (timeout, fact_module))\n+                self._display.warning('Ignoring timeout(%s) for %s' % (timeout, executed_module))\n \n             fact_filter = mod_args.pop('filter', None)\n             if fact_filter is not None:\n-                self._display.warning('Ignoring filter(%s) for %s' % (fact_filter, fact_module))\n+                self._display.warning('Ignoring filter(%s) for %s' % (fact_filter, executed_module))\n \n         # Strip out keys with ``None`` values, effectively mimicking ``omit`` behavior\n         # This ensures we don't pass a ``None`` value as an argument expecting a specific type\n         mod_args = dict((k, v) for k, v in mod_args.items() if v is not None)\n \n-        # handle module defaults\n-        mod_args = get_action_args_with_defaults(fact_module, mod_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list)\n+        # handle module defaults for the resolved module\n+        mod_args = get_action_args_with_defaults(\n+            executed_module, mod_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+        )\n \n         return mod_args\n \n@@ -62,8 +69,8 @@ class ActionModule(ActionBase):\n         result = super(ActionModule, self).run(tmp, task_vars)\n         result['ansible_facts'] = {}\n \n-        modules = C.config.get_config_value('FACTS_MODULES', variables=task_vars)\n-        parallel = task_vars.pop('ansible_facts_parallel', self._task.args.pop('parallel', None))\n+        modules = list(C.config.get_config_value('FACTS_MODULES', variables=task_vars))\n+        parallel = task_vars.get('ansible_facts_parallel', self._task.args.get('parallel', None))\n         if 'smart' in modules:\n             connection_map = C.config.get_config_value('CONNECTION_FACTS_MODULES', variables=task_vars)\n             network_os = self._task.args.get('network_os', task_vars.get('ansible_network_os', task_vars.get('ansible_facts', {}).get('network_os')))\n@@ -135,4 +142,4 @@ class ActionModule(ActionBase):\n         # hack to keep --verbose from showing all the setup module result\n         result['_ansible_verbose_override'] = True\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/package.py b/lib/ansible/plugins/action/package.py\nindex ecef676..7d005c8 100644\n--- a/lib/ansible/plugins/action/package.py\n+++ b/lib/ansible/plugins/action/package.py\n@@ -62,25 +62,26 @@ class ActionModule(ActionBase):\n                 module = facts.get('ansible_facts', {}).get('ansible_pkg_mgr', 'auto')\n \n             if module != 'auto':\n-                if not self._shared_loader_obj.module_loader.has_plugin(module):\n+                # Determine actual module name we will execute (respect builtin legacy aliasing)\n+                final_module = module\n+                if module in self.BUILTIN_PKG_MGR_MODULES:\n+                    final_module = 'ansible.legacy.' + module\n+\n+                if not self._shared_loader_obj.module_loader.has_plugin(final_module):\n                     raise AnsibleActionFail('Could not find a module for %s.' % module)\n                 else:\n-                    # run the 'package' module\n+                    # run the package module\n                     new_module_args = self._task.args.copy()\n                     if 'use' in new_module_args:\n                         del new_module_args['use']\n \n-                    # get defaults for specific module\n+                    # get defaults for the actually executed module\n                     new_module_args = get_action_args_with_defaults(\n-                        module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+                        final_module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n                     )\n \n-                    if module in self.BUILTIN_PKG_MGR_MODULES:\n-                        # prefix with ansible.legacy to eliminate external collisions while still allowing library/ override\n-                        module = 'ansible.legacy.' + module\n-\n-                    display.vvvv(\"Running %s\" % module)\n-                    result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n+                    display.vvvv(\"Running %s\" % final_module)\n+                    result.update(self._execute_module(module_name=final_module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n             else:\n                 raise AnsibleActionFail('Could not detect which package manager to use. Try gathering facts or setting the \"use\" option.')\n \n@@ -91,4 +92,4 @@ class ActionModule(ActionBase):\n                 # remove a temporary path we created\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/service.py b/lib/ansible/plugins/action/service.py\nindex 340c9bb..de84e01 100644\n--- a/lib/ansible/plugins/action/service.py\n+++ b/lib/ansible/plugins/action/service.py\n@@ -78,17 +78,18 @@ class ActionModule(ActionBase):\n                             del new_module_args[unused]\n                             self._display.warning('Ignoring \"%s\" as it is not used in \"%s\"' % (unused, module))\n \n-                # get defaults for specific module\n-                new_module_args = get_action_args_with_defaults(\n-                    module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                )\n-\n                 # collection prefix known internal modules to avoid collisions from collections search, while still allowing library/ overrides\n+                final_module = module\n                 if module in self.BUILTIN_SVC_MGR_MODULES:\n-                    module = 'ansible.legacy.' + module\n+                    final_module = 'ansible.legacy.' + module\n+\n+                # get defaults for the actually executed module\n+                new_module_args = get_action_args_with_defaults(\n+                    final_module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+                )\n \n-                self._display.vvvv(\"Running %s\" % module)\n-                result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n+                self._display.vvvv(\"Running %s\" % final_module)\n+                result.update(self._execute_module(module_name=final_module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n             else:\n                 raise AnsibleActionFail('Could not detect which service manager to use. Try gathering facts or setting the \"use\" option.')\n \n@@ -98,4 +99,4 @@ class ActionModule(ActionBase):\n             if not self._task.async_val:\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/lib/ansible/plugins/action/gather_facts.py b/lib/ansible/plugins/action/gather_facts.py\nindex 1b577e7..3277b89 100644\n--- a/lib/ansible/plugins/action/gather_facts.py\n+++ b/lib/ansible/plugins/action/gather_facts.py\n@@ -62,13 +62,16 @@ class ActionModule(ActionBase):\n         result = super(ActionModule, self).run(tmp, task_vars)\n         result['ansible_facts'] = {}\n \n-        modules = C.config.get_config_value('FACTS_MODULES', variables=task_vars)\n+        # work on a copy to avoid mutating the original configuration\n+        modules = list(C.config.get_config_value('FACTS_MODULES', variables=task_vars) or [])\n         parallel = task_vars.pop('ansible_facts_parallel', self._task.args.pop('parallel', None))\n         if 'smart' in modules:\n             connection_map = C.config.get_config_value('CONNECTION_FACTS_MODULES', variables=task_vars)\n             network_os = self._task.args.get('network_os', task_vars.get('ansible_network_os', task_vars.get('ansible_facts', {}).get('network_os')))\n-            modules.extend([connection_map.get(network_os or self._connection._load_name, 'ansible.legacy.setup')])\n-            modules.pop(modules.index('smart'))\n+            resolved_module = connection_map.get(network_os or self._connection._load_name, 'ansible.legacy.setup')\n+            # replace any 'smart' entries with the resolved facts module\n+            modules = [m for m in modules if m != 'smart']\n+            modules.append(resolved_module)\n \n         failed = {}\n         skipped = {}\n@@ -135,4 +138,4 @@ class ActionModule(ActionBase):\n         # hack to keep --verbose from showing all the setup module result\n         result['_ansible_verbose_override'] = True\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/package.py b/lib/ansible/plugins/action/package.py\nindex ecef676..a5650a4 100644\n--- a/lib/ansible/plugins/action/package.py\n+++ b/lib/ansible/plugins/action/package.py\n@@ -70,15 +70,15 @@ class ActionModule(ActionBase):\n                     if 'use' in new_module_args:\n                         del new_module_args['use']\n \n-                    # get defaults for specific module\n-                    new_module_args = get_action_args_with_defaults(\n-                        module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                    )\n-\n                     if module in self.BUILTIN_PKG_MGR_MODULES:\n                         # prefix with ansible.legacy to eliminate external collisions while still allowing library/ override\n                         module = 'ansible.legacy.' + module\n \n+                    # get defaults for the actually executed module (after any redirection/prefixing)\n+                    new_module_args = get_action_args_with_defaults(\n+                        module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+                    )\n+\n                     display.vvvv(\"Running %s\" % module)\n                     result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n             else:\n@@ -91,4 +91,4 @@ class ActionModule(ActionBase):\n                 # remove a temporary path we created\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\ndiff --git a/lib/ansible/plugins/action/service.py b/lib/ansible/plugins/action/service.py\nindex 340c9bb..418a18e 100644\n--- a/lib/ansible/plugins/action/service.py\n+++ b/lib/ansible/plugins/action/service.py\n@@ -78,15 +78,15 @@ class ActionModule(ActionBase):\n                             del new_module_args[unused]\n                             self._display.warning('Ignoring \"%s\" as it is not used in \"%s\"' % (unused, module))\n \n-                # get defaults for specific module\n-                new_module_args = get_action_args_with_defaults(\n-                    module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n-                )\n-\n                 # collection prefix known internal modules to avoid collisions from collections search, while still allowing library/ overrides\n                 if module in self.BUILTIN_SVC_MGR_MODULES:\n                     module = 'ansible.legacy.' + module\n \n+                # get defaults for the actually executed module (after any redirection/prefixing)\n+                new_module_args = get_action_args_with_defaults(\n+                    module, new_module_args, self._task.module_defaults, self._templar, self._task._ansible_internal_redirect_list\n+                )\n+\n                 self._display.vvvv(\"Running %s\" % module)\n                 result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))\n             else:\n@@ -98,4 +98,4 @@ class ActionModule(ActionBase):\n             if not self._task.async_val:\n                 self._remove_tmp_path(self._connection._shell.tmpdir)\n \n-        return result\n+        return result\n"
}