{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__b9f9961f",
    "original_id": "instance_ansible__ansible-949c503f2ef4b2c5d668af0492a5c0db1ab86140-v0f01c69f1e2528b935359cfe578530722bca2c59",
    "1_model_selected_files": [
        "lib/ansible/config/manager.py",
        "lib/ansible/utils/galaxy.py",
        "lib/ansible/cli/config.py",
        "lib/ansible/constants.py",
        "lib/ansible/utils/context_objects.py"
    ],
    "2_embedding_selected_files": [
        "lib/ansible/cli/config.py",
        "lib/ansible/cli/galaxy.py",
        "lib/ansible/plugins/lookup/config.py",
        "lib/ansible/galaxy/token.py",
        "lib/ansible/config/__init__.py",
        "lib/ansible/cli/arguments/option_helpers.py",
        "lib/ansible/config/manager.py",
        "lib/ansible/galaxy/__init__.py",
        "lib/ansible/plugins/doc_fragments/default_callback.py",
        "lib/ansible/utils/collection_loader/_collection_config.py",
        "lib/ansible/modules/add_host.py",
        "lib/ansible/utils/galaxy.py",
        "lib/ansible/modules/assemble.py",
        "lib/ansible/plugins/doc_fragments/shell_common.py",
        "lib/ansible/modules/debconf.py",
        "lib/ansible/modules/systemd.py",
        "lib/ansible/modules/include_vars.py",
        "lib/ansible/utils/plugin_docs.py",
        "lib/ansible/modules/systemd_service.py",
        "lib/ansible/galaxy/collection/galaxy_api_proxy.py",
        "lib/ansible/modules/apt.py",
        "lib/ansible/modules/gather_facts.py",
        "lib/ansible/galaxy/role.py",
        "lib/ansible/galaxy/api.py",
        "lib/ansible/cli/inventory.py",
        "lib/ansible/plugins/action/gather_facts.py",
        "lib/ansible/plugins/callback/default.py",
        "lib/ansible/plugins/connection/paramiko_ssh.py",
        "lib/ansible/plugins/action/async_status.py",
        "lib/ansible/modules/known_hosts.py",
        "lib/ansible/modules/async_status.py",
        "lib/ansible/modules/wait_for.py",
        "lib/ansible/errors/yaml_strings.py",
        "lib/ansible/modules/setup.py",
        "lib/ansible/cli/doc.py",
        "lib/ansible/modules/cron.py",
        "lib/ansible/galaxy/collection/__init__.py",
        "lib/ansible/plugins/doc_fragments/backup.py",
        "lib/ansible/modules/unarchive.py",
        "lib/ansible/plugins/doc_fragments/shell_windows.py",
        "lib/ansible/plugins/action/include_vars.py",
        "lib/ansible/plugins/callback/__init__.py",
        "lib/ansible/playbook/playbook_include.py",
        "lib/ansible/plugins/inventory/advanced_host_list.py",
        "lib/ansible/galaxy/dependency_resolution/resolvers.py",
        "lib/ansible/modules/import_tasks.py",
        "lib/ansible/modules/yum_repository.py",
        "lib/ansible/constants.py",
        "lib/ansible/modules/pause.py",
        "lib/ansible/executor/interpreter_discovery.py",
        "ansible/setup.py"
    ],
    "3_final_combined_files": [
        "lib/ansible/cli/config.py",
        "lib/ansible/config/manager.py",
        "lib/ansible/utils/galaxy.py",
        "lib/ansible/cli/galaxy.py",
        "lib/ansible/plugins/lookup/config.py"
    ],
    "4_related_elements": {
        "lib/ansible/cli/config.py": [
            "class: ConfigCLI\nfunction: yaml_dump\nfunction: yaml_short\nfunction: get_constants\nfunction: _ansible_env_vars\nfunction: _get_evar_list\nfunction: _get_ini_entries"
        ],
        "lib/ansible/config/manager.py": [
            "variable: Setting\nfunction: _get_entry\nfunction: ensure_type\nfunction: get_ini_config_value\nfunction: find_ini_config_file\nclass: ConfigManager"
        ],
        "lib/ansible/utils/galaxy.py": [
            ""
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "lib/ansible/cli/config.py": [
                    "function: ConfigCLI._list_entries_from_args\nfunction: ConfigCLI._get_global_configs\nfunction: ConfigCLI._render_settings\nfunction: ConfigCLI.execute_dump"
                ],
                "lib/ansible/config/manager.py": [
                    "function: ConfigManager.get_config_value_and_origin"
                ],
                "lib/ansible/utils/galaxy.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/cli/config.py b/lib/ansible/cli/config.py\nindex 68f5f25..b66bb59 100644\n--- a/lib/ansible/cli/config.py\n+++ b/lib/ansible/cli/config.py\n@@ -469,6 +469,9 @@ class ConfigCLI(CLI):\n                 entry = {}\n                 for key in config[setting]._fields:\n                     entry[key] = getattr(config[setting], key)\n+                # ensure default templates are applied consistently\n+                if entry.get('origin') == 'default':\n+                    entry['value'] = self.config.template_default(entry.get('value'), get_constants())\n \n             if not context.CLIARGS['only_changed'] or changed:\n                 entries.append(entry)\n@@ -477,9 +480,17 @@ class ConfigCLI(CLI):\n \n     def _get_global_configs(self):\n         config = self.config.get_configuration_definitions(ignore_private=True).copy()\n-        for setting in config.keys():\n-            v, o = C.config.get_config_value_and_origin(setting, cfile=self.config_file, variables=get_constants())\n-            config[setting] = Setting(setting, v, o, None)\n+        for setting in list(config.keys()):\n+            try:\n+                v, o = C.config.get_config_value_and_origin(setting, cfile=self.config_file, variables=get_constants())\n+                config[setting] = Setting(setting, v, o, None)\n+            except AnsibleError as e:\n+                # Flag missing required options instead of raising, so they are visible in dump output\n+                msg = to_native(e)\n+                if 'required configuration' in msg or 'No setting was provided for required configuration' in msg:\n+                    config[setting] = Setting(setting, None, 'REQUIRED', None)\n+                else:\n+                    raise\n \n         return self._render_settings(config)\n \n@@ -553,6 +564,51 @@ class ConfigCLI(CLI):\n \n         return output\n \n+    def _get_galaxy_server_configs(self):\n+        \"\"\"\n+        Build and return Galaxy server configuration entries similar to plugin configs.\n+        \"\"\"\n+        output = []\n+        # Attempt to retrieve dynamic Galaxy server configuration definitions\n+        try:\n+            servers = self.config.get_configuration_definitions('GALAXY_SERVERS')\n+        except Exception:\n+            servers = {}\n+\n+        if not isinstance(servers, dict):\n+            servers = {}\n+\n+        for server_name in sorted(servers.keys()):\n+            # Retrieve option definitions for each server\n+            defs = self.config.get_configuration_definitions('GALAXY_SERVERS', server_name)\n+            # Build Setting objects for each option\n+            config = {}\n+            for setting in sorted(defs.keys()):\n+                try:\n+                    v, o = C.config.get_config_value_and_origin(setting, cfile=self.config_file,\n+                                                                variables=get_constants(),\n+                                                                plugin_type='GALAXY_SERVERS',\n+                                                                plugin_name=server_name)\n+                    config[setting] = Setting(setting, v, o, None)\n+                except AnsibleError as e:\n+                    msg = to_native(e)\n+                    if 'required configuration' in msg or 'No setting was provided for required configuration' in msg:\n+                        config[setting] = Setting(setting, None, 'REQUIRED', None)\n+                    else:\n+                        raise\n+\n+            results = self._render_settings(config)\n+            if results:\n+                if context.CLIARGS['format'] == 'display':\n+                    # Avoid header for empty lists (respect only_changed)\n+                    finalname = server_name\n+                    output.append('\\n%s:\\n%s' % (finalname, '_' * len(finalname)))\n+                    output.extend(results)\n+                else:\n+                    output.append({server_name: results})\n+\n+        return output\n+\n     def execute_dump(self):\n         '''\n         Shows the current settings, merges ansible.cfg if specified\n@@ -560,9 +616,27 @@ class ConfigCLI(CLI):\n         if context.CLIARGS['type'] == 'base':\n             # deal with base\n             output = self._get_global_configs()\n+            # include Galaxy servers configuration\n+            galaxy_list = self._get_galaxy_server_configs()\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_list:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_list)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_list})\n         elif context.CLIARGS['type'] == 'all':\n             # deal with base\n             output = self._get_global_configs()\n+            # include Galaxy servers configuration\n+            galaxy_list = self._get_galaxy_server_configs()\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_list:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_list)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_list})\n             # deal with plugins\n             for ptype in C.CONFIGURABLE_PLUGINS:\n                 plugin_list = self._get_plugin_configs(ptype, context.CLIARGS['args'])\n",
                "diff --git a/lib/ansible/cli/config.py b/lib/ansible/cli/config.py\nindex 68f5f25..7a7818f 100644\n--- a/lib/ansible/cli/config.py\n+++ b/lib/ansible/cli/config.py\n@@ -560,6 +560,15 @@ class ConfigCLI(CLI):\n         if context.CLIARGS['type'] == 'base':\n             # deal with base\n             output = self._get_global_configs()\n+            # include Galaxy servers in base output\n+            galaxy_list = self._get_plugin_configs('galaxy', context.CLIARGS['args'])\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_list:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_list)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_list})\n         elif context.CLIARGS['type'] == 'all':\n             # deal with base\n             output = self._get_global_configs()\n@@ -568,11 +577,17 @@ class ConfigCLI(CLI):\n                 plugin_list = self._get_plugin_configs(ptype, context.CLIARGS['args'])\n                 if context.CLIARGS['format'] == 'display':\n                     if not context.CLIARGS['only_changed'] or plugin_list:\n-                        output.append('\\n%s:\\n%s' % (ptype.upper(), '=' * len(ptype)))\n+                        if ptype == 'galaxy':\n+                            header = 'GALAXY_SERVERS'\n+                            output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                        else:\n+                            output.append('\\n%s:\\n%s' % (ptype.upper(), '=' * len(ptype)))\n                         output.extend(plugin_list)\n                 else:\n                     if ptype in ('modules', 'doc_fragments'):\n                         pname = ptype.upper()\n+                    elif ptype == 'galaxy':\n+                        pname = 'GALAXY_SERVERS'\n                     else:\n                         pname = '%s_PLUGINS' % ptype.upper()\n                     output.append({pname: plugin_list})\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "lib/ansible/cli/config.py": [
                    "function: ConfigCLI.execute_dump\nfunction: ConfigCLI._get_galaxy_server_configs"
                ],
                "lib/ansible/config/manager.py": [
                    "function: ConfigManager.get_galaxy_server_configs"
                ],
                "lib/ansible/utils/galaxy.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/cli/config.py b/lib/ansible/cli/config.py\nindex 68f5f25..55c60b7 100644\n--- a/lib/ansible/cli/config.py\n+++ b/lib/ansible/cli/config.py\n@@ -553,6 +553,41 @@ class ConfigCLI(CLI):\n \n         return output\n \n+    def _get_galaxy_server_configs(self):\n+        '''\n+        Build the Galaxy servers configuration list, including each server and its resolved options.\n+        '''\n+        output = []\n+        # Resolve the server list from config\n+        try:\n+            server_list, _origin = C.config.get_config_value_and_origin('GALAXY_SERVER_LIST', cfile=self.config_file, variables=get_constants())\n+        except Exception:\n+            server_list = None\n+\n+        if not server_list:\n+            return output\n+\n+        for server_name in server_list:\n+            # Collect definitions for this server\n+            server_defs = self.config.get_configuration_definitions('galaxy_server', server_name).copy()\n+            server_config = {}\n+            for setting in server_defs.keys():\n+                v, o = C.config.get_config_value_and_origin(setting, cfile=self.config_file, variables=get_constants(),\n+                                                            plugin_type='galaxy_server', plugin_name=server_name)\n+                server_config[setting] = Setting(setting, v, o, None)\n+\n+            results = self._render_settings(server_config)\n+\n+            if results:\n+                if context.CLIARGS['format'] == 'display':\n+                    # Title per server\n+                    output.append('\\n%s:\\n%s' % (server_name, '_' * len(server_name)))\n+                    output.extend(results)\n+                else:\n+                    output.append({server_name: results})\n+\n+        return output\n+\n     def execute_dump(self):\n         '''\n         Shows the current settings, merges ansible.cfg if specified\n@@ -560,6 +595,15 @@ class ConfigCLI(CLI):\n         if context.CLIARGS['type'] == 'base':\n             # deal with base\n             output = self._get_global_configs()\n+            # include Galaxy servers\n+            galaxy_list = self._get_galaxy_server_configs()\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_list:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_list)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_list})\n         elif context.CLIARGS['type'] == 'all':\n             # deal with base\n             output = self._get_global_configs()\n@@ -576,6 +620,15 @@ class ConfigCLI(CLI):\n                     else:\n                         pname = '%s_PLUGINS' % ptype.upper()\n                     output.append({pname: plugin_list})\n+            # include Galaxy servers\n+            galaxy_list = self._get_galaxy_server_configs()\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_list:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_list)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_list})\n         else:\n             # deal with plugins\n             output = self._get_plugin_configs(context.CLIARGS['type'], context.CLIARGS['args'])\ndiff --git a/lib/ansible/config/manager.py b/lib/ansible/config/manager.py\nindex 8932f16..3b8c117 100644\n--- a/lib/ansible/config/manager.py\n+++ b/lib/ansible/config/manager.py\n@@ -561,23 +561,26 @@ class ConfigManager(object):\n             # set default if we got here w/o a value\n             if value is None:\n                 if defs[config].get('required', False):\n-                    if not plugin_type or config not in INTERNAL_DEFS.get(plugin_type, {}):\n-                        raise AnsibleError(\"No setting was provided for required configuration %s\" %\n-                                           to_native(_get_entry(plugin_type, plugin_name, config)))\n+                    # Mark as REQUIRED instead of raising so ansible-config dump can display missing required options\n+                    origin = 'REQUIRED'\n+                    value = None\n                 else:\n                     origin = 'default'\n                     value = self.template_default(defs[config].get('default'), variables)\n-            try:\n-                # ensure correct type, can raise exceptions on mismatched types\n-                value = ensure_type(value, defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)\n-            except ValueError as e:\n-                if origin.startswith('env:') and value == '':\n-                    # this is empty env var for non string so we can set to default\n-                    origin = 'default'\n-                    value = ensure_type(defs[config].get('default'), defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)\n-                else:\n-                    raise AnsibleOptionsError('Invalid type for configuration option %s (from %s): %s' %\n-                                              (to_native(_get_entry(plugin_type, plugin_name, config)).strip(), origin, to_native(e)))\n+            # Only attempt type coercion when a concrete value is present and not a REQUIRED placeholder\n+            if origin != 'REQUIRED':\n+                try:\n+                    # ensure correct type, can raise exceptions on mismatched types\n+                    value = ensure_type(value, defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)\n+                except ValueError as e:\n+                    if origin.startswith('env:') and value == '':\n+                        # this is empty env var for non string so we can set to default (resolve templated defaults properly)\n+                        origin = 'default'\n+                        templated_default = self.template_default(defs[config].get('default'), variables)\n+                        value = ensure_type(templated_default, defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)\n+                    else:\n+                        raise AnsibleOptionsError('Invalid type for configuration option %s (from %s): %s' %\n+                                                  (to_native(_get_entry(plugin_type, plugin_name, config)).strip(), origin, to_native(e)))\n \n             # deal with restricted values\n             if value is not None and 'choices' in defs[config] and defs[config]['choices'] is not None:\n@@ -616,4 +619,4 @@ class ConfigManager(object):\n         if plugin_type not in self._plugins:\n             self._plugins[plugin_type] = {}\n \n-        self._plugins[plugin_type][name] = defs\n+        self._plugins[plugin_type][name] = defs\n",
                "diff --git a/lib/ansible/cli/config.py b/lib/ansible/cli/config.py\nindex 68f5f25..46a575f 100644\n--- a/lib/ansible/cli/config.py\n+++ b/lib/ansible/cli/config.py\n@@ -557,9 +557,104 @@ class ConfigCLI(CLI):\n         '''\n         Shows the current settings, merges ansible.cfg if specified\n         '''\n+        import configparser\n+\n+        def _collect_galaxy_servers():\n+            servers_display = []\n+            servers_structured = []\n+            cfg_path = C.CONFIG_FILE\n+\n+            cp = configparser.ConfigParser()\n+            if cfg_path:\n+                try:\n+                    cp.read(cfg_path)\n+                except Exception:\n+                    pass\n+\n+            server_list = ''\n+            if cp.has_section('galaxy'):\n+                try:\n+                    server_list = cp.get('galaxy', 'server_list', fallback=server_list)\n+                except Exception:\n+                    server_list = server_list\n+\n+            names = []\n+            for raw in server_list.split(','):\n+                nm = raw.strip()\n+                if nm:\n+                    names.append(nm)\n+\n+            # Determine fallback timeout from [galaxy] or GALAXY_SERVER_TIMEOUT\n+            fallback_timeout = None\n+            if cp.has_section('galaxy'):\n+                for key in ('server_timeout', 'timeout'):\n+                    if cp.has_option('galaxy', key):\n+                        try:\n+                            fallback_timeout = int(cp.get('galaxy', key))\n+                        except Exception:\n+                            # keep as-is if not integer\n+                            fallback_timeout = cp.get('galaxy', key)\n+                        break\n+            if fallback_timeout is None:\n+                fallback_timeout = getattr(C, 'GALAXY_SERVER_TIMEOUT', None)\n+\n+            origin_config = cfg_path if cfg_path else 'default'\n+\n+            for name in names:\n+                section = 'galaxy_server.%s' % name\n+                server_opts = {}\n+                origins = {}\n+\n+                if cp.has_section(section):\n+                    if cp.has_option(section, 'url'):\n+                        server_opts['url'] = cp.get(section, 'url')\n+                        origins['url'] = origin_config\n+                    else:\n+                        server_opts['url'] = 'REQUIRED'\n+                        origins['url'] = 'missing'\n+\n+                    for opt in ('token', 'username', 'password', 'auth_url', 'validate_certs', 'ssl_verify', 'timeout'):\n+                        if cp.has_option(section, opt):\n+                            server_opts[opt] = cp.get(section, opt)\n+                            origins[opt] = origin_config\n+                else:\n+                    # Missing server section, flag required URL\n+                    server_opts['url'] = 'REQUIRED'\n+                    origins['url'] = 'missing'\n+\n+                # Apply timeout fallback if not explicitly configured\n+                if 'timeout' not in server_opts or server_opts['timeout'] in ('', None):\n+                    if fallback_timeout is not None:\n+                        server_opts['timeout'] = fallback_timeout\n+                        origins['timeout'] = 'default(GALAXY_SERVER_TIMEOUT)'\n+\n+                # Build display output\n+                for opt_key, opt_val in server_opts.items():\n+                    origin_label = origins.get(opt_key, 'default')\n+                    servers_display.append('%s.%s = %s (%s)' % (name, opt_key, opt_val, origin_label))\n+\n+                # Build structured output with origins\n+                servers_structured.append({\n+                    'name': name,\n+                    'options': {k: {'value': v, 'origin': origins.get(k, 'default')} for k, v in server_opts.items()}\n+                })\n+\n+            return servers_display, servers_structured\n+\n         if context.CLIARGS['type'] == 'base':\n             # deal with base\n             output = self._get_global_configs()\n+\n+            # include Galaxy servers\n+            galaxy_display, galaxy_structured = _collect_galaxy_servers()\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_display:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_display)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_structured})\n+\n         elif context.CLIARGS['type'] == 'all':\n             # deal with base\n             output = self._get_global_configs()\n@@ -576,6 +671,17 @@ class ConfigCLI(CLI):\n                     else:\n                         pname = '%s_PLUGINS' % ptype.upper()\n                     output.append({pname: plugin_list})\n+\n+            # include Galaxy servers\n+            galaxy_display, galaxy_structured = _collect_galaxy_servers()\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_display:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_display)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_structured})\n+\n         else:\n             # deal with plugins\n             output = self._get_plugin_configs(context.CLIARGS['type'], context.CLIARGS['args'])\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/lib/ansible/cli/config.py b/lib/ansible/cli/config.py\nindex 68f5f25..b66bb59 100644\n--- a/lib/ansible/cli/config.py\n+++ b/lib/ansible/cli/config.py\n@@ -469,6 +469,9 @@ class ConfigCLI(CLI):\n                 entry = {}\n                 for key in config[setting]._fields:\n                     entry[key] = getattr(config[setting], key)\n+                # ensure default templates are applied consistently\n+                if entry.get('origin') == 'default':\n+                    entry['value'] = self.config.template_default(entry.get('value'), get_constants())\n \n             if not context.CLIARGS['only_changed'] or changed:\n                 entries.append(entry)\n@@ -477,9 +480,17 @@ class ConfigCLI(CLI):\n \n     def _get_global_configs(self):\n         config = self.config.get_configuration_definitions(ignore_private=True).copy()\n-        for setting in config.keys():\n-            v, o = C.config.get_config_value_and_origin(setting, cfile=self.config_file, variables=get_constants())\n-            config[setting] = Setting(setting, v, o, None)\n+        for setting in list(config.keys()):\n+            try:\n+                v, o = C.config.get_config_value_and_origin(setting, cfile=self.config_file, variables=get_constants())\n+                config[setting] = Setting(setting, v, o, None)\n+            except AnsibleError as e:\n+                # Flag missing required options instead of raising, so they are visible in dump output\n+                msg = to_native(e)\n+                if 'required configuration' in msg or 'No setting was provided for required configuration' in msg:\n+                    config[setting] = Setting(setting, None, 'REQUIRED', None)\n+                else:\n+                    raise\n \n         return self._render_settings(config)\n \n@@ -553,6 +564,51 @@ class ConfigCLI(CLI):\n \n         return output\n \n+    def _get_galaxy_server_configs(self):\n+        \"\"\"\n+        Build and return Galaxy server configuration entries similar to plugin configs.\n+        \"\"\"\n+        output = []\n+        # Attempt to retrieve dynamic Galaxy server configuration definitions\n+        try:\n+            servers = self.config.get_configuration_definitions('GALAXY_SERVERS')\n+        except Exception:\n+            servers = {}\n+\n+        if not isinstance(servers, dict):\n+            servers = {}\n+\n+        for server_name in sorted(servers.keys()):\n+            # Retrieve option definitions for each server\n+            defs = self.config.get_configuration_definitions('GALAXY_SERVERS', server_name)\n+            # Build Setting objects for each option\n+            config = {}\n+            for setting in sorted(defs.keys()):\n+                try:\n+                    v, o = C.config.get_config_value_and_origin(setting, cfile=self.config_file,\n+                                                                variables=get_constants(),\n+                                                                plugin_type='GALAXY_SERVERS',\n+                                                                plugin_name=server_name)\n+                    config[setting] = Setting(setting, v, o, None)\n+                except AnsibleError as e:\n+                    msg = to_native(e)\n+                    if 'required configuration' in msg or 'No setting was provided for required configuration' in msg:\n+                        config[setting] = Setting(setting, None, 'REQUIRED', None)\n+                    else:\n+                        raise\n+\n+            results = self._render_settings(config)\n+            if results:\n+                if context.CLIARGS['format'] == 'display':\n+                    # Avoid header for empty lists (respect only_changed)\n+                    finalname = server_name\n+                    output.append('\\n%s:\\n%s' % (finalname, '_' * len(finalname)))\n+                    output.extend(results)\n+                else:\n+                    output.append({server_name: results})\n+\n+        return output\n+\n     def execute_dump(self):\n         '''\n         Shows the current settings, merges ansible.cfg if specified\n@@ -560,9 +616,27 @@ class ConfigCLI(CLI):\n         if context.CLIARGS['type'] == 'base':\n             # deal with base\n             output = self._get_global_configs()\n+            # include Galaxy servers configuration\n+            galaxy_list = self._get_galaxy_server_configs()\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_list:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_list)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_list})\n         elif context.CLIARGS['type'] == 'all':\n             # deal with base\n             output = self._get_global_configs()\n+            # include Galaxy servers configuration\n+            galaxy_list = self._get_galaxy_server_configs()\n+            if context.CLIARGS['format'] == 'display':\n+                if not context.CLIARGS['only_changed'] or galaxy_list:\n+                    header = 'GALAXY_SERVERS'\n+                    output.append('\\n%s:\\n%s' % (header, '=' * len(header)))\n+                    output.extend(galaxy_list)\n+            else:\n+                output.append({'GALAXY_SERVERS': galaxy_list})\n             # deal with plugins\n             for ptype in C.CONFIGURABLE_PLUGINS:\n                 plugin_list = self._get_plugin_configs(ptype, context.CLIARGS['args'])\n"
}