{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__5b2cf9bb",
    "original_id": "instance_ansible__ansible-d58e69c82d7edd0583dd8e78d76b075c33c3151e-v173091e2e36d38c978002990795f66cfc0af30ad",
    "1_model_selected_files": [
        "lib/ansible/module_utils/urls.py",
        "lib/ansible/modules/uri.py",
        "lib/ansible/modules/get_url.py",
        "lib/ansible/plugins/action/uri.py"
    ],
    "2_embedding_selected_files": [
        "lib/ansible/modules/uri.py",
        "lib/ansible/modules/unarchive.py",
        "lib/ansible/plugins/action/uri.py",
        "lib/ansible/module_utils/urls.py",
        "lib/ansible/modules/get_url.py",
        "lib/ansible/plugins/lookup/url.py",
        "lib/ansible/plugins/action/unarchive.py",
        "lib/ansible/executor/module_common.py",
        "lib/ansible/modules/slurp.py",
        "lib/ansible/parsing/utils/jsonify.py",
        "lib/ansible/plugins/filter/urls.py",
        "lib/ansible/plugins/filter/encryption.py",
        "lib/ansible/plugins/doc_fragments/url_windows.py",
        "lib/ansible/plugins/doc_fragments/url.py",
        "lib/ansible/module_utils/common/json.py",
        "lib/ansible/plugins/filter/urlsplit.py",
        "lib/ansible/module_utils/common/_json_compat.py",
        "lib/ansible/utils/py3compat.py",
        "lib/ansible/modules/async_status.py",
        "lib/ansible/modules/async_wrapper.py",
        "lib/ansible/modules/git.py",
        "lib/ansible/modules/apt_key.py",
        "lib/ansible/vars/clean.py",
        "lib/ansible/plugins/lookup/unvault.py",
        "lib/ansible/module_utils/connection.py",
        "lib/ansible/modules/yum.py",
        "lib/ansible/plugins/action/raw.py",
        "lib/ansible/module_utils/ansible_release.py",
        "lib/ansible/module_utils/_text.py",
        "lib/ansible/plugins/action/async_status.py",
        "lib/ansible/plugins/action/fetch.py",
        "lib/ansible/module_utils/compat/__init__.py",
        "lib/ansible/module_utils/common/text/converters.py",
        "lib/ansible/modules/expect.py",
        "lib/ansible/modules/pip.py",
        "lib/ansible/modules/raw.py",
        "lib/ansible/module_utils/facts/compat.py",
        "lib/ansible/plugins/doc_fragments/decrypt.py",
        "lib/ansible/parsing/ajson.py"
    ],
    "3_final_combined_files": [
        "lib/ansible/modules/uri.py",
        "lib/ansible/module_utils/urls.py",
        "lib/ansible/modules/get_url.py",
        "lib/ansible/modules/unarchive.py",
        "lib/ansible/plugins/action/uri.py"
    ],
    "4_related_elements": {
        "lib/ansible/module_utils/urls.py": [
            "class: Request\nfunction: open_url\nfunction: fetch_url\nfunction: fetch_file\nfunction: url_argument_spec"
        ],
        "lib/ansible/modules/uri.py": [
            "function: uri\nfunction: write_file"
        ],
        "lib/ansible/modules/get_url.py": [
            "function: url_get"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "lib/ansible/module_utils/urls.py": [
                    "function: Request.open\nfunction: fetch_url"
                ],
                "lib/ansible/modules/uri.py": [
                    ""
                ],
                "lib/ansible/modules/get_url.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/module_utils/urls.py b/lib/ansible/module_utils/urls.py\nindex 23a006b..a85ed8e 100644\n--- a/lib/ansible/module_utils/urls.py\n+++ b/lib/ansible/module_utils/urls.py\n@@ -1326,6 +1326,10 @@ class Request:\n         elif not isinstance(headers, dict):\n             raise ValueError(\"headers must be a dict\")\n         headers = dict(self.headers, **headers)\n+        # Ensure we advertise support for compressed responses\n+        # to avoid servers returning 406 or forcing gzip unexpectedly\n+        if 'accept-encoding' not in set([h.lower() for h in headers.keys()]):\n+            headers['Accept-Encoding'] = 'gzip,deflate'\n \n         use_proxy = self._fallback(use_proxy, self.use_proxy)\n         force = self._fallback(force, self.force)\n@@ -1793,6 +1797,55 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n     if not isinstance(cookies, cookiejar.CookieJar):\n         cookies = cookiejar.LWPCookieJar()\n \n+    # Internal wrapper to present a file-like response with decompressed content\n+    class _BufferedResponse(object):\n+        def __init__(self, original, content):\n+            self._orig = original\n+            self._content = content\n+            # Common attributes used by callers\n+            self.code = getattr(original, 'code', getattr(original, 'status', None))\n+            # Copy headers if possible and adjust to reflect decompressed payload\n+            try:\n+                # headers may be an email.message.Message or dict-like\n+                if hasattr(original.headers, 'copy'):\n+                    self.headers = original.headers.copy()\n+                else:\n+                    self.headers = original.headers\n+                # Remove content-encoding and update content-length\n+                try:\n+                    # email.message.Message in py3\n+                    if hasattr(self.headers, 'remove_header'):\n+                        self.headers.remove_header('Content-Encoding')\n+                        self.headers['Content-Length'] = str(len(content))\n+                    else:\n+                        self.headers.pop('Content-Encoding', None)\n+                        self.headers.pop('content-encoding', None)\n+                        self.headers['Content-Length'] = str(len(content))\n+                except Exception:\n+                    pass\n+            except Exception:\n+                self.headers = getattr(original, 'headers', {})\n+            def _safe_close(obj):\n+                try:\n+                    obj.close()\n+                except Exception:\n+                    pass\n+            self._safe_close = _safe_close\n+        def read(self, amt=None):\n+            if amt is None:\n+                return self._content\n+            else:\n+                data = self._content[:amt]\n+                self._content = self._content[amt:]\n+                return data\n+        def info(self):\n+            # Return original info to preserve behavior\n+            return self._orig.info()\n+        def geturl(self):\n+            return self._orig.geturl()\n+        def close(self):\n+            self._safe_close(self._orig)\n+\n     r = None\n     info = dict(url=url, status=-1)\n     try:\n@@ -1803,6 +1856,35 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n                      follow_redirects=follow_redirects, client_cert=client_cert,\n                      client_key=client_key, cookies=cookies, use_gssapi=use_gssapi,\n                      unix_socket=unix_socket, ca_path=ca_path, unredirected_headers=unredirected_headers)\n+\n+        # Transparently decompress gzip/deflate encoded responses\n+        try:\n+            enc = r.headers.get('Content-Encoding') or r.headers.get('content-encoding')\n+        except Exception:\n+            enc = None\n+        if enc:\n+            enc_l = enc.lower()\n+            if enc_l in ('gzip', 'x-gzip'):\n+                try:\n+                    import io\n+                    import gzip\n+                    raw = r.read()\n+                    decompressed = gzip.GzipFile(fileobj=io.BytesIO(raw)).read()\n+                    r = _BufferedResponse(r, decompressed)\n+                except Exception:\n+                    pass\n+            elif enc_l in ('deflate', 'x-deflate'):\n+                try:\n+                    import zlib\n+                    raw = r.read()\n+                    try:\n+                        decompressed = zlib.decompress(raw)\n+                    except zlib.error:\n+                        decompressed = zlib.decompress(raw, -zlib.MAX_WBITS)\n+                    r = _BufferedResponse(r, decompressed)\n+                except Exception:\n+                    pass\n+\n         # Lowercase keys, to conform to py2 behavior, so that py3 and py2 are predictable\n         info.update(dict((k.lower(), v) for k, v in r.info().items()))\n \n@@ -1852,6 +1934,29 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n                 # tempfile, due to ``urllib.response.addinfourl`` not being initialized\n                 raise AttributeError\n             body = e.read()\n+            # Transparently decompress error bodies if they are encoded\n+            try:\n+                enc_hdr = e.info().get('Content-Encoding') or e.info().get('content-encoding')\n+            except Exception:\n+                enc_hdr = None\n+            if enc_hdr:\n+                enc_l = to_native(enc_hdr).lower()\n+                if enc_l in ('gzip', 'x-gzip'):\n+                    try:\n+                        import io\n+                        import gzip\n+                        body = gzip.GzipFile(fileobj=io.BytesIO(body)).read()\n+                    except Exception:\n+                        pass\n+                elif enc_l in ('deflate', 'x-deflate'):\n+                    try:\n+                        import zlib\n+                        try:\n+                            body = zlib.decompress(body)\n+                        except zlib.error:\n+                            body = zlib.decompress(body, -zlib.MAX_WBITS)\n+                    except Exception:\n+                        pass\n         except AttributeError:\n             body = ''\n         else:\n",
                "diff --git a/lib/ansible/module_utils/urls.py b/lib/ansible/module_utils/urls.py\nindex 23a006b..3cc47c5 100644\n--- a/lib/ansible/module_utils/urls.py\n+++ b/lib/ansible/module_utils/urls.py\n@@ -1476,6 +1476,9 @@ class Request:\n             request.add_header('If-Modified-Since', tstamp)\n \n         # user defined headers now, which may override things we've set above\n+        # Ensure we accept gzip-encoded responses, so we can transparently decode them later\n+        if not any(h.lower() == 'accept-encoding' for h in headers):\n+            headers['Accept-Encoding'] = 'gzip'\n         unredirected_headers = [h.lower() for h in (unredirected_headers or [])]\n         for header in headers:\n             if header.lower() in unredirected_headers:\n@@ -1819,6 +1822,39 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n                     temp_headers[name] = value\n             info.update(temp_headers)\n \n+        # Transparently decode gzip-encoded responses\n+        content_encoding = info.get('content-encoding', '').lower()\n+        if content_encoding == 'gzip':\n+            try:\n+                import gzip\n+                class GzipDecodedResponse(object):\n+                    def __init__(self, resp):\n+                        self._resp = resp\n+                        self._gz = gzip.GzipFile(fileobj=resp)\n+                        # propagate commonly used attributes\n+                        self.headers = getattr(resp, 'headers', {})\n+                        self.code = getattr(resp, 'code', getattr(resp, 'status', None))\n+                    def read(self, amt=None):\n+                        if amt is None:\n+                            return self._gz.read()\n+                        return self._gz.read(amt)\n+                    def close(self):\n+                        try:\n+                            self._gz.close()\n+                        finally:\n+                            try:\n+                                self._resp.close()\n+                            except Exception:\n+                                pass\n+                    def info(self):\n+                        return self._resp.info()\n+                    def geturl(self):\n+                        return self._resp.geturl()\n+                r = GzipDecodedResponse(r)\n+            except Exception:\n+                # If any error occurs during decompression, fall back to original response\n+                pass\n+\n         # parse the cookies into a nice dictionary\n         cookie_list = []\n         cookie_dict = dict()\n@@ -1852,6 +1888,26 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n                 # tempfile, due to ``urllib.response.addinfourl`` not being initialized\n                 raise AttributeError\n             body = e.read()\n+            # Attempt to transparently decompress gzip-encoded error responses\n+            enc = ''\n+            try:\n+                enc = e.headers.get('Content-Encoding', '')\n+            except Exception:\n+                try:\n+                    enc = e.info().get('Content-Encoding', '')\n+                except Exception:\n+                    enc = ''\n+            if isinstance(enc, bytes):\n+                try:\n+                    enc = enc.decode('latin-1')\n+                except Exception:\n+                    pass\n+            if enc and enc.lower() == 'gzip':\n+                try:\n+                    import gzip, io\n+                    body = gzip.GzipFile(fileobj=io.BytesIO(body)).read()\n+                except Exception:\n+                    pass\n         except AttributeError:\n             body = ''\n         else:\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "lib/ansible/module_utils/urls.py": [
                    "function: Request.open\nfunction: fetch_url"
                ],
                "lib/ansible/modules/uri.py": [
                    ""
                ],
                "lib/ansible/modules/get_url.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/module_utils/urls.py b/lib/ansible/module_utils/urls.py\nindex 23a006b..ee4eb9b 100644\n--- a/lib/ansible/module_utils/urls.py\n+++ b/lib/ansible/module_utils/urls.py\n@@ -1327,6 +1327,11 @@ class Request:\n             raise ValueError(\"headers must be a dict\")\n         headers = dict(self.headers, **headers)\n \n+        # Ensure we advertise support for compressed responses so servers\n+        # that rely on gzip/deflate do not reject the request or return opaque payloads\n+        if not any(h.lower() == 'accept-encoding' for h in headers):\n+            headers['Accept-Encoding'] = 'gzip, deflate'\n+\n         use_proxy = self._fallback(use_proxy, self.use_proxy)\n         force = self._fallback(force, self.force)\n         timeout = self._fallback(timeout, self.timeout)\n@@ -1819,6 +1824,48 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n                     temp_headers[name] = value\n             info.update(temp_headers)\n \n+        # Transparently decode gzip-encoded responses\n+        try:\n+            enc = info.get('content-encoding', None)\n+            if not enc:\n+                enc = r.info().get('Content-Encoding')\n+        except Exception:\n+            enc = None\n+        if enc:\n+            try:\n+                enc_val = enc.lower()\n+            except Exception:\n+                enc_val = str(enc).lower()\n+            if 'gzip' in enc_val:\n+                import gzip\n+                class _GzipDecodedResponse(object):\n+                    def __init__(self, response):\n+                        self._response = response\n+                        self._gzip = gzip.GzipFile(fileobj=response)\n+                        self.code = getattr(response, 'code', None)\n+                        self.headers = response.headers\n+\n+                    def info(self):\n+                        return self._response.info()\n+\n+                    def geturl(self):\n+                        return self._response.geturl()\n+\n+                    def read(self, amt=None):\n+                        if amt is None:\n+                            return self._gzip.read()\n+                        return self._gzip.read(amt)\n+\n+                    def close(self):\n+                        try:\n+                            self._gzip.close()\n+                        finally:\n+                            try:\n+                                self._response.close()\n+                            except Exception:\n+                                pass\n+                r = _GzipDecodedResponse(r)\n+\n         # parse the cookies into a nice dictionary\n         cookie_list = []\n         cookie_dict = dict()\n@@ -1855,6 +1902,19 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n         except AttributeError:\n             body = ''\n         else:\n+            # Transparently decode gzip-compressed error bodies\n+            try:\n+                enc = e.info().get('Content-Encoding')\n+            except Exception:\n+                enc = None\n+            if enc and 'gzip' in str(enc).lower():\n+                import gzip\n+                import io\n+                try:\n+                    body = gzip.GzipFile(fileobj=io.BytesIO(body)).read()\n+                except Exception:\n+                    # If decompression fails, fall back to original body\n+                    pass\n             e.close()\n \n         # Try to add exception info to the output but don't fail if we can't\n",
                "diff --git a/lib/ansible/module_utils/urls.py b/lib/ansible/module_utils/urls.py\nindex 23a006b..ee3300c 100644\n--- a/lib/ansible/module_utils/urls.py\n+++ b/lib/ansible/module_utils/urls.py\n@@ -1327,6 +1327,10 @@ class Request:\n             raise ValueError(\"headers must be a dict\")\n         headers = dict(self.headers, **headers)\n \n+        # Ensure we accept compressed responses and can handle them transparently\n+        if 'Accept-Encoding' not in headers:\n+            headers['Accept-Encoding'] = 'gzip, deflate'\n+\n         use_proxy = self._fallback(use_proxy, self.use_proxy)\n         force = self._fallback(force, self.force)\n         timeout = self._fallback(timeout, self.timeout)\n@@ -1803,6 +1807,55 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n                      follow_redirects=follow_redirects, client_cert=client_cert,\n                      client_key=client_key, cookies=cookies, use_gssapi=use_gssapi,\n                      unix_socket=unix_socket, ca_path=ca_path, unredirected_headers=unredirected_headers)\n+\n+        # Transparent decompression support for gzip/deflate responses\n+        try:\n+            enc = r.headers.get('Content-Encoding', '')\n+        except Exception:\n+            enc = ''\n+        enc_l = enc.lower().strip()\n+        if enc_l in ('gzip', 'deflate'):\n+            # Import locally to avoid changing module-level imports\n+            import gzip\n+            import zlib\n+\n+            class _DecodingHTTPResponse(object):\n+                def __init__(self, response, encoding):\n+                    self._r = response\n+                    self._encoding = encoding\n+                    # Commonly used attributes\n+                    self.headers = response.headers\n+                    self.code = getattr(response, 'code', getattr(response, 'status', None))\n+                def read(self, amt=None):\n+                    # Normalize amt handling for unspecified size\n+                    size = -1 if amt in (None, -1) else amt\n+                    if self._encoding == 'gzip':\n+                        if not hasattr(self, '_gz'):\n+                            self._gz = gzip.GzipFile(fileobj=self._r)\n+                        return self._gz.read() if size == -1 else self._gz.read(size)\n+                    elif self._encoding == 'deflate':\n+                        data = self._r.read(size)\n+                        if not data:\n+                            return data\n+                        try:\n+                            return zlib.decompress(data)\n+                        except zlib.error:\n+                            # Some servers use raw deflate without zlib headers\n+                            return zlib.decompress(data, -zlib.MAX_WBITS)\n+                    else:\n+                        return self._r.read(size)\n+                def close(self):\n+                    try:\n+                        self._r.close()\n+                    except Exception:\n+                        pass\n+                def info(self):\n+                    return self._r.info()\n+                def geturl(self):\n+                    return self._r.geturl()\n+\n+            r = _DecodingHTTPResponse(r, enc_l)\n+\n         # Lowercase keys, to conform to py2 behavior, so that py3 and py2 are predictable\n         info.update(dict((k.lower(), v) for k, v in r.info().items()))\n \n@@ -1857,6 +1910,28 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n         else:\n             e.close()\n \n+        # If the server returned a compressed error body, decompress it\n+        try:\n+            enc = e.info().get('Content-Encoding', '')\n+        except Exception:\n+            enc = ''\n+        enc_l = enc.lower().strip()\n+        if body and enc_l:\n+            try:\n+                if enc_l == 'gzip':\n+                    import gzip\n+                    import io\n+                    body = gzip.GzipFile(fileobj=io.BytesIO(body)).read()\n+                elif enc_l == 'deflate':\n+                    import zlib\n+                    try:\n+                        body = zlib.decompress(body)\n+                    except zlib.error:\n+                        body = zlib.decompress(body, -zlib.MAX_WBITS)\n+            except Exception:\n+                # Fall back to original body if decompression fails\n+                pass\n+\n         # Try to add exception info to the output but don't fail if we can't\n         try:\n             # Lowercase keys, to conform to py2 behavior, so that py3 and py2 are predictable\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/lib/ansible/module_utils/urls.py b/lib/ansible/module_utils/urls.py\nindex 23a006b..a85ed8e 100644\n--- a/lib/ansible/module_utils/urls.py\n+++ b/lib/ansible/module_utils/urls.py\n@@ -1326,6 +1326,10 @@ class Request:\n         elif not isinstance(headers, dict):\n             raise ValueError(\"headers must be a dict\")\n         headers = dict(self.headers, **headers)\n+        # Ensure we advertise support for compressed responses\n+        # to avoid servers returning 406 or forcing gzip unexpectedly\n+        if 'accept-encoding' not in set([h.lower() for h in headers.keys()]):\n+            headers['Accept-Encoding'] = 'gzip,deflate'\n \n         use_proxy = self._fallback(use_proxy, self.use_proxy)\n         force = self._fallback(force, self.force)\n@@ -1793,6 +1797,55 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n     if not isinstance(cookies, cookiejar.CookieJar):\n         cookies = cookiejar.LWPCookieJar()\n \n+    # Internal wrapper to present a file-like response with decompressed content\n+    class _BufferedResponse(object):\n+        def __init__(self, original, content):\n+            self._orig = original\n+            self._content = content\n+            # Common attributes used by callers\n+            self.code = getattr(original, 'code', getattr(original, 'status', None))\n+            # Copy headers if possible and adjust to reflect decompressed payload\n+            try:\n+                # headers may be an email.message.Message or dict-like\n+                if hasattr(original.headers, 'copy'):\n+                    self.headers = original.headers.copy()\n+                else:\n+                    self.headers = original.headers\n+                # Remove content-encoding and update content-length\n+                try:\n+                    # email.message.Message in py3\n+                    if hasattr(self.headers, 'remove_header'):\n+                        self.headers.remove_header('Content-Encoding')\n+                        self.headers['Content-Length'] = str(len(content))\n+                    else:\n+                        self.headers.pop('Content-Encoding', None)\n+                        self.headers.pop('content-encoding', None)\n+                        self.headers['Content-Length'] = str(len(content))\n+                except Exception:\n+                    pass\n+            except Exception:\n+                self.headers = getattr(original, 'headers', {})\n+            def _safe_close(obj):\n+                try:\n+                    obj.close()\n+                except Exception:\n+                    pass\n+            self._safe_close = _safe_close\n+        def read(self, amt=None):\n+            if amt is None:\n+                return self._content\n+            else:\n+                data = self._content[:amt]\n+                self._content = self._content[amt:]\n+                return data\n+        def info(self):\n+            # Return original info to preserve behavior\n+            return self._orig.info()\n+        def geturl(self):\n+            return self._orig.geturl()\n+        def close(self):\n+            self._safe_close(self._orig)\n+\n     r = None\n     info = dict(url=url, status=-1)\n     try:\n@@ -1803,6 +1856,35 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n                      follow_redirects=follow_redirects, client_cert=client_cert,\n                      client_key=client_key, cookies=cookies, use_gssapi=use_gssapi,\n                      unix_socket=unix_socket, ca_path=ca_path, unredirected_headers=unredirected_headers)\n+\n+        # Transparently decompress gzip/deflate encoded responses\n+        try:\n+            enc = r.headers.get('Content-Encoding') or r.headers.get('content-encoding')\n+        except Exception:\n+            enc = None\n+        if enc:\n+            enc_l = enc.lower()\n+            if enc_l in ('gzip', 'x-gzip'):\n+                try:\n+                    import io\n+                    import gzip\n+                    raw = r.read()\n+                    decompressed = gzip.GzipFile(fileobj=io.BytesIO(raw)).read()\n+                    r = _BufferedResponse(r, decompressed)\n+                except Exception:\n+                    pass\n+            elif enc_l in ('deflate', 'x-deflate'):\n+                try:\n+                    import zlib\n+                    raw = r.read()\n+                    try:\n+                        decompressed = zlib.decompress(raw)\n+                    except zlib.error:\n+                        decompressed = zlib.decompress(raw, -zlib.MAX_WBITS)\n+                    r = _BufferedResponse(r, decompressed)\n+                except Exception:\n+                    pass\n+\n         # Lowercase keys, to conform to py2 behavior, so that py3 and py2 are predictable\n         info.update(dict((k.lower(), v) for k, v in r.info().items()))\n \n@@ -1852,6 +1934,29 @@ def fetch_url(module, url, data=None, headers=None, method=None,\n                 # tempfile, due to ``urllib.response.addinfourl`` not being initialized\n                 raise AttributeError\n             body = e.read()\n+            # Transparently decompress error bodies if they are encoded\n+            try:\n+                enc_hdr = e.info().get('Content-Encoding') or e.info().get('content-encoding')\n+            except Exception:\n+                enc_hdr = None\n+            if enc_hdr:\n+                enc_l = to_native(enc_hdr).lower()\n+                if enc_l in ('gzip', 'x-gzip'):\n+                    try:\n+                        import io\n+                        import gzip\n+                        body = gzip.GzipFile(fileobj=io.BytesIO(body)).read()\n+                    except Exception:\n+                        pass\n+                elif enc_l in ('deflate', 'x-deflate'):\n+                    try:\n+                        import zlib\n+                        try:\n+                            body = zlib.decompress(body)\n+                        except zlib.error:\n+                            body = zlib.decompress(body, -zlib.MAX_WBITS)\n+                    except Exception:\n+                        pass\n         except AttributeError:\n             body = ''\n         else:\n"
}