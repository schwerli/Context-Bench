{
    "instance_id": "SWE-Bench-Pro__javascript__maintenance__bugfix__4eb0e647",
    "original_id": "instance_NodeBB__NodeBB-04998908ba6721d64eba79ae3b65a351dcfbc5b5-vnan",
    "1_model_selected_files": [
        "src/user/email.js",
        "src/controllers/write/users.js",
        "src/controllers/admin/users.js",
        "public/src/admin/manage/users.js",
        "src/user/admin.js"
    ],
    "2_embedding_selected_files": [
        "src/user/email.js",
        "src/controllers/admin/users.js",
        "src/user/profile.js",
        "public/src/admin/settings/email.js",
        "src/user/interstitials.js",
        "src/upgrades/1.0.0/users_notvalidated.js",
        "public/src/admin/manage/users.js",
        "src/upgrades/2.8.7/fix-email-sorted-sets.js",
        "public/src/admin/modules/change-email.js",
        "src/user/create.js",
        "src/user/approval.js",
        "src/middleware/user.js",
        "src/socket.io/admin/email.js",
        "src/emailer.js",
        "src/api/users.js",
        "src/controllers/index.js",
        "src/user/reset.js",
        "src/user/invite.js",
        "public/src/admin/settings/api.js",
        "src/upgrades/1.15.0/verified_users_group.js",
        "src/upgrades/4.3.0/fix_duplicate_handles.js",
        "public/src/client/account/edit.js",
        "src/controllers/admin/settings.js",
        "src/controllers/authentication.js",
        "src/controllers/accounts/settings.js",
        "src/upgrades/1.18.0/enable_include_unverified_emails.js",
        "src/controllers/accounts/edit.js",
        "public/src/admin/manage/registration.js",
        "public/src/admin/dashboard/users.js",
        "public/src/admin/admin.js",
        "src/upgrades/1.10.2/username_email_history.js",
        "src/upgrades/1.12.1/clear_username_email_history.js",
        "src/user/data.js",
        "public/src/client/account/edit/password.js",
        "src/controllers/accounts/helpers.js",
        "public/src/client/account/edit/username.js",
        "src/user/auth.js",
        "public/src/admin/manage/digest.js",
        "public/src/modules/accounts/invite.js",
        "src/user/index.js",
        "src/user/admin.js",
        "src/upgrades/1.6.0/clear-stale-digest-template.js",
        "src/user/digest.js",
        "src/user/bans.js",
        "src/controllers/write/users.js",
        "src/user/notifications.js",
        "src/socket.io/admin/user.js",
        "public/src/client/groups/details.js",
        "public/src/client/post-queue.js",
        "public/src/client/reset.js",
        "src/upgrades/1.19.0/reenable-username-login.js",
        "src/user/settings.js",
        "src/upgrades/3.8.0/events-uid-filter.js",
        "src/upgrades/4.0.0/regenerate_slugs_for_users_with_periods.js",
        "src/upgrades/1.7.1/notification-settings.js",
        "src/user/info.js",
        "public/src/client/register.js",
        "src/upgrades/1.13.3/fix_users_sorted_sets.js"
    ],
    "3_final_combined_files": [
        "src/user/email.js",
        "src/controllers/admin/users.js",
        "src/controllers/write/users.js",
        "src/user/profile.js"
    ],
    "4_related_elements": {
        "src/user/email.js": [
            "function: UserEmail.getEmailForValidation\nfunction: UserEmail.isValidationPending\nfunction: UserEmail.getValidationExpiry\nfunction: UserEmail.expireValidation\nfunction: UserEmail.canSendValidation\nfunction: UserEmail.sendValidationEmail\nfunction: UserEmail.confirmByCode\nfunction: UserEmail.confirmByUid\nfunction: UserEmail.remove\nvariable: meta.config.emailConfirmExpiry\nvariable: meta.config.emailConfirmInterval\nvariable: meta.config.sendValidationEmail"
        ],
        "src/controllers/admin/users.js": [
            "variable: userFields\nfunction: loadUserInfo\nfunction: getUsers\nfunction: getConfirmObjs"
        ],
        "src/controllers/write/users.js": [
            "function: Users.confirmEmail\nfunction: Users.addEmail"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "src/controllers/admin/users.js": [
                    "function: loadUserInfo\nfunction: getConfirmObjs\nline: 174\nline: 175\nline: 176\nline: 177\nline: 178\nline: 179\nline: 198\nline: 199\nline: 200\nline: 201\nline: 202\nline: 203"
                ],
                "src/user/email.js": [
                    ""
                ],
                "src/controllers/write/users.js": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/controllers/admin/users.js b/src/controllers/admin/users.js\nindex 42ee986..2f9a612 100644\n--- a/src/controllers/admin/users.js\n+++ b/src/controllers/admin/users.js\n@@ -171,35 +171,88 @@ async function loadUserInfo(callerUid, uids) {\n \tasync function getIPs() {\n \t\treturn await Promise.all(uids.map(uid => db.getSortedSetRevRange(`uid:${uid}:ip`, 0, 4)));\n \t}\n-\tasync function getConfirmObjs() {\n-\t\tconst keys = uids.map(uid => `confirm:byUid:${uid}`);\n-\t\tconst codes = await db.mget(keys);\n-\t\tconst confirmObjs = await db.getObjects(codes.map(code => `confirm:${code}`));\n-\t\treturn uids.map((uid, index) => confirmObjs[index]);\n+\n+\tasync function getConfirmObjsWithFallback(userData) {\n+\t\t// First try to get confirmation codes by uid\n+\t\tconst byUidKeys = uids.map(uid => `confirm:byUid:${uid}`);\n+\t\tconst codesByUid = await db.mget(byUidKeys);\n+\t\tconst codes = Array.isArray(codesByUid) ? codesByUid.slice() : [];\n+\n+\t\t// Fallback to byEmail if byUid is missing\n+\t\tconst emailKeys = [];\n+\t\tconst emailIndexMap = [];\n+\t\tuserData.forEach((u, i) => {\n+\t\t\tif (!codes[i] && u && u.email) {\n+\t\t\t\temailKeys.push(`confirm:byEmail:${u.email}`);\n+\t\t\t\temailIndexMap.push(i);\n+\t\t\t}\n+\t\t});\n+\n+\t\tif (emailKeys.length) {\n+\t\t\tconst emailCodes = await db.mget(emailKeys);\n+\t\t\temailCodes.forEach((code, idx) => {\n+\t\t\t\tconst originalIndex = emailIndexMap[idx];\n+\t\t\t\tif (!codes[originalIndex]) {\n+\t\t\t\t\tcodes[originalIndex] = code;\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t// Fetch confirm objects for the gathered codes, keeping alignment with uids\n+\t\tconst objectKeyIndexMap = [];\n+\t\tconst objectKeys = [];\n+\t\tcodes.forEach((code, i) => {\n+\t\t\tif (code) {\n+\t\t\t\tobjectKeyIndexMap.push(i);\n+\t\t\t\tobjectKeys.push(`confirm:${code}`);\n+\t\t\t}\n+\t\t});\n+\n+\t\tconst found = objectKeys.length ? await db.getObjects(objectKeys) : [];\n+\t\tconst confirmObjs = new Array(uids.length).fill(null);\n+\t\tfound.forEach((obj, idx) => {\n+\t\t\tconst i = objectKeyIndexMap[idx];\n+\t\t\tconfirmObjs[i] = obj || null;\n+\t\t});\n+\n+\t\treturn confirmObjs;\n \t}\n \n-\tconst [isAdmin, userData, lastonline, confirmObjs, ips] = await Promise.all([\n+\t// Fetch base user info first so we can use email for fallback confirmation lookup\n+\tconst [isAdmin, userData, lastonline, ips] = await Promise.all([\n \t\tuser.isAdministrator(uids),\n \t\tuser.getUsersWithFields(uids, userFields, callerUid),\n \t\tdb.sortedSetScores('users:online', uids),\n-\t\tgetConfirmObjs(),\n \t\tgetIPs(),\n \t]);\n+\n+\tconst confirmObjs = await getConfirmObjsWithFallback(userData);\n+\n \tuserData.forEach((user, index) => {\n \t\tif (user) {\n \t\t\tuser.administrator = isAdmin[index];\n-\t\t\tuser.flags = userData[index].flags || 0;\n+\t\t\tuser.flags = user.flags || 0;\n \t\t\tconst timestamp = lastonline[index] || user.joindate;\n \t\t\tuser.lastonline = timestamp;\n \t\t\tuser.lastonlineISO = utils.toISOString(timestamp);\n \t\t\tuser.ips = ips[index];\n \t\t\tuser.ip = ips[index] && ips[index][0] ? ips[index][0] : null;\n \t\t\tuser.emailToConfirm = user.email;\n-\t\t\tif (confirmObjs[index] && confirmObjs[index].email) {\n-\t\t\t\tconst confirmObj = confirmObjs[index];\n-\t\t\t\tuser['email:expired'] = !confirmObj.expires || Date.now() >= confirmObj.expires;\n-\t\t\t\tuser['email:pending'] = confirmObj.expires && Date.now() < confirmObj.expires;\n+\n+\t\t\tconst confirmObj = confirmObjs[index];\n+\t\t\tif (confirmObj && confirmObj.email) {\n+\t\t\t\tconst hasExpiry = Boolean(confirmObj.expires);\n+\t\t\t\tconst isExpired = hasExpiry ? Date.now() >= confirmObj.expires : false;\n+\n+\t\t\t\tuser['email:expired'] = isExpired;\n+\t\t\t\t// Consider confirmation valid (pending) until it explicitly expires\n+\t\t\t\tuser['email:pending'] = !isExpired;\n \t\t\t\tuser.emailToConfirm = validator.escape(String(confirmObj.email));\n+\t\t\t} else {\n+\t\t\t\t// No confirmation info available\n+\t\t\t\tuser['email:expired'] = false;\n+\t\t\t\tuser['email:pending'] = false;\n+\t\t\t\tuser['email:missing'] = true;\n \t\t\t}\n \t\t}\n \t});",
                "diff --git a/src/controllers/admin/users.js b/src/controllers/admin/users.js\nindex 42ee986..4191003 100644\n--- a/src/controllers/admin/users.js\n+++ b/src/controllers/admin/users.js\n@@ -171,20 +171,67 @@ async function loadUserInfo(callerUid, uids) {\n \tasync function getIPs() {\n \t\treturn await Promise.all(uids.map(uid => db.getSortedSetRevRange(`uid:${uid}:ip`, 0, 4)));\n \t}\n-\tasync function getConfirmObjs() {\n-\t\tconst keys = uids.map(uid => `confirm:byUid:${uid}`);\n-\t\tconst codes = await db.mget(keys);\n-\t\tconst confirmObjs = await db.getObjects(codes.map(code => `confirm:${code}`));\n-\t\treturn uids.map((uid, index) => confirmObjs[index]);\n-\t}\n \n-\tconst [isAdmin, userData, lastonline, confirmObjs, ips] = await Promise.all([\n+\t// Load core user info in parallel first so we can use emails for confirmation fallbacks\n+\tconst [isAdmin, userData, lastonline, ips] = await Promise.all([\n \t\tuser.isAdministrator(uids),\n \t\tuser.getUsersWithFields(uids, userFields, callerUid),\n \t\tdb.sortedSetScores('users:online', uids),\n-\t\tgetConfirmObjs(),\n \t\tgetIPs(),\n \t]);\n+\n+\t// Build confirmation objects with fallbacks:\n+\t// 1) try by uid -> code\n+\t// 2) if missing/expired, try by email -> code\n+\tconst confirmObjs = await (async () => {\n+\t\tconst byUidKeys = uids.map(uid => `confirm:byUid:${uid}`);\n+\t\tconst uidCodes = await db.mget(byUidKeys);\n+\n+\t\t// Fetch confirm objects for valid uid codes\n+\t\tconst uidCodePairs = [];\n+\t\tuidCodes.forEach((code, i) => {\n+\t\t\tif (code) {\n+\t\t\t\tuidCodePairs.push({ code, i });\n+\t\t\t}\n+\t\t});\n+\t\tconst uidConfirmObjs = uidCodePairs.length ? await db.getObjects(uidCodePairs.map(p => `confirm:${p.code}`)) : [];\n+\n+\t\t// Place results in array aligned to uids\n+\t\tconst results = new Array(uids.length).fill(null);\n+\t\tuidConfirmObjs.forEach((obj, idx) => {\n+\t\t\tconst i = uidCodePairs[idx].i;\n+\t\t\tresults[i] = obj;\n+\t\t});\n+\n+\t\t// Fallback by email for missing entries\n+\t\tconst fallbackEmailKeys = [];\n+\t\tconst fallbackIndex = [];\n+\t\tuserData.forEach((u, i) => {\n+\t\t\tif (!results[i] && u && u.email) {\n+\t\t\t\tfallbackEmailKeys.push(`confirm:byEmail:${u.email}`);\n+\t\t\t\tfallbackIndex.push(i);\n+\t\t\t}\n+\t\t});\n+\t\tif (fallbackEmailKeys.length) {\n+\t\t\tconst emailCodes = await db.mget(fallbackEmailKeys);\n+\t\t\tconst emailCodePairs = [];\n+\t\t\temailCodes.forEach((code, j) => {\n+\t\t\t\tif (code) {\n+\t\t\t\t\temailCodePairs.push({ code, i: fallbackIndex[j] });\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tif (emailCodePairs.length) {\n+\t\t\t\tconst emailConfirmObjs = await db.getObjects(emailCodePairs.map(p => `confirm:${p.code}`));\n+\t\t\t\temailConfirmObjs.forEach((obj, idx) => {\n+\t\t\t\t\tconst i = emailCodePairs[idx].i;\n+\t\t\t\t\tresults[i] = obj;\n+\t\t\t\t});\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn results;\n+\t})();\n+\n \tuserData.forEach((user, index) => {\n \t\tif (user) {\n \t\t\tuser.administrator = isAdmin[index];\n@@ -194,12 +241,23 @@ async function loadUserInfo(callerUid, uids) {\n \t\t\tuser.lastonlineISO = utils.toISOString(timestamp);\n \t\t\tuser.ips = ips[index];\n \t\t\tuser.ip = ips[index] && ips[index][0] ? ips[index][0] : null;\n+\n+\t\t\t// Default to the user's current email; UI can re-send using this even if no confirmObj\n \t\t\tuser.emailToConfirm = user.email;\n-\t\t\tif (confirmObjs[index] && confirmObjs[index].email) {\n-\t\t\t\tconst confirmObj = confirmObjs[index];\n-\t\t\t\tuser['email:expired'] = !confirmObj.expires || Date.now() >= confirmObj.expires;\n-\t\t\t\tuser['email:pending'] = confirmObj.expires && Date.now() < confirmObj.expires;\n+\n+\t\t\tconst confirmObj = confirmObjs[index];\n+\t\t\tif (confirmObj && confirmObj.email) {\n+\t\t\t\tconst expires = parseInt(confirmObj.expires, 10);\n+\t\t\t\tconst hasExpires = !isNaN(expires);\n+\t\t\t\t// Treat confirmation as valid/pending until it explicitly expires\n+\t\t\t\tuser['email:expired'] = hasExpires ? (Date.now() >= expires) : false;\n+\t\t\t\tuser['email:pending'] = hasExpires ? (Date.now() < expires) : true;\n \t\t\t\tuser.emailToConfirm = validator.escape(String(confirmObj.email));\n+\t\t\t} else {\n+\t\t\t\t// No confirmation object found; mark status explicitly to avoid ambiguity in ACP\n+\t\t\t\tuser['email:expired'] = false;\n+\t\t\t\tuser['email:pending'] = false;\n+\t\t\t\tuser['email:missing'] = true;\n \t\t\t}\n \t\t}\n \t});"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "src/controllers/admin/users.js": [
                    "function: loadUserInfo\nfunction: getConfirmObjs\nline: 175\nline: 176\nline: 177\nline: 178\nline: 198\nline: 200\nline: 201\nline: 202"
                ],
                "src/user/email.js": [
                    ""
                ],
                "src/controllers/write/users.js": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/controllers/admin/users.js b/src/controllers/admin/users.js\nindex 42ee986..56eae78 100644\n--- a/src/controllers/admin/users.js\n+++ b/src/controllers/admin/users.js\n@@ -174,8 +174,14 @@ async function loadUserInfo(callerUid, uids) {\n \tasync function getConfirmObjs() {\n \t\tconst keys = uids.map(uid => `confirm:byUid:${uid}`);\n \t\tconst codes = await db.mget(keys);\n-\t\tconst confirmObjs = await db.getObjects(codes.map(code => `confirm:${code}`));\n-\t\treturn uids.map((uid, index) => confirmObjs[index]);\n+\t\t// Safely fetch confirm objects, preserving index alignment and avoiding invalid keys\n+\t\tconst confirmObjs = await Promise.all(codes.map(async (code) => {\n+\t\t\tif (code) {\n+\t\t\t\treturn await db.getObject(`confirm:${code}`);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}));\n+\t\treturn confirmObjs;\n \t}\n \n \tconst [isAdmin, userData, lastonline, confirmObjs, ips] = await Promise.all([\n@@ -194,12 +200,34 @@ async function loadUserInfo(callerUid, uids) {\n \t\t\tuser.lastonlineISO = utils.toISOString(timestamp);\n \t\t\tuser.ips = ips[index];\n \t\t\tuser.ip = ips[index] && ips[index][0] ? ips[index][0] : null;\n-\t\t\tuser.emailToConfirm = user.email;\n-\t\t\tif (confirmObjs[index] && confirmObjs[index].email) {\n-\t\t\t\tconst confirmObj = confirmObjs[index];\n-\t\t\t\tuser['email:expired'] = !confirmObj.expires || Date.now() >= confirmObj.expires;\n-\t\t\t\tuser['email:pending'] = confirmObj.expires && Date.now() < confirmObj.expires;\n+\n+\t\t\t// Initialize email status flags\n+\t\t\tuser['email:expired'] = false;\n+\t\t\tuser['email:pending'] = false;\n+\t\t\tuser['email:validated'] = false;\n+\t\t\tuser['email:missing'] = false;\n+\n+\t\t\t// Default email to confirm from user record (escaped), if present\n+\t\t\tuser.emailToConfirm = user.email ? validator.escape(String(user.email)) : null;\n+\n+\t\t\tconst confirmObj = confirmObjs[index];\n+\t\t\tif (confirmObj && confirmObj.email) {\n+\t\t\t\t// Confirmation key exists; treat as pending until it explicitly expires\n+\t\t\t\tconst expires = Number(confirmObj.expires) || 0;\n+\t\t\t\tconst hasExpiry = !!confirmObj.expires;\n+\t\t\t\tconst now = Date.now();\n+\t\t\t\tconst isExpired = hasExpiry && now >= expires;\n+\n+\t\t\t\tuser['email:expired'] = isExpired;\n+\t\t\t\tuser['email:pending'] = hasExpiry ? !isExpired : true;\n \t\t\t\tuser.emailToConfirm = validator.escape(String(confirmObj.email));\n+\t\t\t} else if (user.email) {\n+\t\t\t\t// No confirmation object; consider email present and validated\n+\t\t\t\tuser['email:validated'] = true;\n+\t\t\t} else {\n+\t\t\t\t// No email on record\n+\t\t\t\tuser['email:missing'] = true;\n+\t\t\t\tuser.emailToConfirm = null;\n \t\t\t}\n \t\t}\n \t});"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/src/controllers/admin/users.js b/src/controllers/admin/users.js\nindex 42ee986..2f9a612 100644\n--- a/src/controllers/admin/users.js\n+++ b/src/controllers/admin/users.js\n@@ -171,35 +171,88 @@ async function loadUserInfo(callerUid, uids) {\n \tasync function getIPs() {\n \t\treturn await Promise.all(uids.map(uid => db.getSortedSetRevRange(`uid:${uid}:ip`, 0, 4)));\n \t}\n-\tasync function getConfirmObjs() {\n-\t\tconst keys = uids.map(uid => `confirm:byUid:${uid}`);\n-\t\tconst codes = await db.mget(keys);\n-\t\tconst confirmObjs = await db.getObjects(codes.map(code => `confirm:${code}`));\n-\t\treturn uids.map((uid, index) => confirmObjs[index]);\n+\n+\tasync function getConfirmObjsWithFallback(userData) {\n+\t\t// First try to get confirmation codes by uid\n+\t\tconst byUidKeys = uids.map(uid => `confirm:byUid:${uid}`);\n+\t\tconst codesByUid = await db.mget(byUidKeys);\n+\t\tconst codes = Array.isArray(codesByUid) ? codesByUid.slice() : [];\n+\n+\t\t// Fallback to byEmail if byUid is missing\n+\t\tconst emailKeys = [];\n+\t\tconst emailIndexMap = [];\n+\t\tuserData.forEach((u, i) => {\n+\t\t\tif (!codes[i] && u && u.email) {\n+\t\t\t\temailKeys.push(`confirm:byEmail:${u.email}`);\n+\t\t\t\temailIndexMap.push(i);\n+\t\t\t}\n+\t\t});\n+\n+\t\tif (emailKeys.length) {\n+\t\t\tconst emailCodes = await db.mget(emailKeys);\n+\t\t\temailCodes.forEach((code, idx) => {\n+\t\t\t\tconst originalIndex = emailIndexMap[idx];\n+\t\t\t\tif (!codes[originalIndex]) {\n+\t\t\t\t\tcodes[originalIndex] = code;\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t// Fetch confirm objects for the gathered codes, keeping alignment with uids\n+\t\tconst objectKeyIndexMap = [];\n+\t\tconst objectKeys = [];\n+\t\tcodes.forEach((code, i) => {\n+\t\t\tif (code) {\n+\t\t\t\tobjectKeyIndexMap.push(i);\n+\t\t\t\tobjectKeys.push(`confirm:${code}`);\n+\t\t\t}\n+\t\t});\n+\n+\t\tconst found = objectKeys.length ? await db.getObjects(objectKeys) : [];\n+\t\tconst confirmObjs = new Array(uids.length).fill(null);\n+\t\tfound.forEach((obj, idx) => {\n+\t\t\tconst i = objectKeyIndexMap[idx];\n+\t\t\tconfirmObjs[i] = obj || null;\n+\t\t});\n+\n+\t\treturn confirmObjs;\n \t}\n \n-\tconst [isAdmin, userData, lastonline, confirmObjs, ips] = await Promise.all([\n+\t// Fetch base user info first so we can use email for fallback confirmation lookup\n+\tconst [isAdmin, userData, lastonline, ips] = await Promise.all([\n \t\tuser.isAdministrator(uids),\n \t\tuser.getUsersWithFields(uids, userFields, callerUid),\n \t\tdb.sortedSetScores('users:online', uids),\n-\t\tgetConfirmObjs(),\n \t\tgetIPs(),\n \t]);\n+\n+\tconst confirmObjs = await getConfirmObjsWithFallback(userData);\n+\n \tuserData.forEach((user, index) => {\n \t\tif (user) {\n \t\t\tuser.administrator = isAdmin[index];\n-\t\t\tuser.flags = userData[index].flags || 0;\n+\t\t\tuser.flags = user.flags || 0;\n \t\t\tconst timestamp = lastonline[index] || user.joindate;\n \t\t\tuser.lastonline = timestamp;\n \t\t\tuser.lastonlineISO = utils.toISOString(timestamp);\n \t\t\tuser.ips = ips[index];\n \t\t\tuser.ip = ips[index] && ips[index][0] ? ips[index][0] : null;\n \t\t\tuser.emailToConfirm = user.email;\n-\t\t\tif (confirmObjs[index] && confirmObjs[index].email) {\n-\t\t\t\tconst confirmObj = confirmObjs[index];\n-\t\t\t\tuser['email:expired'] = !confirmObj.expires || Date.now() >= confirmObj.expires;\n-\t\t\t\tuser['email:pending'] = confirmObj.expires && Date.now() < confirmObj.expires;\n+\n+\t\t\tconst confirmObj = confirmObjs[index];\n+\t\t\tif (confirmObj && confirmObj.email) {\n+\t\t\t\tconst hasExpiry = Boolean(confirmObj.expires);\n+\t\t\t\tconst isExpired = hasExpiry ? Date.now() >= confirmObj.expires : false;\n+\n+\t\t\t\tuser['email:expired'] = isExpired;\n+\t\t\t\t// Consider confirmation valid (pending) until it explicitly expires\n+\t\t\t\tuser['email:pending'] = !isExpired;\n \t\t\t\tuser.emailToConfirm = validator.escape(String(confirmObj.email));\n+\t\t\t} else {\n+\t\t\t\t// No confirmation info available\n+\t\t\t\tuser['email:expired'] = false;\n+\t\t\t\tuser['email:pending'] = false;\n+\t\t\t\tuser['email:missing'] = true;\n \t\t\t}\n \t\t}\n \t});"
}