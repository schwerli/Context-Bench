{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__18d7bbbc",
    "original_id": "instance_ansible__ansible-6cc97447aac5816745278f3735af128afb255c81-v0f01c69f1e2528b935359cfe578530722bca2c59",
    "1_model_selected_files": [
        "lib/ansible/template/__init__.py",
        "lib/ansible/parsing/yaml/objects.py",
        "lib/ansible/plugins/lookup/__init__.py",
        "lib/ansible/_internal/_templating/_jinja_plugins.py",
        "lib/ansible/executor/module_common.py"
    ],
    "2_embedding_selected_files": [
        "lib/ansible/_internal/_yaml/_errors.py",
        "lib/ansible/parsing/yaml/objects.py",
        "lib/ansible/_internal/_templating/_datatag.py",
        "lib/ansible/module_utils/common/parameters.py",
        "lib/ansible/constants.py",
        "lib/ansible/plugins/doc_fragments/template_common.py",
        "lib/ansible/_internal/_templating/_jinja_bits.py",
        "lib/ansible/utils/unsafe_proxy.py",
        "lib/ansible/_internal/_templating/_engine.py",
        "lib/ansible/_internal/_templating/_jinja_common.py",
        "lib/ansible/plugins/doc_fragments/shell_common.py",
        "lib/ansible/module_utils/errors.py",
        "lib/ansible/_internal/_templating/_marker_behaviors.py",
        "lib/ansible/template/__init__.py",
        "lib/ansible/_internal/_errors/_utils.py",
        "lib/ansible/cli/arguments/option_helpers.py",
        "lib/ansible/plugins/callback/__init__.py",
        "lib/ansible/errors/__init__.py",
        "lib/ansible/modules/template.py",
        "lib/ansible/module_utils/_internal/_datatag/_tags.py",
        "lib/ansible/_internal/_templating/_jinja_patches.py",
        "hacking/create-bulk-issues.py",
        "lib/ansible/plugins/action/debug.py",
        "lib/ansible/module_utils/common/messages.py",
        "lib/ansible/playbook/task.py",
        "lib/ansible/cli/doc.py",
        "lib/ansible/plugins/doc_fragments/action_core.py",
        "lib/ansible/cli/config.py",
        "lib/ansible/_internal/_templating/_utils.py",
        "packaging/release.py",
        "lib/ansible/_internal/_templating/_errors.py",
        "lib/ansible/_internal/_templating/_chain_templar.py",
        "lib/ansible/plugins/doc_fragments/action_common_attributes.py",
        "lib/ansible/modules/debug.py",
        "lib/ansible/plugins/lookup/template.py",
        "lib/ansible/modules/replace.py",
        "lib/ansible/_internal/ansible_collections/ansible/_protomatter/plugins/action/debug.py",
        "lib/ansible/plugins/filter/core.py",
        "lib/ansible/modules/debconf.py",
        "lib/ansible/module_utils/basic.py",
        "lib/ansible/modules/assert.py",
        "lib/ansible/cli/__init__.py",
        "lib/ansible/vars/clean.py",
        "lib/ansible/modules/apt.py",
        "lib/ansible/modules/file.py",
        "lib/ansible/module_utils/common/warnings.py",
        "lib/ansible/module_utils/datatag.py",
        "lib/ansible/utils/display.py",
        "lib/ansible/modules/unarchive.py",
        "lib/ansible/_internal/_templating/_transform.py",
        "lib/ansible/_internal/_templating/_jinja_plugins.py",
        "lib/ansible/_internal/_templating/__init__.py",
        "lib/ansible/plugins/doc_fragments/return_common.py",
        "lib/ansible/modules/include_vars.py",
        "lib/ansible/_internal/_templating/_access.py",
        "lib/ansible/_internal/_errors/_captured.py",
        "hacking/ansible-profile.py",
        "lib/ansible/parsing/vault/__init__.py",
        "lib/ansible/modules/pause.py"
    ],
    "3_final_combined_files": [
        "lib/ansible/parsing/yaml/objects.py",
        "lib/ansible/template/__init__.py",
        "lib/ansible/plugins/lookup/__init__.py",
        "lib/ansible/_internal/_yaml/_errors.py",
        "lib/ansible/_internal/_templating/_datatag.py"
    ],
    "4_related_elements": {
        "lib/ansible/parsing/yaml/objects.py": [
            "class: _AnsibleMapping\nclass: _AnsibleUnicode\nclass: _AnsibleSequence\nclass: _AnsibleVaultEncryptedUnicode\nfunction: __getattr__"
        ],
        "lib/ansible/template/__init__.py": [
            "variable: _UNSET\nvariable: AnsibleUndefined\nfunction: Templar.copy_with_new_env\nfunction: Templar.set_temporary_context\nfunction: Templar.template\nfunction: Templar.do_template\nfunction: Templar.evaluate_expression\nfunction: Templar.resolve_variable_expression\nfunction: Templar.evaluate_conditional\nfunction: Templar.environment\nfunction: trust_as_template\nfunction: is_trusted_as_template\nfunction: generate_ansible_template_vars"
        ],
        "lib/ansible/plugins/lookup/__init__.py": [
            "variable: display\nclass: LookupBase\nfunction: LookupBase.run\nfunction: LookupBase._deprecate_inline_kv"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "lib/ansible/parsing/yaml/objects.py": [
                    "function: _AnsibleMapping.__new__\nline: 15\nline: 16\nfunction: _AnsibleUnicode.__new__\nline: 22\nline: 23\nfunction: _AnsibleSequence.__new__\nline: 29\nline: 30"
                ],
                "lib/ansible/template/__init__.py": [
                    "function: Templar.copy_with_new_env\nline: 174\nfunction: Templar.set_temporary_context\nline: 216"
                ],
                "lib/ansible/plugins/lookup/__init__.py": [
                    "function: LookupBase.find_file_in_search_path\nline: 135\nline: 138"
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/parsing/yaml/objects.py b/lib/ansible/parsing/yaml/objects.py\nindex 1e96fea..f91de12 100644\n--- a/lib/ansible/parsing/yaml/objects.py\n+++ b/lib/ansible/parsing/yaml/objects.py\n@@ -12,22 +12,31 @@ from ansible.parsing import vault as _vault\n class _AnsibleMapping(dict):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, dict(value))\n+    def __new__(cls, *args, **kwargs):\n+        # Mirror dict() constructor: allow no args, mapping, iterable of pairs, and kwargs\n+        value = dict(*args, **kwargs)\n+        original = args[0] if args else (kwargs if kwargs else value)\n+        return _datatag.AnsibleTagHelper.tag_copy(original, value)\n \n \n class _AnsibleUnicode(str):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, str(value))\n+    def __new__(cls, *args, **kwargs):\n+        # Mirror str() constructor: allow no args, object=..., or bytes with encoding/errors\n+        value = str(*args, **kwargs)\n+        original = args[0] if args else (kwargs.get('object', value))\n+        return _datatag.AnsibleTagHelper.tag_copy(original, value)\n \n \n class _AnsibleSequence(list):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, list(value))\n+    def __new__(cls, *args):\n+        # Mirror list() constructor: allow no args or iterable\n+        value = list(*args)\n+        original = args[0] if args else value\n+        return _datatag.AnsibleTagHelper.tag_copy(original, value)\n \n \n class _AnsibleVaultEncryptedUnicode:\ndiff --git a/lib/ansible/template/__init__.py b/lib/ansible/template/__init__.py\nindex 533ea9a..5c61773 100644\n--- a/lib/ansible/template/__init__.py\n+++ b/lib/ansible/template/__init__.py\n@@ -159,7 +159,9 @@ class Templar:\n                 version='2.23',\n             )\n \n-        if context_overrides:\n+        # Ignore None-valued overrides; only warn if there are effective overrides\n+        filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+        if filtered_overrides:\n             _display.deprecated(\n                 msg='Passing Jinja environment overrides to `copy_with_new_env` is deprecated.',\n                 help_text='Pass Jinja environment overrides to individual `template` calls.',\n@@ -171,7 +173,7 @@ class Templar:\n             variables=self._engine._variables if available_variables is None else available_variables,\n         )\n \n-        templar._overrides = self._overrides.merge(context_overrides)\n+        templar._overrides = self._overrides.merge(filtered_overrides)\n \n         if searchpath is not None:\n             templar._engine.environment.loader.searchpath = searchpath\n@@ -213,7 +215,9 @@ class Templar:\n                     original[key] = getattr(target, key)\n                     setattr(target, key, value)\n \n-            self._overrides = self._overrides.merge(context_overrides)\n+            # Ignore None-valued overrides to prevent errors when temporary overrides include unset values\n+            filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+            self._overrides = self._overrides.merge(filtered_overrides)\n \n             yield\n         finally:\n",
                "diff --git a/lib/ansible/parsing/yaml/objects.py b/lib/ansible/parsing/yaml/objects.py\nindex 1e96fea..8b949e3 100644\n--- a/lib/ansible/parsing/yaml/objects.py\n+++ b/lib/ansible/parsing/yaml/objects.py\n@@ -12,22 +12,34 @@ from ansible.parsing import vault as _vault\n class _AnsibleMapping(dict):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, dict(value))\n+    def __new__(cls, *args, **kwargs):\n+        # Support the full dict constructor semantics, including invocation without arguments\n+        new_value = dict(*args, **kwargs)\n+        source = args[0] if args else new_value\n+        return _datatag.AnsibleTagHelper.tag_copy(source, new_value)\n \n \n class _AnsibleUnicode(str):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, str(value))\n+    def __new__(cls, object='', encoding=None, errors=None):\n+        # Support legacy constructor patterns compatible with str(), including bytes plus encoding/errors and invocation without arguments\n+        # Use to_text to normalize both text and bytes input\n+        if encoding is not None or errors is not None:\n+            text = _converters.to_text(object, encoding=encoding or 'utf-8', errors=errors or 'strict')\n+        else:\n+            text = _converters.to_text(object)\n+        return _datatag.AnsibleTagHelper.tag_copy(object, text)\n \n \n class _AnsibleSequence(list):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, list(value))\n+    def __new__(cls, *args):\n+        # Support the full list constructor semantics, including invocation without arguments\n+        new_value = list(*args)\n+        source = args[0] if args else new_value\n+        return _datatag.AnsibleTagHelper.tag_copy(source, new_value)\n \n \n class _AnsibleVaultEncryptedUnicode:\n@@ -53,4 +65,4 @@ def __getattr__(name: str) -> _t.Any:\n \n         return value\n \n-    raise AttributeError(f'module {__name__!r} has no attribute {name!r}')\n+    raise AttributeError(f'module {__name__!r} has no attribute {name!r}')\ndiff --git a/lib/ansible/plugins/lookup/__init__.py b/lib/ansible/plugins/lookup/__init__.py\nindex 5ee0cb1..e883ef3 100644\n--- a/lib/ansible/plugins/lookup/__init__.py\n+++ b/lib/ansible/plugins/lookup/__init__.py\n@@ -133,13 +133,13 @@ class LookupBase(AnsiblePlugin):\n         result = None\n         try:\n             result = self._loader.path_dwim_relative_stack(paths, subdir, needle, is_role=bool('role_path' in myvars))\n-        except AnsibleFileNotFound:\n+        except AnsibleFileNotFound as e:\n             if not ignore_missing:\n-                self._display.warning(\"Unable to find '%s' in expected paths (use -vvvvv to see paths)\" % needle)\n+                self._display.warning(\"Unable to find '%s' in expected paths (use -vvvvv to see paths): %s: %s\" % (needle, e.__class__.__name__, e))\n \n         return result\n \n     def _deprecate_inline_kv(self):\n         # TODO: place holder to deprecate in future version allowing for long transition period\n         # self._display.deprecated('Passing inline k=v values embedded in a string to this lookup. Use direct ,k=v, k2=v2 syntax instead.', version='2.18')\n-        pass\n+        pass\ndiff --git a/lib/ansible/template/__init__.py b/lib/ansible/template/__init__.py\nindex 533ea9a..8f64110 100644\n--- a/lib/ansible/template/__init__.py\n+++ b/lib/ansible/template/__init__.py\n@@ -159,7 +159,9 @@ class Templar:\n                 version='2.23',\n             )\n \n-        if context_overrides:\n+        # Ignore None-valued overrides and only deprecate if there are effective overrides\n+        filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+        if filtered_overrides:\n             _display.deprecated(\n                 msg='Passing Jinja environment overrides to `copy_with_new_env` is deprecated.',\n                 help_text='Pass Jinja environment overrides to individual `template` calls.',\n@@ -171,7 +173,7 @@ class Templar:\n             variables=self._engine._variables if available_variables is None else available_variables,\n         )\n \n-        templar._overrides = self._overrides.merge(context_overrides)\n+        templar._overrides = self._overrides.merge(filtered_overrides)\n \n         if searchpath is not None:\n             templar._engine.environment.loader.searchpath = searchpath\n@@ -213,7 +215,9 @@ class Templar:\n                     original[key] = getattr(target, key)\n                     setattr(target, key, value)\n \n-            self._overrides = self._overrides.merge(context_overrides)\n+            # Ignore None-valued overrides when temporarily setting context\n+            filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+            self._overrides = self._overrides.merge(filtered_overrides)\n \n             yield\n         finally:\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "lib/ansible/parsing/yaml/objects.py": [
                    "class: _AnsibleMapping\nline: 15\nline: 16\nclass: _AnsibleUnicode\nline: 22\nline: 23\nclass: _AnsibleSequence\nline: 29\nline: 30\nfunction: __getattr__"
                ],
                "lib/ansible/template/__init__.py": [
                    "function: Templar.copy_with_new_env\nline: 174\nfunction: Templar.set_temporary_context\nline: 216"
                ],
                "lib/ansible/plugins/lookup/__init__.py": [
                    "function: LookupBase.find_file_in_search_path\nline: 134\nline: 138"
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/parsing/yaml/objects.py b/lib/ansible/parsing/yaml/objects.py\nindex 1e96fea..fbba10c 100644\n--- a/lib/ansible/parsing/yaml/objects.py\n+++ b/lib/ansible/parsing/yaml/objects.py\n@@ -12,22 +12,35 @@ from ansible.parsing import vault as _vault\n class _AnsibleMapping(dict):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, dict(value))\n+    def __new__(cls, *args, **kwargs):\n+        constructed = dict(*args, **kwargs)\n+        source = args[0] if args else constructed\n+        return _datatag.AnsibleTagHelper.tag_copy(source, constructed)\n \n \n class _AnsibleUnicode(str):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, str(value))\n+    def __new__(cls, *args, **kwargs):\n+        # Support legacy YAML constructor signatures: object=..., or positional, with optional encoding/errors\n+        obj = kwargs.pop('object', args[0] if args else '')\n+        encoding = kwargs.pop('encoding', None)\n+        errors = kwargs.pop('errors', None)\n+\n+        # Convert to text using Ansible's converter to ensure compatibility\n+        constructed = _converters.to_text(obj, encoding=encoding, errors=errors)\n+\n+        source = args[0] if args else obj\n+        return _datatag.AnsibleTagHelper.tag_copy(source, constructed)\n \n \n class _AnsibleSequence(list):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, list(value))\n+    def __new__(cls, *args):\n+        constructed = list(*args)\n+        source = args[0] if args else constructed\n+        return _datatag.AnsibleTagHelper.tag_copy(source, constructed)\n \n \n class _AnsibleVaultEncryptedUnicode:\ndiff --git a/lib/ansible/template/__init__.py b/lib/ansible/template/__init__.py\nindex 533ea9a..d1e80f3 100644\n--- a/lib/ansible/template/__init__.py\n+++ b/lib/ansible/template/__init__.py\n@@ -159,7 +159,10 @@ class Templar:\n                 version='2.23',\n             )\n \n-        if context_overrides:\n+        # Ignore None-valued overrides to avoid errors when overriding Jinja environment options\n+        filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+\n+        if filtered_overrides:\n             _display.deprecated(\n                 msg='Passing Jinja environment overrides to `copy_with_new_env` is deprecated.',\n                 help_text='Pass Jinja environment overrides to individual `template` calls.',\n@@ -171,7 +174,7 @@ class Templar:\n             variables=self._engine._variables if available_variables is None else available_variables,\n         )\n \n-        templar._overrides = self._overrides.merge(context_overrides)\n+        templar._overrides = self._overrides.merge(filtered_overrides)\n \n         if searchpath is not None:\n             templar._engine.environment.loader.searchpath = searchpath\n@@ -213,7 +216,9 @@ class Templar:\n                     original[key] = getattr(target, key)\n                     setattr(target, key, value)\n \n-            self._overrides = self._overrides.merge(context_overrides)\n+            # Ignore None-valued overrides to avoid errors when overriding Jinja environment options\n+            filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+            self._overrides = self._overrides.merge(filtered_overrides)\n \n             yield\n         finally:\n",
                "diff --git a/lib/ansible/parsing/yaml/objects.py b/lib/ansible/parsing/yaml/objects.py\nindex 1e96fea..93e34c8 100644\n--- a/lib/ansible/parsing/yaml/objects.py\n+++ b/lib/ansible/parsing/yaml/objects.py\n@@ -12,22 +12,35 @@ from ansible.parsing import vault as _vault\n class _AnsibleMapping(dict):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, dict(value))\n+    def __new__(cls, *args, **kwargs):\n+        constructed = dict(*args, **kwargs)\n+        original = args[0] if args else constructed\n+        return _datatag.AnsibleTagHelper.AnsibleTagHelper.tag_copy(original, constructed)\n \n \n class _AnsibleUnicode(str):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, str(value))\n+    def __new__(cls, object: _t.Any = '', encoding: str | None = None, errors: str | None = None):\n+        # Mirror str() constructor semantics:\n+        # - str(object) for non-bytes\n+        # - str(bytes, encoding, errors) when encoding/errors provided\n+        if isinstance(object, (bytes, bytearray)) and (encoding is not None or errors is not None):\n+            constructed = str(object, encoding or 'utf-8', errors or 'strict')\n+        else:\n+            constructed = str(object)\n+\n+        return _datatag.AnsibleTagHelper.tag_copy(object, constructed)\n \n \n class _AnsibleSequence(list):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, list(value))\n+    def __new__(cls, *args):\n+        # Mirror list() constructor semantics: 0 or 1 positional argument\n+        constructed = list(*args)\n+        original = args[0] if args else constructed\n+        return _datatag.AnsibleTagHelper.tag_copy(original, constructed)\n \n \n class _AnsibleVaultEncryptedUnicode:\n@@ -53,4 +66,4 @@ def __getattr__(name: str) -> _t.Any:\n \n         return value\n \n-    raise AttributeError(f'module {__name__!r} has no attribute {name!r}')\n+    raise AttributeError(f'module {__name__!r} has no attribute {name!r}')\ndiff --git a/lib/ansible/plugins/lookup/__init__.py b/lib/ansible/plugins/lookup/__init__.py\nindex 5ee0cb1..9b59e71 100644\n--- a/lib/ansible/plugins/lookup/__init__.py\n+++ b/lib/ansible/plugins/lookup/__init__.py\n@@ -133,13 +133,13 @@ class LookupBase(AnsiblePlugin):\n         result = None\n         try:\n             result = self._loader.path_dwim_relative_stack(paths, subdir, needle, is_role=bool('role_path' in myvars))\n-        except AnsibleFileNotFound:\n+        except AnsibleFileNotFound as exc:\n             if not ignore_missing:\n-                self._display.warning(\"Unable to find '%s' in expected paths (use -vvvvv to see paths)\" % needle)\n+                self._display.warning(\"Unable to find '%s' in expected paths (use -vvvvv to see paths): %s: %s\" % (needle, exc.__class__.__name__, exc))\n \n         return result\n \n     def _deprecate_inline_kv(self):\n         # TODO: place holder to deprecate in future version allowing for long transition period\n         # self._display.deprecated('Passing inline k=v values embedded in a string to this lookup. Use direct ,k=v, k2=v2 syntax instead.', version='2.18')\n-        pass\n+        pass\ndiff --git a/lib/ansible/template/__init__.py b/lib/ansible/template/__init__.py\nindex 533ea9a..80aa4d6 100644\n--- a/lib/ansible/template/__init__.py\n+++ b/lib/ansible/template/__init__.py\n@@ -159,7 +159,10 @@ class Templar:\n                 version='2.23',\n             )\n \n-        if context_overrides:\n+        # Filter out None-valued overrides so passing explicit None does not cause errors\n+        filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+\n+        if filtered_overrides:\n             _display.deprecated(\n                 msg='Passing Jinja environment overrides to `copy_with_new_env` is deprecated.',\n                 help_text='Pass Jinja environment overrides to individual `template` calls.',\n@@ -171,7 +174,7 @@ class Templar:\n             variables=self._engine._variables if available_variables is None else available_variables,\n         )\n \n-        templar._overrides = self._overrides.merge(context_overrides)\n+        templar._overrides = self._overrides.merge(filtered_overrides)\n \n         if searchpath is not None:\n             templar._engine.environment.loader.searchpath = searchpath\n@@ -213,7 +216,9 @@ class Templar:\n                     original[key] = getattr(target, key)\n                     setattr(target, key, value)\n \n-            self._overrides = self._overrides.merge(context_overrides)\n+            # Ignore None-valued overrides to avoid errors when temporarily overriding context\n+            filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+            self._overrides = self._overrides.merge(filtered_overrides)\n \n             yield\n         finally:\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/lib/ansible/parsing/yaml/objects.py b/lib/ansible/parsing/yaml/objects.py\nindex 1e96fea..f91de12 100644\n--- a/lib/ansible/parsing/yaml/objects.py\n+++ b/lib/ansible/parsing/yaml/objects.py\n@@ -12,22 +12,31 @@ from ansible.parsing import vault as _vault\n class _AnsibleMapping(dict):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, dict(value))\n+    def __new__(cls, *args, **kwargs):\n+        # Mirror dict() constructor: allow no args, mapping, iterable of pairs, and kwargs\n+        value = dict(*args, **kwargs)\n+        original = args[0] if args else (kwargs if kwargs else value)\n+        return _datatag.AnsibleTagHelper.tag_copy(original, value)\n \n \n class _AnsibleUnicode(str):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, str(value))\n+    def __new__(cls, *args, **kwargs):\n+        # Mirror str() constructor: allow no args, object=..., or bytes with encoding/errors\n+        value = str(*args, **kwargs)\n+        original = args[0] if args else (kwargs.get('object', value))\n+        return _datatag.AnsibleTagHelper.tag_copy(original, value)\n \n \n class _AnsibleSequence(list):\n     \"\"\"Backwards compatibility type.\"\"\"\n \n-    def __new__(cls, value):\n-        return _datatag.AnsibleTagHelper.tag_copy(value, list(value))\n+    def __new__(cls, *args):\n+        # Mirror list() constructor: allow no args or iterable\n+        value = list(*args)\n+        original = args[0] if args else value\n+        return _datatag.AnsibleTagHelper.tag_copy(original, value)\n \n \n class _AnsibleVaultEncryptedUnicode:\ndiff --git a/lib/ansible/template/__init__.py b/lib/ansible/template/__init__.py\nindex 533ea9a..5c61773 100644\n--- a/lib/ansible/template/__init__.py\n+++ b/lib/ansible/template/__init__.py\n@@ -159,7 +159,9 @@ class Templar:\n                 version='2.23',\n             )\n \n-        if context_overrides:\n+        # Ignore None-valued overrides; only warn if there are effective overrides\n+        filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+        if filtered_overrides:\n             _display.deprecated(\n                 msg='Passing Jinja environment overrides to `copy_with_new_env` is deprecated.',\n                 help_text='Pass Jinja environment overrides to individual `template` calls.',\n@@ -171,7 +173,7 @@ class Templar:\n             variables=self._engine._variables if available_variables is None else available_variables,\n         )\n \n-        templar._overrides = self._overrides.merge(context_overrides)\n+        templar._overrides = self._overrides.merge(filtered_overrides)\n \n         if searchpath is not None:\n             templar._engine.environment.loader.searchpath = searchpath\n@@ -213,7 +215,9 @@ class Templar:\n                     original[key] = getattr(target, key)\n                     setattr(target, key, value)\n \n-            self._overrides = self._overrides.merge(context_overrides)\n+            # Ignore None-valued overrides to prevent errors when temporary overrides include unset values\n+            filtered_overrides = {k: v for k, v in context_overrides.items() if v is not None}\n+            self._overrides = self._overrides.merge(filtered_overrides)\n \n             yield\n         finally:\n"
}