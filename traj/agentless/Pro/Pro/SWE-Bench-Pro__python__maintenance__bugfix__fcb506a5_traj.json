{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__fcb506a5",
    "original_id": "instance_internetarchive__openlibrary-bb152d23c004f3d68986877143bb0f83531fe401-ve8c8d62a2b60610a3c4631f5f23ed866bada9818",
    "1_model_selected_files": [
        "openlibrary/coverstore/archive.py",
        "openlibrary/coverstore/db.py",
        "openlibrary/coverstore/server.py",
        "openlibrary/coverstore/utils.py",
        "openlibrary/coverstore/schema.py"
    ],
    "2_embedding_selected_files": [
        "openlibrary/coverstore/archive.py",
        "openlibrary/coverstore/code.py",
        "openlibrary/coverstore/coverlib.py",
        "openlibrary/plugins/upstream/covers.py",
        "openlibrary/plugins/openlibrary/code.py",
        "openlibrary/catalog/add_book/__init__.py",
        "openlibrary/coverstore/db.py",
        "openlibrary/core/lending.py",
        "openlibrary/catalog/get_ia.py",
        "openlibrary/coverstore/__init__.py",
        "openlibrary/catalog/utils/query.py",
        "openlibrary/plugins/openlibrary/dev_instance.py",
        "openlibrary/coverstore/oldb.py",
        "openlibrary/book_providers.py",
        "openlibrary/plugins/upstream/borrow.py",
        "openlibrary/coverstore/server.py",
        "scripts/store_counts.py",
        "scripts/lc_marc_update.py",
        "openlibrary/plugins/importapi/code.py",
        "openlibrary/coverstore/schema.py",
        "openlibrary/catalog/utils/edit.py",
        "openlibrary/core/ia.py",
        "openlibrary/coverstore/utils.py",
        "openlibrary/plugins/upstream/code.py",
        "openlibrary/core/bookshelves.py",
        "openlibrary/plugins/upstream/data.py",
        "openlibrary/admin/stats.py",
        "openlibrary/utils/lcc.py",
        "openlibrary/plugins/openlibrary/api.py",
        "openlibrary/core/models.py",
        "openlibrary/views/showmarc.py",
        "openlibrary/plugins/upstream/models.py",
        "scripts/partner_batch_imports.py",
        "openlibrary/plugins/books/code.py",
        "scripts/affiliate_server.py",
        "openlibrary/plugins/upstream/account.py",
        "openlibrary/plugins/ol_infobase.py",
        "scripts/manage-imports.py",
        "openlibrary/solr/update_work.py",
        "openlibrary/accounts/model.py",
        "openlibrary/api.py",
        "openlibrary/data/dump.py",
        "scripts/mail_bad_author_query.py",
        "scripts/promise_batch_imports.py",
        "openlibrary/plugins/openlibrary/connection.py",
        "openlibrary/core/sponsorships.py",
        "scripts/sponsor_update_prices.py",
        "openlibrary/core/imports.py",
        "scripts/copydocs.py",
        "openlibrary/solr/data_provider.py",
        "openlibrary/plugins/books/readlinks.py",
        "openlibrary/solr/db_load_authors.py",
        "scripts/import_standard_ebooks.py",
        "openlibrary/admin/numbers.py",
        "openlibrary/coverstore/disk.py",
        "openlibrary/mocks/mock_infobase.py"
    ],
    "3_final_combined_files": [
        "openlibrary/coverstore/archive.py",
        "openlibrary/coverstore/db.py",
        "openlibrary/coverstore/server.py",
        "openlibrary/coverstore/code.py",
        "openlibrary/coverstore/coverlib.py"
    ],
    "4_related_elements": {
        "openlibrary/coverstore/archive.py": [
            "function: log\nclass: TarManager\nvariable: idx\nfunction: is_uploaded\nfunction: audit\nfunction: archive"
        ],
        "openlibrary/coverstore/db.py": [
            "variable: _categories\nvariable: _db\nfunction: getdb\nfunction: get_category_id\nfunction: new\nfunction: query\nfunction: details\nfunction: touch\nfunction: delete\nfunction: get_filename"
        ],
        "openlibrary/coverstore/server.py": [
            "function: runfcgi\nfunction: load_config\nfunction: setup\nfunction: main"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "openlibrary/coverstore/archive.py": [
                    "class: TarManager\nfunction: is_uploaded\nline: 102\nfunction: audit\nfunction: archive\nline: 149\nline: 204\nline: 205\nline: 206\nline: 207\nline: 208\nline: 209\nline: 210\nline: 211\nline: 212\nline: 82"
                ],
                "openlibrary/coverstore/server.py": [
                    "function: main\nline: 52"
                ],
                "openlibrary/coverstore/db.py": [
                    "function: new\nfunction: delete\nline: 135"
                ]
            },
            "patches": [
                "diff --git a/openlibrary/coverstore/archive.py b/openlibrary/coverstore/archive.py\nindex 35bf894..0bf7094 100644\n--- a/openlibrary/coverstore/archive.py\n+++ b/openlibrary/coverstore/archive.py\n@@ -99,10 +99,16 @@ def is_uploaded(item: str, filename_pattern: str) -> bool:\n     :param item: name of archive.org item to look within\n     :param filename_pattern: filename pattern to look for\n     \"\"\"\n-    command = fr'ia list {item} | grep \"{filename_pattern}\\.[tar|index]\" | wc -l'\n+    # Expect exactly two files: <pattern>.tar and <pattern>.index\n+    # Use grep -E with an anchored pattern to avoid partial matches.\n+    command = fr'ia list {item} | grep -E \"^{filename_pattern}\\.(tar|index)$\" | wc -l'\n     result = run(command, shell=True, text=True, capture_output=True, check=True)\n     output = result.stdout.strip()\n-    return int(output) == 2\n+    try:\n+        count = int(output)\n+    except ValueError:\n+        count = 0\n+    return count == 2\n \n \n def audit(group_id, chunk_ids=(0, 100), sizes=('', 's', 'm', 'l')) -> None:\n@@ -142,6 +148,13 @@ def audit(group_id, chunk_ids=(0, 100), sizes=('', 's', 'm', 'l')) -> None:\n \n def archive(test=True):\n     \"\"\"Move files from local disk to tar files and update the paths in the db.\"\"\"\n+    # Simple concurrency control: global lock to prevent overlapping archival runs.\n+    lock_path = os.path.join(config.data_root, \"archive.lock\")\n+    if os.path.exists(lock_path):\n+        raise RuntimeError(f\"Another archival process is already running (lock: {lock_path}).\")\n+    with open(lock_path, \"w\") as _lockf:\n+        _lockf.write(str(os.getpid()))\n+\n     tar_manager = TarManager()\n \n     _db = db.getdb()\n@@ -201,15 +214,16 @@ def archive(test=True):\n                 )\n \n             if not test:\n+                # Update only if not already archived to be idempotent\n                 _db.update(\n                     'cover',\n-                    where=\"id=$cover.id\",\n+                    where=\"id=$cover.id AND archived=$f\",\n                     archived=True,\n                     filename=files['filename'].newname,\n                     filename_s=files['filename_s'].newname,\n                     filename_m=files['filename_m'].newname,\n                     filename_l=files['filename_l'].newname,\n-                    vars=locals(),\n+                    vars={'cover': cover, 'f': False},\n                 )\n \n                 for d in files.values():\n@@ -218,4 +232,8 @@ def archive(test=True):\n \n     finally:\n         # logfile.close()\n-        tar_manager.close()\n+        tar_manager.close()\n+        try:\n+            os.remove(lock_path)\n+        except OSError:\n+            pass\ndiff --git a/openlibrary/coverstore/db.py b/openlibrary/coverstore/db.py\nindex d4e2d6a..df90202 100644\n--- a/openlibrary/coverstore/db.py\n+++ b/openlibrary/coverstore/db.py\n@@ -133,7 +133,7 @@ def delete(id):\n     t = db.transaction()\n     try:\n         db.query(\n-            'UPDATE cover set deleted=$true AND last_modified=$now WHERE id=$id',\n+            'UPDATE cover set deleted=$true, last_modified=$now WHERE id=$id',\n             vars=locals(),\n         )\n         db.insert(\"log\", action=\"delete\", timestamp=now, cover_id=id)\ndiff --git a/openlibrary/coverstore/server.py b/openlibrary/coverstore/server.py\nindex 72f4693..18af815 100644\n--- a/openlibrary/coverstore/server.py\n+++ b/openlibrary/coverstore/server.py\n@@ -49,11 +49,12 @@ def main(configfile, *args):\n     setup(configfile)\n \n     if '--archive' in args:\n-        archive.archive()\n+        # Run archival in non-test mode so database paths are updated and local files removed\n+        archive.archive(test=False)\n     else:\n         sys.argv = [sys.argv[0]] + list(args)\n         code.app.run()\n \n \n if __name__ == \"__main__\":\n-    main(*sys.argv[1:])\n+    main(*sys.argv[1:])\n",
                "diff --git a/openlibrary/coverstore/archive.py b/openlibrary/coverstore/archive.py\nindex 35bf894..97023fd 100644\n--- a/openlibrary/coverstore/archive.py\n+++ b/openlibrary/coverstore/archive.py\n@@ -42,7 +42,9 @@ class TarManager:\n \n         _tarname, _tarfile, _indexfile = self.tarfiles[size.upper()]\n         if _tarname != tarname:\n-            _tarname and _tarfile.close()\n+            if _tarname:\n+                _tarfile.close()\n+                _indexfile.close()\n             _tarfile, _indexfile = self.open_tarfile(tarname)\n             self.tarfiles[size.upper()] = tarname, _tarfile, _indexfile\n             log('writing', tarname)\n@@ -56,7 +58,6 @@ class TarManager:\n             os.makedirs(dir)\n \n         indexpath = path.replace('.tar', '.index')\n-        print(indexpath, os.path.exists(path))\n         mode = 'a' if os.path.exists(path) else 'w'\n         # Need USTAR since that used to be the default in Py2\n         return tarfile.TarFile(path, mode, format=tarfile.USTAR_FORMAT), open(\n@@ -99,10 +100,16 @@ def is_uploaded(item: str, filename_pattern: str) -> bool:\n     :param item: name of archive.org item to look within\n     :param filename_pattern: filename pattern to look for\n     \"\"\"\n-    command = fr'ia list {item} | grep \"{filename_pattern}\\.[tar|index]\" | wc -l'\n-    result = run(command, shell=True, text=True, capture_output=True, check=True)\n-    output = result.stdout.strip()\n-    return int(output) == 2\n+    # Ensure we match exactly the tar and index files for the given pattern\n+    # Using egrep alternation instead of a character class and anchoring\n+    command = fr'ia list \"{item}\" | egrep -E \"^{filename_pattern}\\.(tar|index)$\" | wc -l'\n+    try:\n+        result = run(command, shell=True, text=True, capture_output=True, check=False)\n+        output = result.stdout.strip()\n+        return output.isdigit() and int(output) == 2\n+    except Exception:\n+        # If listing fails, assume not uploaded\n+        return False\n \n \n def audit(group_id, chunk_ids=(0, 100), sizes=('', 's', 'm', 'l')) -> None:\n@@ -146,7 +153,19 @@ def archive(test=True):\n \n     _db = db.getdb()\n \n+    # Concurrency control: simple file-based lock to prevent overlapping runs\n+    lock_path = os.path.join(config.data_root, \"archive.lock\")\n+    created_lock = False\n     try:\n+        try:\n+            fd = os.open(lock_path, os.O_CREAT | os.O_EXCL | os.O_WRONLY)\n+            os.write(fd, str(os.getpid()).encode(\"utf-8\"))\n+            os.close(fd)\n+            created_lock = True\n+        except FileExistsError:\n+            print(\"Another archive process is already running; exiting.\", file=web.debug)\n+            return\n+\n         covers = _db.select(\n             'cover',\n             # IDs before this are legacy and not in the right format this script\n@@ -217,5 +236,11 @@ def archive(test=True):\n                     os.remove(d.path)\n \n     finally:\n-        # logfile.close()\n-        tar_manager.close()\n+        # logfile close\n+        tar_manager.close()\n+        # Release concurrency lock if we created it\n+        if created_lock and os.path.exists(lock_path):\n+            try:\n+                os.unlink(lock_path)\n+            except Exception:\n+                pass\ndiff --git a/openlibrary/coverstore/db.py b/openlibrary/coverstore/db.py\nindex d4e2d6a..5519ebe 100644\n--- a/openlibrary/coverstore/db.py\n+++ b/openlibrary/coverstore/db.py\n@@ -133,7 +133,7 @@ def delete(id):\n     t = db.transaction()\n     try:\n         db.query(\n-            'UPDATE cover set deleted=$true AND last_modified=$now WHERE id=$id',\n+            'UPDATE cover set deleted=$true, last_modified=$now WHERE id=$id',\n             vars=locals(),\n         )\n         db.insert(\"log\", action=\"delete\", timestamp=now, cover_id=id)\n@@ -146,4 +146,4 @@ def delete(id):\n \n def get_filename(id):\n     d = getdb().select('cover', what='filename', where='id=$id', vars=locals())\n-    return d and d[0].filename or None\n+    return d and d[0].filename or None\ndiff --git a/openlibrary/coverstore/server.py b/openlibrary/coverstore/server.py\nindex 72f4693..8219c02 100644\n--- a/openlibrary/coverstore/server.py\n+++ b/openlibrary/coverstore/server.py\n@@ -49,11 +49,12 @@ def main(configfile, *args):\n     setup(configfile)\n \n     if '--archive' in args:\n-        archive.archive()\n+        # Run archival in non-test mode so database records are updated\n+        archive.archive(test=False)\n     else:\n         sys.argv = [sys.argv[0]] + list(args)\n         code.app.run()\n \n \n if __name__ == \"__main__\":\n-    main(*sys.argv[1:])\n+    main(*sys.argv[1:])\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "openlibrary/coverstore/server.py": [
                    "line: 52"
                ],
                "openlibrary/coverstore/archive.py": [
                    "function: archive\nline: 143\nline: 150\nline: 151\nline: 158\nfunction: is_uploaded\nline: 102\nline: 103\nline: 105\nfunction: TarManager.open_tarfile\nline: 53\nline: 59\nfunction: TarManager.add_file\nline: 82\nline: 91"
                ],
                "openlibrary/coverstore/db.py": [
                    "function: delete\nline: 135\nline: 137"
                ]
            },
            "patches": [
                "diff --git a/openlibrary/coverstore/archive.py b/openlibrary/coverstore/archive.py\nindex 35bf894..9256310 100644\n--- a/openlibrary/coverstore/archive.py\n+++ b/openlibrary/coverstore/archive.py\n@@ -50,18 +50,23 @@ class TarManager:\n         return _tarfile, _indexfile\n \n     def open_tarfile(self, name):\n-        path = os.path.join(config.data_root, \"items\", name[: -len(\"_XX.tar\")], name)\n+        import re\n+        # Derive the item directory from the tar filename:\n+        # {prefix_}covers_{group}_{chunk}.tar -> {prefix_}covers_{group}\n+        m = re.match(r'^(?:(?P<size>[sml])_)?covers_(?P<group>\\d{4})_(?P<chunk>\\d{2})\\.tar$', name, re.IGNORECASE)\n+        if not m:\n+            raise ValueError(f\"Unexpected tar filename: {name}\")\n+        size = m.group('size')\n+        item_dir = f\"{size.lower()}_covers_{m.group('group')}\" if size else f\"covers_{m.group('group')}\"\n+        path = os.path.join(config.data_root, \"items\", item_dir, name)\n         dir = os.path.dirname(path)\n         if not os.path.exists(dir):\n             os.makedirs(dir)\n \n         indexpath = path.replace('.tar', '.index')\n-        print(indexpath, os.path.exists(path))\n         mode = 'a' if os.path.exists(path) else 'w'\n         # Need USTAR since that used to be the default in Py2\n-        return tarfile.TarFile(path, mode, format=tarfile.USTAR_FORMAT), open(\n-            indexpath, mode\n-        )\n+        return tarfile.TarFile(path, mode, format=tarfile.USTAR_FORMAT), open(indexpath, mode)\n \n     def add_file(self, name, filepath, mtime):\n         with open(filepath, 'rb') as fileobj:\n@@ -99,10 +104,14 @@ def is_uploaded(item: str, filename_pattern: str) -> bool:\n     :param item: name of archive.org item to look within\n     :param filename_pattern: filename pattern to look for\n     \"\"\"\n-    command = fr'ia list {item} | grep \"{filename_pattern}\\.[tar|index]\" | wc -l'\n-    result = run(command, shell=True, text=True, capture_output=True, check=True)\n-    output = result.stdout.strip()\n-    return int(output) == 2\n+    command = fr'ia list {item} | grep -E \"{filename_pattern}\\.(tar|index)$\" | wc -l'\n+    try:\n+        result = run(command, shell=True, text=True, capture_output=True, check=True)\n+        output = result.stdout.strip()\n+        return int(output) == 2\n+    except Exception as e:\n+        log(f\"Validation error for item {item}: {e}\")\n+        return False\n \n \n def audit(group_id, chunk_ids=(0, 100), sizes=('', 's', 'm', 'l')) -> None:\n@@ -142,11 +151,17 @@ def audit(group_id, chunk_ids=(0, 100), sizes=('', 's', 'm', 'l')) -> None:\n \n def archive(test=True):\n     \"\"\"Move files from local disk to tar files and update the paths in the db.\"\"\"\n+    import fcntl\n     tar_manager = TarManager()\n \n     _db = db.getdb()\n \n+    # Prevent concurrent archival runs from overlapping\n+    lock_path = os.path.join(config.data_root, \"archive.lock\")\n+    lock_file = open(lock_path, \"a+\")\n     try:\n+        fcntl.lockf(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)\n+\n         covers = _db.select(\n             'cover',\n             # IDs before this are legacy and not in the right format this script\n@@ -216,6 +231,13 @@ def archive(test=True):\n                     print('removing', d.path)\n                     os.remove(d.path)\n \n+    except IOError:\n+        log(\"Another archival process is running; exiting to avoid overlap.\")\n+        return\n     finally:\n         # logfile.close()\n-        tar_manager.close()\n+        tar_manager.close()\n+        try:\n+            fcntl.lockf(lock_file, fcntl.LOCK_UN)\n+        finally:\n+            lock_file.close()\ndiff --git a/openlibrary/coverstore/db.py b/openlibrary/coverstore/db.py\nindex d4e2d6a..08739ef 100644\n--- a/openlibrary/coverstore/db.py\n+++ b/openlibrary/coverstore/db.py\n@@ -133,7 +133,7 @@ def delete(id):\n     t = db.transaction()\n     try:\n         db.query(\n-            'UPDATE cover set deleted=$true AND last_modified=$now WHERE id=$id',\n+            'UPDATE cover SET deleted=$true, last_modified=$now WHERE id=$id',\n             vars=locals(),\n         )\n         db.insert(\"log\", action=\"delete\", timestamp=now, cover_id=id)\ndiff --git a/openlibrary/coverstore/server.py b/openlibrary/coverstore/server.py\nindex 72f4693..5c8e473 100644\n--- a/openlibrary/coverstore/server.py\n+++ b/openlibrary/coverstore/server.py\n@@ -49,11 +49,11 @@ def main(configfile, *args):\n     setup(configfile)\n \n     if '--archive' in args:\n-        archive.archive()\n+        archive.archive(test=False)\n     else:\n         sys.argv = [sys.argv[0]] + list(args)\n         code.app.run()\n \n \n if __name__ == \"__main__\":\n-    main(*sys.argv[1:])\n+    main(*sys.argv[1:])\n",
                "diff --git a/openlibrary/coverstore/archive.py b/openlibrary/coverstore/archive.py\nindex 35bf894..fd1a8ad 100644\n--- a/openlibrary/coverstore/archive.py\n+++ b/openlibrary/coverstore/archive.py\n@@ -56,7 +56,6 @@ class TarManager:\n             os.makedirs(dir)\n \n         indexpath = path.replace('.tar', '.index')\n-        print(indexpath, os.path.exists(path))\n         mode = 'a' if os.path.exists(path) else 'w'\n         # Need USTAR since that used to be the default in Py2\n         return tarfile.TarFile(path, mode, format=tarfile.USTAR_FORMAT), open(\n@@ -99,7 +98,7 @@ def is_uploaded(item: str, filename_pattern: str) -> bool:\n     :param item: name of archive.org item to look within\n     :param filename_pattern: filename pattern to look for\n     \"\"\"\n-    command = fr'ia list {item} | grep \"{filename_pattern}\\.[tar|index]\" | wc -l'\n+    command = fr'ia list {item} | egrep \"{filename_pattern}\\.(tar|index)$\" | wc -l'\n     result = run(command, shell=True, text=True, capture_output=True, check=True)\n     output = result.stdout.strip()\n     return int(output) == 2\n@@ -142,6 +141,18 @@ def audit(group_id, chunk_ids=(0, 100), sizes=('', 's', 'm', 'l')) -> None:\n \n def archive(test=True):\n     \"\"\"Move files from local disk to tar files and update the paths in the db.\"\"\"\n+    # Prevent overlapping archival runs by using a lock file when performing a real archive.\n+    lock_fd = None\n+    lock_path = os.path.join(config.data_root, \"archive.lock\")\n+    try:\n+        if not test:\n+            # Atomically create the lock file; fail if it already exists.\n+            lock_fd = os.open(lock_path, os.O_CREAT | os.O_EXCL | os.O_WRONLY)\n+            os.write(lock_fd, f\"{os.getpid()}\\n\".encode(\"utf-8\"))\n+    except FileExistsError:\n+        print(f\"Archive already in progress. Lock file exists at: {lock_path}\")\n+        return\n+\n     tar_manager = TarManager()\n \n     _db = db.getdb()\n@@ -218,4 +229,13 @@ def archive(test=True):\n \n     finally:\n         # logfile.close()\n-        tar_manager.close()\n+        tar_manager.close()\n+        if lock_fd is not None:\n+            try:\n+                os.close(lock_fd)\n+            except Exception:\n+                pass\n+            try:\n+                os.remove(lock_path)\n+            except Exception:\n+                pass\ndiff --git a/openlibrary/coverstore/db.py b/openlibrary/coverstore/db.py\nindex d4e2d6a..5519ebe 100644\n--- a/openlibrary/coverstore/db.py\n+++ b/openlibrary/coverstore/db.py\n@@ -133,7 +133,7 @@ def delete(id):\n     t = db.transaction()\n     try:\n         db.query(\n-            'UPDATE cover set deleted=$true AND last_modified=$now WHERE id=$id',\n+            'UPDATE cover set deleted=$true, last_modified=$now WHERE id=$id',\n             vars=locals(),\n         )\n         db.insert(\"log\", action=\"delete\", timestamp=now, cover_id=id)\n@@ -146,4 +146,4 @@ def delete(id):\n \n def get_filename(id):\n     d = getdb().select('cover', what='filename', where='id=$id', vars=locals())\n-    return d and d[0].filename or None\n+    return d and d[0].filename or None\ndiff --git a/openlibrary/coverstore/server.py b/openlibrary/coverstore/server.py\nindex 72f4693..5c8e473 100644\n--- a/openlibrary/coverstore/server.py\n+++ b/openlibrary/coverstore/server.py\n@@ -49,11 +49,11 @@ def main(configfile, *args):\n     setup(configfile)\n \n     if '--archive' in args:\n-        archive.archive()\n+        archive.archive(test=False)\n     else:\n         sys.argv = [sys.argv[0]] + list(args)\n         code.app.run()\n \n \n if __name__ == \"__main__\":\n-    main(*sys.argv[1:])\n+    main(*sys.argv[1:])\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/openlibrary/coverstore/archive.py b/openlibrary/coverstore/archive.py\nindex 35bf894..0bf7094 100644\n--- a/openlibrary/coverstore/archive.py\n+++ b/openlibrary/coverstore/archive.py\n@@ -99,10 +99,16 @@ def is_uploaded(item: str, filename_pattern: str) -> bool:\n     :param item: name of archive.org item to look within\n     :param filename_pattern: filename pattern to look for\n     \"\"\"\n-    command = fr'ia list {item} | grep \"{filename_pattern}\\.[tar|index]\" | wc -l'\n+    # Expect exactly two files: <pattern>.tar and <pattern>.index\n+    # Use grep -E with an anchored pattern to avoid partial matches.\n+    command = fr'ia list {item} | grep -E \"^{filename_pattern}\\.(tar|index)$\" | wc -l'\n     result = run(command, shell=True, text=True, capture_output=True, check=True)\n     output = result.stdout.strip()\n-    return int(output) == 2\n+    try:\n+        count = int(output)\n+    except ValueError:\n+        count = 0\n+    return count == 2\n \n \n def audit(group_id, chunk_ids=(0, 100), sizes=('', 's', 'm', 'l')) -> None:\n@@ -142,6 +148,13 @@ def audit(group_id, chunk_ids=(0, 100), sizes=('', 's', 'm', 'l')) -> None:\n \n def archive(test=True):\n     \"\"\"Move files from local disk to tar files and update the paths in the db.\"\"\"\n+    # Simple concurrency control: global lock to prevent overlapping archival runs.\n+    lock_path = os.path.join(config.data_root, \"archive.lock\")\n+    if os.path.exists(lock_path):\n+        raise RuntimeError(f\"Another archival process is already running (lock: {lock_path}).\")\n+    with open(lock_path, \"w\") as _lockf:\n+        _lockf.write(str(os.getpid()))\n+\n     tar_manager = TarManager()\n \n     _db = db.getdb()\n@@ -201,15 +214,16 @@ def archive(test=True):\n                 )\n \n             if not test:\n+                # Update only if not already archived to be idempotent\n                 _db.update(\n                     'cover',\n-                    where=\"id=$cover.id\",\n+                    where=\"id=$cover.id AND archived=$f\",\n                     archived=True,\n                     filename=files['filename'].newname,\n                     filename_s=files['filename_s'].newname,\n                     filename_m=files['filename_m'].newname,\n                     filename_l=files['filename_l'].newname,\n-                    vars=locals(),\n+                    vars={'cover': cover, 'f': False},\n                 )\n \n                 for d in files.values():\n@@ -218,4 +232,8 @@ def archive(test=True):\n \n     finally:\n         # logfile.close()\n-        tar_manager.close()\n+        tar_manager.close()\n+        try:\n+            os.remove(lock_path)\n+        except OSError:\n+            pass\ndiff --git a/openlibrary/coverstore/db.py b/openlibrary/coverstore/db.py\nindex d4e2d6a..df90202 100644\n--- a/openlibrary/coverstore/db.py\n+++ b/openlibrary/coverstore/db.py\n@@ -133,7 +133,7 @@ def delete(id):\n     t = db.transaction()\n     try:\n         db.query(\n-            'UPDATE cover set deleted=$true AND last_modified=$now WHERE id=$id',\n+            'UPDATE cover set deleted=$true, last_modified=$now WHERE id=$id',\n             vars=locals(),\n         )\n         db.insert(\"log\", action=\"delete\", timestamp=now, cover_id=id)\ndiff --git a/openlibrary/coverstore/server.py b/openlibrary/coverstore/server.py\nindex 72f4693..18af815 100644\n--- a/openlibrary/coverstore/server.py\n+++ b/openlibrary/coverstore/server.py\n@@ -49,11 +49,12 @@ def main(configfile, *args):\n     setup(configfile)\n \n     if '--archive' in args:\n-        archive.archive()\n+        # Run archival in non-test mode so database paths are updated and local files removed\n+        archive.archive(test=False)\n     else:\n         sys.argv = [sys.argv[0]] + list(args)\n         code.app.run()\n \n \n if __name__ == \"__main__\":\n-    main(*sys.argv[1:])\n+    main(*sys.argv[1:])\n"
}