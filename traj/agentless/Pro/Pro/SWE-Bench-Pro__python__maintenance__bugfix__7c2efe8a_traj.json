{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__7c2efe8a",
    "original_id": "instance_internetarchive__openlibrary-e1e502986a3b003899a8347ac8a7ff7b08cbfc39-v08d8e8889ec945ab821fb156c04c7d2e2810debb",
    "1_model_selected_files": [
        "openlibrary/plugins/upstream/table_of_contents.py",
        "openlibrary/plugins/upstream/forms.py",
        "openlibrary/core/olmarkdown.py",
        "openlibrary/plugins/openlibrary/design.py",
        "openlibrary/plugins/upstream/edits.py"
    ],
    "2_embedding_selected_files": [
        "openlibrary/plugins/upstream/table_of_contents.py",
        "openlibrary/catalog/marc/parse.py",
        "openlibrary/plugins/upstream/addbook.py",
        "openlibrary/catalog/utils/edit.py",
        "openlibrary/plugins/upstream/addtag.py",
        "openlibrary/catalog/add_book/__init__.py",
        "openlibrary/core/olmarkdown.py",
        "openlibrary/plugins/upstream/merge_authors.py",
        "openlibrary/plugins/upstream/code.py",
        "openlibrary/plugins/admin/code.py",
        "openlibrary/core/sponsorships.py",
        "openlibrary/plugins/upstream/edits.py",
        "openlibrary/plugins/upstream/models.py",
        "openlibrary/plugins/upstream/mybooks.py",
        "openlibrary/plugins/openlibrary/opds.py",
        "openlibrary/plugins/openlibrary/home.py",
        "openlibrary/plugins/openlibrary/events.py",
        "openlibrary/solr/updater/work.py",
        "openlibrary/plugins/openlibrary/dev_instance.py",
        "openlibrary/core/bookshelves.py",
        "openlibrary/core/observations.py",
        "openlibrary/plugins/upstream/covers.py",
        "openlibrary/plugins/upstream/utils.py",
        "openlibrary/plugins/upstream/checkins.py",
        "openlibrary/plugins/books/dynlinks.py",
        "openlibrary/core/edits.py",
        "openlibrary/core/booknotes.py",
        "openlibrary/plugins/upstream/account.py",
        "openlibrary/plugins/books/readlinks.py",
        "openlibrary/catalog/add_book/match.py",
        "openlibrary/catalog/utils/__init__.py",
        "openlibrary/views/showmarc.py",
        "scripts/detect_missing_i18n.py",
        "openlibrary/plugins/importapi/code.py",
        "openlibrary/utils/lcc.py",
        "openlibrary/plugins/upstream/borrow.py",
        "openlibrary/plugins/openlibrary/lists.py",
        "openlibrary/core/models.py",
        "openlibrary/plugins/openlibrary/code.py",
        "openlibrary/plugins/importapi/import_edition_builder.py",
        "openlibrary/plugins/openlibrary/support.py",
        "openlibrary/solr/updater/edition.py",
        "openlibrary/plugins/worksearch/autocomplete.py",
        "openlibrary/plugins/openlibrary/bulk_tag.py",
        "openlibrary/i18n/__init__.py",
        "openlibrary/plugins/importapi/metaxml_to_json.py"
    ],
    "3_final_combined_files": [
        "openlibrary/plugins/upstream/table_of_contents.py",
        "openlibrary/plugins/upstream/forms.py",
        "openlibrary/core/olmarkdown.py",
        "openlibrary/catalog/marc/parse.py",
        "openlibrary/plugins/upstream/addbook.py"
    ],
    "4_related_elements": {
        "openlibrary/plugins/upstream/table_of_contents.py": [
            "class: TableOfContents\nclass: TocEntry\nclass: AuthorRecord\nvariable: T\nfunction: pad"
        ],
        "openlibrary/core/olmarkdown.py": [
            "variable: AUTOLINK_RE\nvariable: LINK_REFERENCE_RE\nclass: LineBreaksPreprocessor\nvariable: LINE_BREAKS_PREPROCESSOR\nclass: AutolinkPreprocessor\nvariable: AUTOLINK_PREPROCESSOR\nclass: OLMarkdown"
        ],
        "openlibrary/plugins/upstream/forms.py": [
            ""
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "openlibrary/plugins/upstream/table_of_contents.py": [
                    "function: TableOfContents.from_markdown\nfunction: TableOfContents.to_markdown\nfunction: TocEntry.from_markdown\nfunction: TocEntry.to_markdown\nfunction: TocEntry.is_empty"
                ],
                "openlibrary/core/olmarkdown.py": [
                    "function: LineBreaksPreprocessor.run"
                ],
                "openlibrary/plugins/upstream/forms.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 21983d3..9b92c24 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -34,11 +34,17 @@ class TableOfContents:\n \n     @staticmethod\n     def from_markdown(text: str) -> 'TableOfContents':\n+        # Build entries from markdown, skipping lines that are effectively empty\n+        # (only spaces, pipes, or asterisks) and filtering out empty entries.\n         return TableOfContents(\n             [\n-                TocEntry.from_markdown(line)\n-                for line in text.splitlines()\n-                if line.strip(\" |\")\n+                entry\n+                for entry in (\n+                    TocEntry.from_markdown(line)\n+                    for line in text.splitlines()\n+                    if line.strip(\" *|\")\n+                )\n+                if not entry.is_empty()\n             ]\n         )\n \n@@ -100,22 +106,75 @@ class TocEntry:\n         RE_LEVEL = web.re_compile(r\"(\\**)(.*)\")\n         level, text = RE_LEVEL.match(line.strip()).groups()\n \n+        # Initialize defaults\n+        label = \"\"\n+        title = \"\"\n+        page = \"\"\n+        authors = None\n+        subtitle = None\n+        description = None\n+\n         if \"|\" in text:\n-            tokens = text.split(\"|\", 2)\n-            label, title, page = pad(tokens, 3, '')\n+            # Allow an optional metadata segment after the first three fields.\n+            tokens = [t.strip() for t in text.split(\"|\", 3)]\n+            label, title, page, extra = pad(tokens, 4, '')\n+            if extra:\n+                # Try parsing extended metadata as JSON for lossless round-tripping.\n+                try:\n+                    import json\n+                    meta_obj = json.loads(extra)\n+                    if isinstance(meta_obj, dict):\n+                        authors = meta_obj.get('authors')\n+                        subtitle = meta_obj.get('subtitle')\n+                        description = meta_obj.get('description')\n+                except Exception:\n+                    # Fallback: treat extra as pipe-separated positional fields:\n+                    # authors; subtitle; description\n+                    extras = [t.strip() for t in extra.split(\"|\")]\n+                    if len(extras) >= 1 and extras[0]:\n+                        # authors as semicolon-separated names\n+                        names = [n.strip() for n in extras[0].split(';') if n.strip()]\n+                        authors = names or extras[0].strip()\n+                    if len(extras) >= 2 and extras[1]:\n+                        subtitle = extras[1]\n+                    if len(extras) >= 3 and extras[2]:\n+                        description = extras[2]\n         else:\n-            title = text\n-            label = page = \"\"\n+            title = text.strip()\n \n         return TocEntry(\n             level=len(level),\n-            label=label.strip() or None,\n-            title=title.strip() or None,\n-            pagenum=page.strip() or None,\n+            label=label or None,\n+            title=title or None,\n+            pagenum=page or None,\n+            authors=authors,\n+            subtitle=subtitle,\n+            description=description,\n         )\n \n     def to_markdown(self) -> str:\n-        return f\"{'*' * self.level} {self.label or ''} | {self.title or ''} | {self.pagenum or ''}\"\n+        # Build the base representation, normalizing indentation and spacing.\n+        prefix = f\"{'*' * self.level + ' ' if self.level else ''}\"\n+        label = self.label or ''\n+        title = self.title or ''\n+        page = self.pagenum or ''\n+        # Use pipe-separated format when level > 0 or when a label/page is present.\n+        if self.level or self.label is not None or self.pagenum is not None:\n+            base = f\"{label} | {title} | {page}\"\n+        else:\n+            base = title\n+        # Append extended metadata as JSON if present.\n+        meta = {}\n+        if getattr(self, 'authors', None) is not None:\n+            meta['authors'] = self.authors\n+        if getattr(self, 'subtitle', None) is not None:\n+            meta['subtitle'] = self.subtitle\n+        if getattr(self, 'description', None) is not None:\n+            meta['description'] = self.description\n+        if meta:\n+            import json\n+            base = f\"{base} | {json.dumps(meta, ensure_ascii=False)}\"\n+        return f\"{prefix}{base}\".rstrip()\n \n     def is_empty(self) -> bool:\n         return all(\n",
                "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 21983d3..7a0c307 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -97,25 +97,96 @@ class TocEntry:\n         >>> f(\"1.1 | Apple\")\n         (0, '1.1', 'Apple', None)\n         \"\"\"\n+        import json\n         RE_LEVEL = web.re_compile(r\"(\\**)(.*)\")\n-        level, text = RE_LEVEL.match(line.strip()).groups()\n+        RE_META = web.re_compile(r\"^(.*?)(?:\\s*<!--\\s*(?:toc:)?\\s*(\\{.*\\})\\s*-->\\s*)?$\")\n+\n+        stripped = line.strip()\n+        m_meta = RE_META.match(stripped)\n+        if m_meta:\n+            core_text = m_meta.group(1).strip()\n+            meta_json = m_meta.group(2)\n+        else:\n+            core_text = stripped\n+            meta_json = None\n+\n+        level, text = RE_LEVEL.match(core_text).groups()\n+\n+        authors = None\n+        subtitle = None\n+        description = None\n \n         if \"|\" in text:\n-            tokens = text.split(\"|\", 2)\n-            label, title, page = pad(tokens, 3, '')\n+            # Allow optional 4th token for metadata JSON\n+            tokens = text.split(\"|\", 3)\n+            label, title, page = pad(tokens[:3], 3, '')\n+            extra = tokens[3].strip() if len(tokens) > 3 else ''\n+            if extra:\n+                try:\n+                    meta = json.loads(extra)\n+                    authors = meta.get('authors')\n+                    subtitle = meta.get('subtitle')\n+                    description = meta.get('description')\n+                except Exception:\n+                    # Ignore unparsable extra metadata\n+                    pass\n         else:\n             title = text\n             label = page = \"\"\n \n+        # Trailing HTML comment metadata takes precedence if present\n+        if meta_json:\n+            try:\n+                meta = json.loads(meta_json)\n+                authors = meta.get('authors', authors)\n+                subtitle = meta.get('subtitle', subtitle)\n+                description = meta.get('description', description)\n+            except Exception:\n+                # Ignore unparsable comment metadata\n+                pass\n+\n         return TocEntry(\n             level=len(level),\n             label=label.strip() or None,\n             title=title.strip() or None,\n             pagenum=page.strip() or None,\n+            authors=authors,\n+            subtitle=subtitle,\n+            description=description,\n         )\n \n     def to_markdown(self) -> str:\n-        return f\"{'*' * self.level} {self.label or ''} | {self.title or ''} | {self.pagenum or ''}\"\n+        # Build the core text with minimal, readable fields\n+        if self.label is None and self.pagenum is None:\n+            core = f\"{self.title or ''}\".strip()\n+        elif self.label is None:\n+            core = f\"| {self.title or ''} | {self.pagenum or ''}\".strip()\n+        elif self.pagenum is None:\n+            core = f\"{self.label or ''} | {self.title or ''}\".strip()\n+        else:\n+            core = f\"{self.label or ''} | {self.title or ''} | {self.pagenum or ''}\".strip()\n+\n+        prefix = ('*' * self.level + ' ') if self.level > 0 else ''\n+\n+        # Preserve extended metadata in an HTML comment so it round-trips without cluttering UI\n+        meta: dict = {}\n+        if self.authors is not None:\n+            meta['authors'] = self.authors\n+        if self.subtitle is not None:\n+            meta['subtitle'] = self.subtitle\n+        if self.description is not None:\n+            meta['description'] = self.description\n+\n+        if meta:\n+            try:\n+                import json\n+                meta_str = json.dumps(meta, separators=(',', ':'))\n+                return f\"{prefix}{core} <!-- toc: {meta_str} -->\"\n+            except Exception:\n+                # Fallback to core if serialization fails\n+                return f\"{prefix}{core}\"\n+        else:\n+            return f\"{prefix}{core}\"\n \n     def is_empty(self) -> bool:\n         return all(\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "openlibrary/plugins/upstream/table_of_contents.py": [
                    "function: TableOfContents.from_markdown\nfunction: TableOfContents.to_markdown\nfunction: TocEntry.from_markdown\nline: 100\nfunction: TocEntry.to_markdown\nfunction: TocEntry.to_dict\nfunction: TocEntry.is_empty"
                ],
                "openlibrary/core/olmarkdown.py": [
                    "class: OLMarkdown"
                ],
                "openlibrary/plugins/upstream/forms.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 21983d3..2b5c47b 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -46,6 +46,8 @@ class TableOfContents:\n         return \"\\n\".join(r.to_markdown() for r in self.entries)\n \n \n+import json\n+\n class AuthorRecord(TypedDict, total=False):\n     name: Required[str]\n     author: ThingReferenceDict | None\n@@ -100,22 +102,58 @@ class TocEntry:\n         RE_LEVEL = web.re_compile(r\"(\\**)(.*)\")\n         level, text = RE_LEVEL.match(line.strip()).groups()\n \n+        label = title = page = \"\"\n+        authors = None\n+        subtitle = None\n+        description = None\n+\n         if \"|\" in text:\n-            tokens = text.split(\"|\", 2)\n-            label, title, page = pad(tokens, 3, '')\n+            tokens = [t.strip() for t in text.split(\"|\")]\n+            # Ensure at least 3 tokens for label, title, and page number\n+            while len(tokens) < 3:\n+                tokens.append('')\n+            label, title, page = tokens[:3]\n+            # Everything after the third column is treated as an \"extras\" payload\n+            extras_str = \" | \".join(tokens[3:]).strip() if len(tokens) > 3 else \"\"\n+            if extras_str:\n+                try:\n+                    extras = json.loads(extras_str)\n+                    if isinstance(extras, dict):\n+                        authors = extras.get('authors')\n+                        subtitle = extras.get('subtitle')\n+                        description = extras.get('description')\n+                except Exception:\n+                    # Ignore invalid extras payloads to remain backward compatible\n+                    pass\n         else:\n-            title = text\n-            label = page = \"\"\n+            title = text.strip()\n \n         return TocEntry(\n             level=len(level),\n-            label=label.strip() or None,\n-            title=title.strip() or None,\n-            pagenum=page.strip() or None,\n+            label=label or None,\n+            title=title or None,\n+            pagenum=page or None,\n+            authors=authors,\n+            subtitle=subtitle,\n+            description=description,\n         )\n \n     def to_markdown(self) -> str:\n-        return f\"{'*' * self.level} {self.label or ''} | {self.title or ''} | {self.pagenum or ''}\"\n+        prefix = '*' * self.level\n+        if prefix:\n+            prefix += ' '\n+        cols = [self.label or '', self.title or '', self.pagenum or '']\n+        md = f\"{prefix}{' | '.join(cols)}\"\n+        extras = {}\n+        if getattr(self, 'authors', None):\n+            extras['authors'] = self.authors\n+        if getattr(self, 'subtitle', None):\n+            extras['subtitle'] = self.subtitle\n+        if getattr(self, 'description', None):\n+            extras['description'] = self.description\n+        if extras:\n+            md += \" | \" + json.dumps(extras, ensure_ascii=False, sort_keys=True)\n+        return md\n \n     def is_empty(self) -> bool:\n         return all(\n",
                "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 21983d3..538e731 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -34,13 +34,16 @@ class TableOfContents:\n \n     @staticmethod\n     def from_markdown(text: str) -> 'TableOfContents':\n-        return TableOfContents(\n-            [\n-                TocEntry.from_markdown(line)\n-                for line in text.splitlines()\n-                if line.strip(\" |\")\n-            ]\n-        )\n+        entries = []\n+        for line in text.splitlines():\n+            # Skip blank/whitespace-only lines\n+            if not line.strip():\n+                continue\n+            entry = TocEntry.from_markdown(line)\n+            # Ignore entries with no meaningful content\n+            if not entry.is_empty():\n+                entries.append(entry)\n+        return TableOfContents(entries)\n \n     def to_markdown(self) -> str:\n         return \"\\n\".join(r.to_markdown() for r in self.entries)\n@@ -115,7 +118,28 @@ class TocEntry:\n         )\n \n     def to_markdown(self) -> str:\n-        return f\"{'*' * self.level} {self.label or ''} | {self.title or ''} | {self.pagenum or ''}\"\n+        prefix = '*' * self.level\n+        # Prefer simple (no-pipe) form when only a title is present\n+        has_only_title = (\n+            self.label is None\n+            and self.pagenum is None\n+            and self.authors is None\n+            and self.subtitle is None\n+            and self.description is None\n+        )\n+        if has_only_title:\n+            if prefix:\n+                return f\"{prefix} {self.title or ''}\".rstrip()\n+            return f\"{self.title or ''}\".rstrip()\n+\n+        # Otherwise, use pipe-delimited form, allowing missing label/page\n+        label = self.label or ''\n+        title = self.title or ''\n+        page = self.pagenum or ''\n+        core = f\"{label} | {title} | {page}\"\n+        if prefix:\n+            return f\"{prefix} {core}\".rstrip()\n+        return core.rstrip()\n \n     def is_empty(self) -> bool:\n         return all(\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/openlibrary/plugins/upstream/table_of_contents.py b/openlibrary/plugins/upstream/table_of_contents.py\nindex 21983d3..9b92c24 100644\n--- a/openlibrary/plugins/upstream/table_of_contents.py\n+++ b/openlibrary/plugins/upstream/table_of_contents.py\n@@ -34,11 +34,17 @@ class TableOfContents:\n \n     @staticmethod\n     def from_markdown(text: str) -> 'TableOfContents':\n+        # Build entries from markdown, skipping lines that are effectively empty\n+        # (only spaces, pipes, or asterisks) and filtering out empty entries.\n         return TableOfContents(\n             [\n-                TocEntry.from_markdown(line)\n-                for line in text.splitlines()\n-                if line.strip(\" |\")\n+                entry\n+                for entry in (\n+                    TocEntry.from_markdown(line)\n+                    for line in text.splitlines()\n+                    if line.strip(\" *|\")\n+                )\n+                if not entry.is_empty()\n             ]\n         )\n \n@@ -100,22 +106,75 @@ class TocEntry:\n         RE_LEVEL = web.re_compile(r\"(\\**)(.*)\")\n         level, text = RE_LEVEL.match(line.strip()).groups()\n \n+        # Initialize defaults\n+        label = \"\"\n+        title = \"\"\n+        page = \"\"\n+        authors = None\n+        subtitle = None\n+        description = None\n+\n         if \"|\" in text:\n-            tokens = text.split(\"|\", 2)\n-            label, title, page = pad(tokens, 3, '')\n+            # Allow an optional metadata segment after the first three fields.\n+            tokens = [t.strip() for t in text.split(\"|\", 3)]\n+            label, title, page, extra = pad(tokens, 4, '')\n+            if extra:\n+                # Try parsing extended metadata as JSON for lossless round-tripping.\n+                try:\n+                    import json\n+                    meta_obj = json.loads(extra)\n+                    if isinstance(meta_obj, dict):\n+                        authors = meta_obj.get('authors')\n+                        subtitle = meta_obj.get('subtitle')\n+                        description = meta_obj.get('description')\n+                except Exception:\n+                    # Fallback: treat extra as pipe-separated positional fields:\n+                    # authors; subtitle; description\n+                    extras = [t.strip() for t in extra.split(\"|\")]\n+                    if len(extras) >= 1 and extras[0]:\n+                        # authors as semicolon-separated names\n+                        names = [n.strip() for n in extras[0].split(';') if n.strip()]\n+                        authors = names or extras[0].strip()\n+                    if len(extras) >= 2 and extras[1]:\n+                        subtitle = extras[1]\n+                    if len(extras) >= 3 and extras[2]:\n+                        description = extras[2]\n         else:\n-            title = text\n-            label = page = \"\"\n+            title = text.strip()\n \n         return TocEntry(\n             level=len(level),\n-            label=label.strip() or None,\n-            title=title.strip() or None,\n-            pagenum=page.strip() or None,\n+            label=label or None,\n+            title=title or None,\n+            pagenum=page or None,\n+            authors=authors,\n+            subtitle=subtitle,\n+            description=description,\n         )\n \n     def to_markdown(self) -> str:\n-        return f\"{'*' * self.level} {self.label or ''} | {self.title or ''} | {self.pagenum or ''}\"\n+        # Build the base representation, normalizing indentation and spacing.\n+        prefix = f\"{'*' * self.level + ' ' if self.level else ''}\"\n+        label = self.label or ''\n+        title = self.title or ''\n+        page = self.pagenum or ''\n+        # Use pipe-separated format when level > 0 or when a label/page is present.\n+        if self.level or self.label is not None or self.pagenum is not None:\n+            base = f\"{label} | {title} | {page}\"\n+        else:\n+            base = title\n+        # Append extended metadata as JSON if present.\n+        meta = {}\n+        if getattr(self, 'authors', None) is not None:\n+            meta['authors'] = self.authors\n+        if getattr(self, 'subtitle', None) is not None:\n+            meta['subtitle'] = self.subtitle\n+        if getattr(self, 'description', None) is not None:\n+            meta['description'] = self.description\n+        if meta:\n+            import json\n+            base = f\"{base} | {json.dumps(meta, ensure_ascii=False)}\"\n+        return f\"{prefix}{base}\".rstrip()\n \n     def is_empty(self) -> bool:\n         return all(\n"
}