{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__4c132bfd",
    "original_id": "instance_ansible__ansible-e9e6001263f51103e96e58ad382660df0f3d0e39-v30a923fb5c164d6cd18280c02422f75e611e8fb2",
    "1_model_selected_files": [
        "lib/ansible/plugins/connection/winrm.py",
        "lib/ansible/plugins/doc_fragments/url_windows.py"
    ],
    "2_embedding_selected_files": [
        "lib/ansible/plugins/connection/winrm.py",
        "lib/ansible/plugins/connection/local.py",
        "lib/ansible/plugins/connection/paramiko_ssh.py",
        "lib/ansible/plugins/become/__init__.py",
        "lib/ansible/plugins/become/runas.py",
        "lib/ansible/plugins/connection/psrp.py",
        "lib/ansible/plugins/connection/ssh.py",
        "lib/ansible/plugins/action/__init__.py",
        "lib/ansible/modules/uri.py",
        "lib/ansible/plugins/become/sudo.py",
        "lib/ansible/plugins/become/su.py",
        "lib/ansible/plugins/doc_fragments/url_windows.py",
        "lib/ansible/playbook/play_context.py",
        "lib/ansible/executor/task_executor.py",
        "lib/ansible/cli/scripts/ansible_connection_cli_stub.py",
        "lib/ansible/plugins/action/wait_for_connection.py",
        "lib/ansible/plugins/connection/__init__.py",
        "lib/ansible/modules/get_url.py",
        "lib/ansible/modules/wait_for.py",
        "lib/ansible/plugins/doc_fragments/shell_common.py",
        "lib/ansible/modules/user.py",
        "lib/ansible/plugins/doc_fragments/connection_pipelining.py",
        "lib/ansible/modules/apt_key.py",
        "lib/ansible/modules/expect.py",
        "lib/ansible/modules/getent.py",
        "lib/ansible/plugins/action/reboot.py",
        "lib/ansible/modules/include_vars.py",
        "lib/ansible/plugins/action/copy.py",
        "lib/ansible/modules/wait_for_connection.py",
        "lib/ansible/plugins/doc_fragments/shell_windows.py",
        "lib/ansible/plugins/action/script.py",
        "lib/ansible/modules/async_status.py",
        "lib/ansible/plugins/callback/default.py",
        "lib/ansible/plugins/action/gather_facts.py",
        "lib/ansible/modules/known_hosts.py",
        "lib/ansible/plugins/strategy/__init__.py",
        "lib/ansible/modules/raw.py",
        "lib/ansible/executor/interpreter_discovery.py",
        "lib/ansible/module_utils/compat/paramiko.py",
        "lib/ansible/executor/powershell/__init__.py"
    ],
    "3_final_combined_files": [
        "lib/ansible/plugins/connection/winrm.py",
        "lib/ansible/plugins/doc_fragments/url_windows.py",
        "lib/ansible/plugins/connection/local.py",
        "lib/ansible/plugins/connection/paramiko_ssh.py"
    ],
    "4_related_elements": {
        "lib/ansible/plugins/connection/winrm.py": [
            "variable: HAVE_KERBEROS\nvariable: HAS_PEXPECT\nfunction: Connection.__init__\nfunction: Connection._build_winrm_kwargs\nfunction: Connection._kerb_auth\nfunction: Connection._winrm_connect\nfunction: Connection._connect\nfunction: Connection.reset\nfunction: Connection.close"
        ],
        "lib/ansible/plugins/doc_fragments/url_windows.py": [
            ""
        ],
        "lib/ansible/plugins/connection/local.py": [
            ""
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "lib/ansible/plugins/connection/winrm.py": [
                    "function: Connection._kerb_auth\nline: 357\nline: 383\nline: 414\nline: 432\nline: 440\nline: 226"
                ],
                "lib/ansible/plugins/doc_fragments/url_windows.py": [
                    ""
                ],
                "lib/ansible/plugins/connection/local.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/plugins/connection/winrm.py b/lib/ansible/plugins/connection/winrm.py\nindex fff04da..c360d91 100644\n--- a/lib/ansible/plugins/connection/winrm.py\n+++ b/lib/ansible/plugins/connection/winrm.py\n@@ -354,8 +354,8 @@ class Connection(ConnectionBase):\n         self._kerb_ccache = tempfile.NamedTemporaryFile()\n         display.vvvvv(\"creating Kerberos CC at %s\" % self._kerb_ccache.name)\n         krb5ccname = \"FILE:%s\" % self._kerb_ccache.name\n-        os.environ[\"KRB5CCNAME\"] = krb5ccname\n-        krb5env = dict(PATH=os.environ[\"PATH\"], KRB5CCNAME=krb5ccname)\n+        # Only set KRB5CCNAME in the kinit process environment; do not modify the global env\n+        krb5env = dict(PATH=os.environ.get(\"PATH\", \"\"), KRB5CCNAME=krb5ccname)\n \n         # Add any explicit environment vars into the krb5env block\n         kinit_env_vars = self.get_option('kinit_env_vars')\n@@ -370,75 +370,35 @@ class Connection(ConnectionBase):\n         if kinit_args:\n             kinit_args = [to_text(a) for a in shlex.split(kinit_args) if a.strip()]\n             kinit_cmdline.extend(kinit_args)\n-\n         elif boolean(self.get_option('_extras').get('ansible_winrm_kerberos_delegation', False)):\n             kinit_cmdline.append('-f')\n \n+        # Principal must be the last arg\n         kinit_cmdline.append(principal)\n \n-        # pexpect runs the process in its own pty so it can correctly send\n-        # the password as input even on MacOS which blocks subprocess from\n-        # doing so. Unfortunately it is not available on the built in Python\n-        # so we can only use it if someone has installed it\n-        if HAS_PEXPECT:\n-            proc_mechanism = \"pexpect\"\n-            command = kinit_cmdline.pop(0)\n-            password = to_text(password, encoding='utf-8',\n-                               errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with pexpect for principal %s\"\n-                         % principal)\n-            try:\n-                child = pexpect.spawn(command, kinit_cmdline, timeout=60,\n-                                      env=krb5env, echo=False)\n-            except pexpect.ExceptionPexpect as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (command, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n-\n-            try:\n-                child.expect(\".*:\")\n-                child.sendline(password)\n-            except OSError as err:\n-                # child exited before the pass was sent, Ansible will raise\n-                # error based on the rc below, just display the error here\n-                display.vvvv(\"kinit with pexpect raised OSError: %s\"\n-                             % to_native(err))\n-\n-            # technically this is the stdout + stderr but to match the\n-            # subprocess error checking behaviour, we will call it stderr\n-            stderr = child.read()\n-            child.wait()\n-            rc = child.exitstatus\n-        else:\n-            proc_mechanism = \"subprocess\"\n-            b_password = to_bytes(password, encoding='utf-8',\n-                                  errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with subprocess for principal %s\"\n-                         % principal)\n-            try:\n-                p = subprocess.Popen(kinit_cmdline, stdin=subprocess.PIPE,\n-                                     stdout=subprocess.PIPE,\n-                                     stderr=subprocess.PIPE,\n-                                     env=krb5env)\n-\n-            except OSError as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (self._kinit_cmd, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n+        # Always use subprocess to provide the password via stdin for consistent behavior across platforms\n+        b_password = to_bytes(password, encoding='utf-8', errors='surrogate_or_strict')\n+        display.vvvv(\"calling kinit for principal %s\" % principal)\n+        try:\n+            p = subprocess.Popen(\n+                kinit_cmdline,\n+                stdin=subprocess.PIPE,\n+                stdout=subprocess.PIPE,\n+                stderr=subprocess.PIPE,\n+                env=krb5env\n+            )\n+        except OSError as err:\n+            err_msg = \"Kerberos auth failure when calling kinit cmd '%s': %s\" % (self._kinit_cmd, to_native(err))\n+            raise AnsibleConnectionFailure(err_msg)\n \n-            stdout, stderr = p.communicate(b_password + b'\\n')\n-            rc = p.returncode != 0\n+        stdout, stderr = p.communicate(b_password + b'\\n')\n+        rc = p.returncode\n \n         if rc != 0:\n-            # one last attempt at making sure the password does not exist\n-            # in the output\n+            # one last attempt at making sure the password does not exist in the output\n             exp_msg = to_native(stderr.strip())\n             exp_msg = exp_msg.replace(to_native(password), \"<redacted>\")\n-\n-            err_msg = \"Kerberos auth failure for principal %s with %s: %s\" \\\n-                      % (principal, proc_mechanism, exp_msg)\n+            err_msg = \"Kerberos auth failure for principal %s: %s\" % (principal, exp_msg)\n             raise AnsibleConnectionFailure(err_msg)\n \n         display.vvvvv(\"kinit succeeded for principal %s\" % principal)\n",
                "diff --git a/lib/ansible/plugins/connection/winrm.py b/lib/ansible/plugins/connection/winrm.py\nindex fff04da..c8cfd6d 100644\n--- a/lib/ansible/plugins/connection/winrm.py\n+++ b/lib/ansible/plugins/connection/winrm.py\n@@ -354,14 +354,15 @@ class Connection(ConnectionBase):\n         self._kerb_ccache = tempfile.NamedTemporaryFile()\n         display.vvvvv(\"creating Kerberos CC at %s\" % self._kerb_ccache.name)\n         krb5ccname = \"FILE:%s\" % self._kerb_ccache.name\n-        os.environ[\"KRB5CCNAME\"] = krb5ccname\n-        krb5env = dict(PATH=os.environ[\"PATH\"], KRB5CCNAME=krb5ccname)\n+        # Build a per-process env for kinit; do not modify global environment\n+        krb5env = dict(PATH=os.environ.get(\"PATH\", \"\"), KRB5CCNAME=krb5ccname)\n \n         # Add any explicit environment vars into the krb5env block\n         kinit_env_vars = self.get_option('kinit_env_vars')\n-        for var in kinit_env_vars:\n-            if var not in krb5env and var in os.environ:\n-                krb5env[var] = os.environ[var]\n+        if kinit_env_vars:\n+            for var in kinit_env_vars:\n+                if var not in krb5env and var in os.environ:\n+                    krb5env[var] = os.environ[var]\n \n         # Stores various flags to call with kinit, these could be explicit args set by 'ansible_winrm_kinit_args' OR\n         # '-f' if kerberos delegation is requested (ansible_winrm_kerberos_delegation).\n@@ -370,75 +371,37 @@ class Connection(ConnectionBase):\n         if kinit_args:\n             kinit_args = [to_text(a) for a in shlex.split(kinit_args) if a.strip()]\n             kinit_cmdline.extend(kinit_args)\n-\n         elif boolean(self.get_option('_extras').get('ansible_winrm_kerberos_delegation', False)):\n             kinit_cmdline.append('-f')\n \n+        # The principal must be appended at the end of the command line\n         kinit_cmdline.append(principal)\n \n-        # pexpect runs the process in its own pty so it can correctly send\n-        # the password as input even on MacOS which blocks subprocess from\n-        # doing so. Unfortunately it is not available on the built in Python\n-        # so we can only use it if someone has installed it\n-        if HAS_PEXPECT:\n-            proc_mechanism = \"pexpect\"\n-            command = kinit_cmdline.pop(0)\n-            password = to_text(password, encoding='utf-8',\n-                               errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with pexpect for principal %s\"\n-                         % principal)\n-            try:\n-                child = pexpect.spawn(command, kinit_cmdline, timeout=60,\n-                                      env=krb5env, echo=False)\n-            except pexpect.ExceptionPexpect as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (command, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n-\n-            try:\n-                child.expect(\".*:\")\n-                child.sendline(password)\n-            except OSError as err:\n-                # child exited before the pass was sent, Ansible will raise\n-                # error based on the rc below, just display the error here\n-                display.vvvv(\"kinit with pexpect raised OSError: %s\"\n-                             % to_native(err))\n-\n-            # technically this is the stdout + stderr but to match the\n-            # subprocess error checking behaviour, we will call it stderr\n-            stderr = child.read()\n-            child.wait()\n-            rc = child.exitstatus\n-        else:\n-            proc_mechanism = \"subprocess\"\n-            b_password = to_bytes(password, encoding='utf-8',\n-                                  errors='surrogate_or_strict')\n+        b_password = to_bytes(password, encoding='utf-8', errors='surrogate_or_strict')\n \n-            display.vvvv(\"calling kinit with subprocess for principal %s\"\n-                         % principal)\n-            try:\n-                p = subprocess.Popen(kinit_cmdline, stdin=subprocess.PIPE,\n-                                     stdout=subprocess.PIPE,\n-                                     stderr=subprocess.PIPE,\n-                                     env=krb5env)\n-\n-            except OSError as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (self._kinit_cmd, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n+        display.vvvv(\"calling kinit with subprocess for principal %s\" % principal)\n+        try:\n+            p = subprocess.Popen(\n+                kinit_cmdline,\n+                stdin=subprocess.PIPE,\n+                stdout=subprocess.PIPE,\n+                stderr=subprocess.PIPE,\n+                env=krb5env,\n+                close_fds=True\n+            )\n+        except OSError as err:\n+            err_msg = \"Kerberos auth failure when calling kinit cmd '%s': %s\" % (self._kinit_cmd, to_native(err))\n+            raise AnsibleConnectionFailure(err_msg)\n \n-            stdout, stderr = p.communicate(b_password + b'\\n')\n-            rc = p.returncode != 0\n+        stdout, stderr = p.communicate(b_password + b'\\n')\n+        rc = p.returncode\n \n         if rc != 0:\n-            # one last attempt at making sure the password does not exist\n-            # in the output\n+            # Ensure the password does not exist in the error output\n             exp_msg = to_native(stderr.strip())\n-            exp_msg = exp_msg.replace(to_native(password), \"<redacted>\")\n-\n-            err_msg = \"Kerberos auth failure for principal %s with %s: %s\" \\\n-                      % (principal, proc_mechanism, exp_msg)\n+            if password:\n+                exp_msg = exp_msg.replace(to_native(password), \"<redacted>\")\n+            err_msg = \"Kerberos auth failure for principal %s: %s\" % (principal, exp_msg)\n             raise AnsibleConnectionFailure(err_msg)\n \n         display.vvvvv(\"kinit succeeded for principal %s\" % principal)\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "lib/ansible/plugins/connection/winrm.py": [
                    "line: 294\nfunction: Connection._kerb_auth\nline: 357\nline: 358\nline: 383\nline: 414\nline: 432\nline: 440"
                ],
                "lib/ansible/plugins/doc_fragments/url_windows.py": [
                    ""
                ],
                "lib/ansible/plugins/connection/local.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/plugins/connection/winrm.py b/lib/ansible/plugins/connection/winrm.py\nindex fff04da..45177a1 100644\n--- a/lib/ansible/plugins/connection/winrm.py\n+++ b/lib/ansible/plugins/connection/winrm.py\n@@ -355,7 +355,7 @@ class Connection(ConnectionBase):\n         display.vvvvv(\"creating Kerberos CC at %s\" % self._kerb_ccache.name)\n         krb5ccname = \"FILE:%s\" % self._kerb_ccache.name\n         os.environ[\"KRB5CCNAME\"] = krb5ccname\n-        krb5env = dict(PATH=os.environ[\"PATH\"], KRB5CCNAME=krb5ccname)\n+        krb5env = dict(PATH=os.environ.get(\"PATH\", \"\"), KRB5CCNAME=krb5ccname)\n \n         # Add any explicit environment vars into the krb5env block\n         kinit_env_vars = self.get_option('kinit_env_vars')\n@@ -376,69 +376,27 @@ class Connection(ConnectionBase):\n \n         kinit_cmdline.append(principal)\n \n-        # pexpect runs the process in its own pty so it can correctly send\n-        # the password as input even on MacOS which blocks subprocess from\n-        # doing so. Unfortunately it is not available on the built in Python\n-        # so we can only use it if someone has installed it\n-        if HAS_PEXPECT:\n-            proc_mechanism = \"pexpect\"\n-            command = kinit_cmdline.pop(0)\n-            password = to_text(password, encoding='utf-8',\n-                               errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with pexpect for principal %s\"\n-                         % principal)\n-            try:\n-                child = pexpect.spawn(command, kinit_cmdline, timeout=60,\n-                                      env=krb5env, echo=False)\n-            except pexpect.ExceptionPexpect as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (command, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n+        # Always use subprocess to invoke kinit and pass the password via stdin for reliable behavior across platforms.\n+        b_password = to_bytes(password, encoding='utf-8', errors='surrogate_or_strict')\n \n-            try:\n-                child.expect(\".*:\")\n-                child.sendline(password)\n-            except OSError as err:\n-                # child exited before the pass was sent, Ansible will raise\n-                # error based on the rc below, just display the error here\n-                display.vvvv(\"kinit with pexpect raised OSError: %s\"\n-                             % to_native(err))\n-\n-            # technically this is the stdout + stderr but to match the\n-            # subprocess error checking behaviour, we will call it stderr\n-            stderr = child.read()\n-            child.wait()\n-            rc = child.exitstatus\n-        else:\n-            proc_mechanism = \"subprocess\"\n-            b_password = to_bytes(password, encoding='utf-8',\n-                                  errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with subprocess for principal %s\"\n-                         % principal)\n-            try:\n-                p = subprocess.Popen(kinit_cmdline, stdin=subprocess.PIPE,\n-                                     stdout=subprocess.PIPE,\n-                                     stderr=subprocess.PIPE,\n-                                     env=krb5env)\n-\n-            except OSError as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (self._kinit_cmd, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n+        display.vvvv(\"calling kinit with subprocess for principal %s\" % principal)\n+        try:\n+            p = subprocess.Popen(kinit_cmdline, stdin=subprocess.PIPE,\n+                                 stdout=subprocess.PIPE,\n+                                 stderr=subprocess.PIPE,\n+                                 env=krb5env)\n+        except OSError as err:\n+            err_msg = \"Kerberos auth failure when calling kinit cmd '%s': %s\" % (self._kinit_cmd, to_native(err))\n+            raise AnsibleConnectionFailure(err_msg)\n \n-            stdout, stderr = p.communicate(b_password + b'\\n')\n-            rc = p.returncode != 0\n+        stdout, stderr = p.communicate(b_password + b'\\n')\n+        rc = p.returncode\n \n         if rc != 0:\n-            # one last attempt at making sure the password does not exist\n-            # in the output\n+            # one last attempt at making sure the password does not exist in the output\n             exp_msg = to_native(stderr.strip())\n             exp_msg = exp_msg.replace(to_native(password), \"<redacted>\")\n-\n-            err_msg = \"Kerberos auth failure for principal %s with %s: %s\" \\\n-                      % (principal, proc_mechanism, exp_msg)\n+            err_msg = \"Kerberos auth failure for principal %s: %s\" % (principal, exp_msg)\n             raise AnsibleConnectionFailure(err_msg)\n \n         display.vvvvv(\"kinit succeeded for principal %s\" % principal)\n",
                "diff --git a/lib/ansible/plugins/connection/winrm.py b/lib/ansible/plugins/connection/winrm.py\nindex fff04da..cdbbf2b 100644\n--- a/lib/ansible/plugins/connection/winrm.py\n+++ b/lib/ansible/plugins/connection/winrm.py\n@@ -354,8 +354,8 @@ class Connection(ConnectionBase):\n         self._kerb_ccache = tempfile.NamedTemporaryFile()\n         display.vvvvv(\"creating Kerberos CC at %s\" % self._kerb_ccache.name)\n         krb5ccname = \"FILE:%s\" % self._kerb_ccache.name\n-        os.environ[\"KRB5CCNAME\"] = krb5ccname\n-        krb5env = dict(PATH=os.environ[\"PATH\"], KRB5CCNAME=krb5ccname)\n+        # Do not mutate global environment; pass an explicit env to the kinit process\n+        krb5env = dict(PATH=os.environ.get(\"PATH\", \"\"), KRB5CCNAME=krb5ccname)\n \n         # Add any explicit environment vars into the krb5env block\n         kinit_env_vars = self.get_option('kinit_env_vars')\n@@ -370,75 +370,34 @@ class Connection(ConnectionBase):\n         if kinit_args:\n             kinit_args = [to_text(a) for a in shlex.split(kinit_args) if a.strip()]\n             kinit_cmdline.extend(kinit_args)\n-\n         elif boolean(self.get_option('_extras').get('ansible_winrm_kerberos_delegation', False)):\n             kinit_cmdline.append('-f')\n \n         kinit_cmdline.append(principal)\n \n-        # pexpect runs the process in its own pty so it can correctly send\n-        # the password as input even on MacOS which blocks subprocess from\n-        # doing so. Unfortunately it is not available on the built in Python\n-        # so we can only use it if someone has installed it\n-        if HAS_PEXPECT:\n-            proc_mechanism = \"pexpect\"\n-            command = kinit_cmdline.pop(0)\n-            password = to_text(password, encoding='utf-8',\n-                               errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with pexpect for principal %s\"\n-                         % principal)\n-            try:\n-                child = pexpect.spawn(command, kinit_cmdline, timeout=60,\n-                                      env=krb5env, echo=False)\n-            except pexpect.ExceptionPexpect as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (command, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n-\n-            try:\n-                child.expect(\".*:\")\n-                child.sendline(password)\n-            except OSError as err:\n-                # child exited before the pass was sent, Ansible will raise\n-                # error based on the rc below, just display the error here\n-                display.vvvv(\"kinit with pexpect raised OSError: %s\"\n-                             % to_native(err))\n-\n-            # technically this is the stdout + stderr but to match the\n-            # subprocess error checking behaviour, we will call it stderr\n-            stderr = child.read()\n-            child.wait()\n-            rc = child.exitstatus\n-        else:\n-            proc_mechanism = \"subprocess\"\n-            b_password = to_bytes(password, encoding='utf-8',\n-                                  errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with subprocess for principal %s\"\n-                         % principal)\n-            try:\n-                p = subprocess.Popen(kinit_cmdline, stdin=subprocess.PIPE,\n-                                     stdout=subprocess.PIPE,\n-                                     stderr=subprocess.PIPE,\n-                                     env=krb5env)\n-\n-            except OSError as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (self._kinit_cmd, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n+        # Always use subprocess and write the password to stdin to avoid relying on a TTY/pty.\n+        b_password = to_bytes(password, encoding='utf-8', errors='surrogate_or_strict')\n+        display.vvvv(\"calling kinit with subprocess for principal %s\" % principal)\n+        try:\n+            p = subprocess.Popen(\n+                kinit_cmdline,\n+                stdin=subprocess.PIPE,\n+                stdout=subprocess.PIPE,\n+                stderr=subprocess.PIPE,\n+                env=krb5env,\n+            )\n+        except OSError as err:\n+            err_msg = \"Kerberos auth failure when calling kinit cmd '%s': %s\" % (self._kinit_cmd, to_native(err))\n+            raise AnsibleConnectionFailure(err_msg)\n \n-            stdout, stderr = p.communicate(b_password + b'\\n')\n-            rc = p.returncode != 0\n+        stdout, stderr = p.communicate(b_password + b'\\n')\n+        rc = p.returncode\n \n         if rc != 0:\n-            # one last attempt at making sure the password does not exist\n-            # in the output\n+            # one last attempt at making sure the password does not exist in the output\n             exp_msg = to_native(stderr.strip())\n             exp_msg = exp_msg.replace(to_native(password), \"<redacted>\")\n-\n-            err_msg = \"Kerberos auth failure for principal %s with %s: %s\" \\\n-                      % (principal, proc_mechanism, exp_msg)\n+            err_msg = \"Kerberos auth failure for principal %s: %s\" % (principal, exp_msg)\n             raise AnsibleConnectionFailure(err_msg)\n \n         display.vvvvv(\"kinit succeeded for principal %s\" % principal)\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/lib/ansible/plugins/connection/winrm.py b/lib/ansible/plugins/connection/winrm.py\nindex fff04da..c360d91 100644\n--- a/lib/ansible/plugins/connection/winrm.py\n+++ b/lib/ansible/plugins/connection/winrm.py\n@@ -354,8 +354,8 @@ class Connection(ConnectionBase):\n         self._kerb_ccache = tempfile.NamedTemporaryFile()\n         display.vvvvv(\"creating Kerberos CC at %s\" % self._kerb_ccache.name)\n         krb5ccname = \"FILE:%s\" % self._kerb_ccache.name\n-        os.environ[\"KRB5CCNAME\"] = krb5ccname\n-        krb5env = dict(PATH=os.environ[\"PATH\"], KRB5CCNAME=krb5ccname)\n+        # Only set KRB5CCNAME in the kinit process environment; do not modify the global env\n+        krb5env = dict(PATH=os.environ.get(\"PATH\", \"\"), KRB5CCNAME=krb5ccname)\n \n         # Add any explicit environment vars into the krb5env block\n         kinit_env_vars = self.get_option('kinit_env_vars')\n@@ -370,75 +370,35 @@ class Connection(ConnectionBase):\n         if kinit_args:\n             kinit_args = [to_text(a) for a in shlex.split(kinit_args) if a.strip()]\n             kinit_cmdline.extend(kinit_args)\n-\n         elif boolean(self.get_option('_extras').get('ansible_winrm_kerberos_delegation', False)):\n             kinit_cmdline.append('-f')\n \n+        # Principal must be the last arg\n         kinit_cmdline.append(principal)\n \n-        # pexpect runs the process in its own pty so it can correctly send\n-        # the password as input even on MacOS which blocks subprocess from\n-        # doing so. Unfortunately it is not available on the built in Python\n-        # so we can only use it if someone has installed it\n-        if HAS_PEXPECT:\n-            proc_mechanism = \"pexpect\"\n-            command = kinit_cmdline.pop(0)\n-            password = to_text(password, encoding='utf-8',\n-                               errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with pexpect for principal %s\"\n-                         % principal)\n-            try:\n-                child = pexpect.spawn(command, kinit_cmdline, timeout=60,\n-                                      env=krb5env, echo=False)\n-            except pexpect.ExceptionPexpect as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (command, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n-\n-            try:\n-                child.expect(\".*:\")\n-                child.sendline(password)\n-            except OSError as err:\n-                # child exited before the pass was sent, Ansible will raise\n-                # error based on the rc below, just display the error here\n-                display.vvvv(\"kinit with pexpect raised OSError: %s\"\n-                             % to_native(err))\n-\n-            # technically this is the stdout + stderr but to match the\n-            # subprocess error checking behaviour, we will call it stderr\n-            stderr = child.read()\n-            child.wait()\n-            rc = child.exitstatus\n-        else:\n-            proc_mechanism = \"subprocess\"\n-            b_password = to_bytes(password, encoding='utf-8',\n-                                  errors='surrogate_or_strict')\n-\n-            display.vvvv(\"calling kinit with subprocess for principal %s\"\n-                         % principal)\n-            try:\n-                p = subprocess.Popen(kinit_cmdline, stdin=subprocess.PIPE,\n-                                     stdout=subprocess.PIPE,\n-                                     stderr=subprocess.PIPE,\n-                                     env=krb5env)\n-\n-            except OSError as err:\n-                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\\n-                          \"'%s': %s\" % (self._kinit_cmd, to_native(err))\n-                raise AnsibleConnectionFailure(err_msg)\n+        # Always use subprocess to provide the password via stdin for consistent behavior across platforms\n+        b_password = to_bytes(password, encoding='utf-8', errors='surrogate_or_strict')\n+        display.vvvv(\"calling kinit for principal %s\" % principal)\n+        try:\n+            p = subprocess.Popen(\n+                kinit_cmdline,\n+                stdin=subprocess.PIPE,\n+                stdout=subprocess.PIPE,\n+                stderr=subprocess.PIPE,\n+                env=krb5env\n+            )\n+        except OSError as err:\n+            err_msg = \"Kerberos auth failure when calling kinit cmd '%s': %s\" % (self._kinit_cmd, to_native(err))\n+            raise AnsibleConnectionFailure(err_msg)\n \n-            stdout, stderr = p.communicate(b_password + b'\\n')\n-            rc = p.returncode != 0\n+        stdout, stderr = p.communicate(b_password + b'\\n')\n+        rc = p.returncode\n \n         if rc != 0:\n-            # one last attempt at making sure the password does not exist\n-            # in the output\n+            # one last attempt at making sure the password does not exist in the output\n             exp_msg = to_native(stderr.strip())\n             exp_msg = exp_msg.replace(to_native(password), \"<redacted>\")\n-\n-            err_msg = \"Kerberos auth failure for principal %s with %s: %s\" \\\n-                      % (principal, proc_mechanism, exp_msg)\n+            err_msg = \"Kerberos auth failure for principal %s: %s\" % (principal, exp_msg)\n             raise AnsibleConnectionFailure(err_msg)\n \n         display.vvvvv(\"kinit succeeded for principal %s\" % principal)\n"
}