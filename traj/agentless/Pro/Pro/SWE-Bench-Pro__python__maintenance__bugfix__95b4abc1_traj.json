{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__95b4abc1",
    "original_id": "instance_internetarchive__openlibrary-d109cc7e6e161170391f98f9a6fa1d02534c18e4-ve8c8d62a2b60610a3c4631f5f23ed866bada9818",
    "1_model_selected_files": [
        "openlibrary/plugins/openlibrary/lists.py",
        "openlibrary/core/lists/model.py",
        "openlibrary/core/lists/engine.py",
        "openlibrary/plugins/openlibrary/schema.py",
        "openlibrary/core/olmarkdown.py"
    ],
    "2_embedding_selected_files": [
        "openlibrary/plugins/openlibrary/lists.py",
        "openlibrary/core/lists/model.py",
        "openlibrary/core/models.py",
        "openlibrary/plugins/upstream/mybooks.py",
        "openlibrary/core/booknotes.py",
        "openlibrary/solr/updater/list.py",
        "openlibrary/core/lists/__init__.py",
        "openlibrary/plugins/openlibrary/api.py",
        "openlibrary/core/observations.py",
        "openlibrary/core/waitinglist.py",
        "openlibrary/plugins/upstream/addbook.py",
        "openlibrary/plugins/upstream/account.py",
        "openlibrary/core/lists/engine.py",
        "openlibrary/catalog/marc/parse.py",
        "openlibrary/catalog/add_book/__init__.py",
        "openlibrary/plugins/openlibrary/code.py",
        "openlibrary/plugins/upstream/edits.py",
        "openlibrary/plugins/openlibrary/infobase_hook.py",
        "openlibrary/plugins/books/readlinks.py",
        "openlibrary/plugins/upstream/borrow.py",
        "openlibrary/views/showmarc.py",
        "openlibrary/core/olmarkdown.py",
        "openlibrary/core/bookshelves.py",
        "openlibrary/plugins/upstream/models.py",
        "openlibrary/records/functions.py",
        "openlibrary/plugins/openlibrary/opds.py",
        "openlibrary/plugins/openlibrary/dev_instance.py",
        "openlibrary/views/__init__.py",
        "openlibrary/plugins/upstream/addtag.py",
        "openlibrary/core/lending.py",
        "openlibrary/catalog/utils/edit.py",
        "scripts/import_open_textbook_library.py",
        "openlibrary/views/loanstats.py",
        "openlibrary/plugins/openlibrary/bulk_tag.py",
        "openlibrary/catalog/add_book/match.py"
    ],
    "3_final_combined_files": [
        "openlibrary/plugins/openlibrary/lists.py",
        "openlibrary/core/lists/model.py",
        "openlibrary/core/lists/engine.py",
        "openlibrary/core/models.py"
    ],
    "4_related_elements": {
        "openlibrary/plugins/openlibrary/lists.py": [
            "function: subject_key_to_seed\nfunction: is_seed_subject_string\nclass: ListRecord\nfunction: get_seed_info\nfunction: get_list_data\nclass: lists_partials\nclass: lists_edit\nclass: lists_add\nclass: lists_json\nfunction: get_list\nclass: list_view_json\nclass: list_view_yaml\nfunction: get_list_seeds\nclass: list_seeds\nclass: list_seed_yaml\nclass: lists_embed\nfunction: seed_key_to_seed_type"
        ],
        "openlibrary/core/lists/model.py": [
            "class: SeedDict\nclass: List\nclass: Seed\nclass: ListChangeset"
        ],
        "openlibrary/core/lists/engine.py": [
            "function: reduce_seeds\nfunction: get_seeds"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "openlibrary/core/lists/model.py": [
                    "class: SeedDict\nclass: List\nfunction: List.add_seed\nfunction: List.remove_seed\nfunction: List.get_seeds\nclass: Seed\nfunction: Seed.__init__\nfunction: Seed.dict"
                ],
                "openlibrary/plugins/openlibrary/lists.py": [
                    "class: ListRecord\nfunction: ListRecord.normalize_input_seed\nfunction: ListRecord.from_input\nfunction: ListRecord.to_thing_json\nfunction: lists_json.process_seeds\nclass: list_seeds\nfunction: list_seeds.POST"
                ],
                "openlibrary/core/lists/engine.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/openlibrary/core/lists/model.py b/openlibrary/core/lists/model.py\nindex 5a3d056..826d0e9 100644\n--- a/openlibrary/core/lists/model.py\n+++ b/openlibrary/core/lists/model.py\n@@ -22,8 +22,9 @@ import contextlib\n logger = logging.getLogger(\"openlibrary.lists.model\")\n \n \n-class SeedDict(TypedDict):\n+class SeedDict(TypedDict, total=False):\n     key: ThingKey\n+    note: str\n \n \n SeedSubjectString = str\n@@ -51,6 +52,9 @@ class List(Thing):\n     seeds: list[Thing | SeedSubjectString]\n     \"\"\"Members of the list. Either references or subject strings.\"\"\"\n \n+    seed_notes: dict[ThingKey, str] | None\n+    \"\"\"Optional public Markdown notes keyed by Thing key for non-subject seeds.\"\"\"\n+\n     def url(self, suffix=\"\", **params):\n         return self.get_url(suffix, **params)\n \n@@ -82,25 +86,54 @@ class List(Thing):\n         seed can be:\n             - a `Thing`: author, edition or work object\n             - a key dict: {\"key\": \"...\"} for author, edition or work objects\n+              Optionally supports {\"key\": \"...\", \"note\": \"...\"} to annotate the seed.\n             - a string: for a subject\n         \"\"\"\n+        # If a dict was provided, capture optional note and key before converting to Thing\n         if isinstance(seed, dict):\n-            seed = Thing(self._site, seed['key'], None)\n-\n-        if self._index_of_seed(seed) >= 0:\n-            return False\n+            key = seed.get('key')\n+            if not key:\n+                return False\n+            # Check for duplicate using key string to avoid constructing a Thing unnecessarily\n+            if self._index_of_seed(key) >= 0:\n+                return False\n+            # Store optional note for non-subject seeds\n+            note = seed.get('note')\n+            if note:\n+                self.seed_notes = getattr(self, \"seed_notes\", None) or {}\n+                # Only allow notes for Thing seeds, not subject pseudo-keys\n+                if not isinstance(key, str) or not key.startswith(\"/subjects/\"):\n+                    self.seed_notes[key] = note\n+            # Convert to Thing for storage\n+            seed = Thing(self._site, key, None)\n         else:\n-            self.seeds = self.seeds or []\n-            self.seeds.append(seed)\n-            return True\n+            # For Thing or subject string, perform duplicate check as usual\n+            if self._index_of_seed(seed) >= 0:\n+                return False\n+\n+        self.seeds = self.seeds or []\n+        self.seeds.append(seed)\n+        return True\n \n     def remove_seed(self, seed: Thing | SeedDict | SeedSubjectString):\n         \"\"\"Removes a seed for the list.\"\"\"\n+        key_str: str | None = None\n+\n         if isinstance(seed, dict):\n-            seed = Thing(self._site, seed['key'], None)\n+            key_str = seed.get('key')\n+            if key_str:\n+                seed = Thing(self._site, key_str, None)\n+            else:\n+                return False\n+        elif isinstance(seed, Thing):\n+            key_str = seed.key\n \n         if (index := self._index_of_seed(seed)) >= 0:\n             self.seeds.pop(index)\n+            # Remove any associated note for non-subject seeds\n+            if key_str and not key_str.startswith(\"/subjects/\"):\n+                if getattr(self, \"seed_notes\", None):\n+                    self.seed_notes.pop(key_str, None)\n             return True\n         else:\n             return False\n@@ -508,6 +541,12 @@ class Seed:\n         }\n         if cover := self.get_cover():\n             d['picture'] = {\"url\": cover.url(\"S\")}\n+        # Include optional public note for non-subject seeds\n+        if self.type != \"subject\":\n+            notes = getattr(self._list, \"seed_notes\", None) or {}\n+            note_val = notes.get(self.key)\n+            if note_val is not None:\n+                d[\"note\"] = note_val\n         return d\n \n     def __repr__(self):\ndiff --git a/openlibrary/plugins/openlibrary/lists.py b/openlibrary/plugins/openlibrary/lists.py\nindex 1d12c5f..4368783 100644\n--- a/openlibrary/plugins/openlibrary/lists.py\n+++ b/openlibrary/plugins/openlibrary/lists.py\n@@ -564,6 +564,7 @@ class list_seeds(delegate.page):\n \n         data.setdefault(\"add\", [])\n         data.setdefault(\"remove\", [])\n+        data.setdefault(\"notes\", {})\n \n         # support /subjects/foo and /books/OL1M along with subject:foo and {\"key\": \"/books/OL1M\"}.\n         process_seeds = lists_json().process_seeds\n@@ -574,10 +575,23 @@ class list_seeds(delegate.page):\n         for seed in process_seeds(data[\"remove\"]):\n             lst.remove_seed(seed)\n \n+        # Update notes for existing non-subject seeds\n+        notes = data.get(\"notes\") or {}\n+        if isinstance(notes, dict):\n+            lst.seed_notes = getattr(lst, \"seed_notes\", None) or {}\n+            for k, v in notes.items():\n+                # Only allow notes for Thing seeds\n+                if isinstance(k, str) and k.startswith(('/books', '/works', '/authors')):\n+                    if v:\n+                        lst.seed_notes[k] = v\n+                    else:\n+                        # Empty/None value clears the note\n+                        lst.seed_notes.pop(k, None)\n+\n         seeds = []\n         for seed in data[\"add\"] + data[\"remove\"]:\n             if isinstance(seed, dict):\n-                seeds.append(seed['key'])\n+                seeds.append(seed.get('key'))\n             else:\n                 seeds.append(seed)\n \n@@ -586,6 +600,7 @@ class list_seeds(delegate.page):\n             \"seeds\": seeds,\n             \"add\": data[\"add\"],\n             \"remove\": data[\"remove\"],\n+            \"notes\": data.get(\"notes\", {}),\n         }\n \n         d = lst._save(comment=\"Updated list.\", action=\"lists\", data=changeset_data)\n",
                "diff --git a/openlibrary/core/lists/model.py b/openlibrary/core/lists/model.py\nindex 5a3d056..7cd7585 100644\n--- a/openlibrary/core/lists/model.py\n+++ b/openlibrary/core/lists/model.py\n@@ -22,8 +22,10 @@ import contextlib\n logger = logging.getLogger(\"openlibrary.lists.model\")\n \n \n-class SeedDict(TypedDict):\n+class SeedDict(TypedDict, total=False):\n     key: ThingKey\n+    # Optional public note for Thing seeds (works/editions/authors). Subjects do not support notes.\n+    note: str\n \n \n SeedSubjectString = str\n@@ -81,12 +83,10 @@ class List(Thing):\n \n         seed can be:\n             - a `Thing`: author, edition or work object\n-            - a key dict: {\"key\": \"...\"} for author, edition or work objects\n+            - a key dict: {\"key\": \"...\", \"note\"?: \"...\"} for author, edition or work objects\n             - a string: for a subject\n         \"\"\"\n-        if isinstance(seed, dict):\n-            seed = Thing(self._site, seed['key'], None)\n-\n+        # Do not coerce dict seeds to Thing here, as dicts may include a per-seed public note.\n         if self._index_of_seed(seed) >= 0:\n             return False\n         else:\n@@ -96,18 +96,18 @@ class List(Thing):\n \n     def remove_seed(self, seed: Thing | SeedDict | SeedSubjectString):\n         \"\"\"Removes a seed for the list.\"\"\"\n-        if isinstance(seed, dict):\n-            seed = Thing(self._site, seed['key'], None)\n-\n+        # Support removing by Thing, dict seed (with key/note), or subject string.\n         if (index := self._index_of_seed(seed)) >= 0:\n             self.seeds.pop(index)\n             return True\n         else:\n             return False\n \n-    def _index_of_seed(self, seed: Thing | SeedSubjectString) -> int:\n+    def _index_of_seed(self, seed: Thing | SeedDict | SeedSubjectString) -> int:\n         if isinstance(seed, Thing):\n             seed = seed.key\n+        elif isinstance(seed, dict):\n+            seed = seed['key']\n         for i, s in enumerate(self._get_seed_strings()):\n             if s == seed:\n                 return i\n@@ -117,7 +117,15 @@ class List(Thing):\n         return f\"<List: {self.key} ({self.name!r})>\"\n \n     def _get_seed_strings(self) -> list[SeedSubjectString | ThingKey]:\n-        return [seed if isinstance(seed, str) else seed.key for seed in self.seeds]\n+        result: list[SeedSubjectString | ThingKey] = []\n+        for seed in self.seeds:\n+            if isinstance(seed, str):\n+                result.append(seed)\n+            elif isinstance(seed, dict):\n+                result.append(seed['key'])\n+            else:\n+                result.append(seed.key)\n+        return result\n \n     @cached_property\n     def last_update(self):\n@@ -147,22 +155,47 @@ class List(Thing):\n \n     def get_book_keys(self, offset=0, limit=50):\n         offset = offset or 0\n-        return list(\n-            {\n-                (seed.works[0].key if seed.works else seed.key)\n-                for seed in self.seeds\n-                if seed.key.startswith(('/books', '/works'))\n-            }\n-        )[offset : offset + limit]\n+        keys = set()\n+        for seed in self.seeds:\n+            # Skip subject strings\n+            if isinstance(seed, str):\n+                continue\n+            # Normalize to a Thing for works/editions/authors\n+            if isinstance(seed, dict):\n+                doc = Thing(self._site, seed['key'], None)\n+            else:\n+                doc = seed\n+            if not hasattr(doc, \"key\"):\n+                continue\n+            if doc.key.startswith(('/books', '/works')):\n+                keys.add(doc.works[0].key if getattr(doc, \"works\", None) else doc.key)\n+        return list(keys)[offset : offset + limit]\n \n     def get_editions(self, limit=50, offset=0, _raw=False):\n         \"\"\"Returns the editions objects belonged to this list ordered by last_modified.\n \n         When _raw=True, the edtion dicts are returned instead of edtion objects.\n         \"\"\"\n-        edition_keys = {\n-            seed.key for seed in self.seeds if seed and seed.type.key == '/type/edition'\n-        }\n+        edition_keys: set[str] = set()\n+        for seed in self.seeds:\n+            if not seed:\n+                continue\n+            if isinstance(seed, str):\n+                # subjects don't have editions\n+                continue\n+            if isinstance(seed, dict):\n+                key = seed.get('key')\n+                if key and key.startswith('/books/'):\n+                    edition_keys.add(key)\n+            else:\n+                # Thing\n+                try:\n+                    if seed.type and seed.type.key == '/type/edition':\n+                        edition_keys.add(seed.key)\n+                except Exception:\n+                    # Be safe if shell object isn't fully loaded\n+                    if getattr(seed, \"key\", \"\").startswith(\"/books/\"):\n+                        edition_keys.add(seed.key)\n \n         editions = web.ctx.site.get_many(list(edition_keys))\n \n@@ -186,24 +219,37 @@ class List(Thing):\n         This works even for lists with too many seeds as it doesn't try to\n         return editions in the order of last-modified.\n         \"\"\"\n-        edition_keys = {\n-            seed.key for seed in self.seeds if seed and seed.type.key == '/type/edition'\n-        }\n-\n-        def get_query_term(seed):\n-            if seed.type.key == \"/type/work\":\n-                return \"key:%s\" % seed.key.split(\"/\")[-1]\n-            if seed.type.key == \"/type/author\":\n-                return \"author_key:%s\" % seed.key.split(\"/\")[-1]\n+        # Gather edition keys already present in seeds\n+        edition_keys: set[str] = set()\n+        for seed in self.seeds:\n+            if not seed or isinstance(seed, str):\n+                continue\n+            if isinstance(seed, dict):\n+                key = seed.get('key')\n+                if key and key.startswith('/books/'):\n+                    edition_keys.add(key)\n+            else:\n+                try:\n+                    if seed.type and seed.type.key == '/type/edition':\n+                        edition_keys.add(seed.key)\n+                except Exception:\n+                    if getattr(seed, \"key\", \"\").startswith(\"/books/\"):\n+                        edition_keys.add(seed.key)\n+\n+        def get_query_term_from_seed(raw_seed):\n+            # Only works and authors expand to editions via solr\n+            if isinstance(raw_seed, str):\n+                return None\n+            key = raw_seed['key'] if isinstance(raw_seed, dict) else getattr(raw_seed, \"key\", \"\")\n+            if key.startswith(\"/works/\"):\n+                return \"key:%s\" % key.split(\"/\")[-1]\n+            if key.startswith(\"/authors/\"):\n+                return \"author_key:%s\" % key.split(\"/\")[-1]\n+            return None\n \n-        query_terms = [get_query_term(seed) for seed in self.seeds]\n+        query_terms = [get_query_term_from_seed(seed) for seed in self.seeds]\n         query_terms = [q for q in query_terms if q]  # drop Nones\n-        edition_keys = set(self._get_edition_keys_from_solr(query_terms))\n-\n-        # Add all editions\n-        edition_keys.update(\n-            seed.key for seed in self.seeds if seed and seed.type.key == '/type/edition'\n-        )\n+        edition_keys.update(self._get_edition_keys_from_solr(query_terms) or [])\n \n         return [doc.dict() for doc in web.ctx.site.get_many(list(edition_keys))]\n \n@@ -230,12 +276,16 @@ class List(Thing):\n         # Make one db call to fetch fully loaded Thing instances. By\n         # default they are 'shell' instances that dynamically get fetched\n         # as you access their attributes.\n-        things = cast(\n-            list[Thing],\n-            web.ctx.site.get_many(\n-                [seed.key for seed in self.seeds if isinstance(seed, Thing)]\n-            ),\n-        )\n+        keys: list[str] = []\n+        for seed in self.seeds:\n+            if isinstance(seed, str):\n+                continue\n+            if isinstance(seed, dict):\n+                keys.append(seed['key'])\n+            else:\n+                keys.append(seed.key)\n+\n+        things = cast(list[Thing], web.ctx.site.get_many(keys))\n \n         # Create the return dictionary\n         return {\n@@ -400,16 +450,21 @@ class Seed:\n \n     key: ThingKey | SeedSubjectString\n \n-    value: Thing | SeedSubjectString\n+    value: Thing | SeedSubjectString | SeedDict\n \n-    def __init__(self, list: List, value: Thing | SeedSubjectString):\n+    def __init__(self, list: List, value: Thing | SeedSubjectString | SeedDict):\n         self._list = list\n         self._type = None\n+        self.note = None  # Optional public note for non-subject seeds\n \n         self.value = value\n         if isinstance(value, str):\n             self.key = value\n             self._type = \"subject\"\n+        elif isinstance(value, dict):\n+            # Preserve note for Thing seeds represented as dicts\n+            self.key = value['key']\n+            self.note = value.get('note')\n         else:\n             self.key = value.key\n \n@@ -417,6 +472,9 @@ class Seed:\n     def document(self) -> Subject | Thing:\n         if isinstance(self.value, str):\n             return get_subject(self.get_subject_url(self.value))\n+        elif isinstance(self.value, dict):\n+            # Construct a Thing shell for the given key\n+            return Thing(self._list._site, self.key, None)\n         else:\n             return self.value\n \n@@ -508,6 +566,9 @@ class Seed:\n         }\n         if cover := self.get_cover():\n             d['picture'] = {\"url\": cover.url(\"S\")}\n+        # Include public note only for non-subject seeds\n+        if self.type != \"subject\" and getattr(self, \"note\", None):\n+            d[\"note\"] = self.note\n         return d\n \n     def __repr__(self):\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "openlibrary/core/lists/model.py": [
                    "class: SeedDict\nfunction: List.add_seed\nfunction: List.remove_seed\nfunction: List._index_of_seed\nfunction: List._get_seed_strings\nfunction: List.get_book_keys\nfunction: List.get_editions\nfunction: List.get_all_editions\nfunction: List.get_export_list\nfunction: Seed.__init__\nfunction: Seed.document\nfunction: Seed.dict"
                ],
                "openlibrary/plugins/openlibrary/lists.py": [
                    ""
                ],
                "openlibrary/core/lists/engine.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/openlibrary/core/lists/model.py b/openlibrary/core/lists/model.py\nindex 5a3d056..7957b53 100644\n--- a/openlibrary/core/lists/model.py\n+++ b/openlibrary/core/lists/model.py\n@@ -22,8 +22,9 @@ import contextlib\n logger = logging.getLogger(\"openlibrary.lists.model\")\n \n \n-class SeedDict(TypedDict):\n+class SeedDict(TypedDict, total=False):\n     key: ThingKey\n+    note: str\n \n \n SeedSubjectString = str\n@@ -81,35 +82,48 @@ class List(Thing):\n \n         seed can be:\n             - a `Thing`: author, edition or work object\n-            - a key dict: {\"key\": \"...\"} for author, edition or work objects\n+            - a key dict: {\"key\": \"...\"} for author, edition or work objects (optionally with 'note')\n             - a string: for a subject\n         \"\"\"\n+        normalized = seed\n+        # Do not convert dicts to Thing; preserve optional 'note'\n         if isinstance(seed, dict):\n-            seed = Thing(self._site, seed['key'], None)\n-\n-        if self._index_of_seed(seed) >= 0:\n+            # Ensure only required keys are kept\n+            normalized = {\"key\": seed[\"key\"]}\n+            if isinstance(seed.get(\"note\"), str):\n+                normalized[\"note\"] = seed[\"note\"]\n+\n+        index = self._index_of_seed(normalized)\n+        self.seeds = self.seeds or []\n+        if index >= 0:\n+            # Already present; update any provided note for non-subject seeds\n+            if isinstance(normalized, dict):\n+                self.seeds[index] = normalized\n             return False\n         else:\n-            self.seeds = self.seeds or []\n-            self.seeds.append(seed)\n+            self.seeds.append(normalized)\n             return True\n \n     def remove_seed(self, seed: Thing | SeedDict | SeedSubjectString):\n         \"\"\"Removes a seed for the list.\"\"\"\n-        if isinstance(seed, dict):\n-            seed = Thing(self._site, seed['key'], None)\n-\n-        if (index := self._index_of_seed(seed)) >= 0:\n+        # Compare by key; don't convert dict to Thing to avoid losing metadata\n+        index = self._index_of_seed(seed)\n+        if index >= 0:\n             self.seeds.pop(index)\n             return True\n         else:\n             return False\n \n-    def _index_of_seed(self, seed: Thing | SeedSubjectString) -> int:\n+    def _index_of_seed(self, seed: Thing | SeedDict | SeedSubjectString) -> int:\n+        key: ThingKey | SeedSubjectString | None\n         if isinstance(seed, Thing):\n-            seed = seed.key\n+            key = seed.key\n+        elif isinstance(seed, dict):\n+            key = seed.get('key')\n+        else:\n+            key = seed\n         for i, s in enumerate(self._get_seed_strings()):\n-            if s == seed:\n+            if s == key:\n                 return i\n         return -1\n \n@@ -117,7 +131,15 @@ class List(Thing):\n         return f\"<List: {self.key} ({self.name!r})>\"\n \n     def _get_seed_strings(self) -> list[SeedSubjectString | ThingKey]:\n-        return [seed if isinstance(seed, str) else seed.key for seed in self.seeds]\n+        keys: list[SeedSubjectString | ThingKey] = []\n+        for seed in self.seeds:\n+            if isinstance(seed, str):\n+                keys.append(seed)\n+            elif isinstance(seed, dict):\n+                keys.append(seed['key'])\n+            else:\n+                keys.append(seed.key)\n+        return keys\n \n     @cached_property\n     def last_update(self):\n@@ -147,25 +169,30 @@ class List(Thing):\n \n     def get_book_keys(self, offset=0, limit=50):\n         offset = offset or 0\n-        return list(\n-            {\n-                (seed.works[0].key if seed.works else seed.key)\n-                for seed in self.seeds\n-                if seed.key.startswith(('/books', '/works'))\n-            }\n-        )[offset : offset + limit]\n+        keys = set()\n+        for seed in self.get_seeds():\n+            if seed.type in ('work', 'edition'):\n+                doc = seed.document\n+                # Prefer work key if available from an edition\n+                if seed.type == 'edition' and getattr(doc, 'works', None):\n+                    try:\n+                        work_key = doc.works[0].key\n+                    except Exception:\n+                        work_key = None\n+                    if work_key and work_key.startswith(('/works')):\n+                        keys.add(work_key)\n+                        continue\n+                if doc.key.startswith(('/books', '/works')):\n+                    keys.add(doc.key)\n+        return list(keys)[offset : offset + limit]\n \n     def get_editions(self, limit=50, offset=0, _raw=False):\n         \"\"\"Returns the editions objects belonged to this list ordered by last_modified.\n \n         When _raw=True, the edtion dicts are returned instead of edtion objects.\n         \"\"\"\n-        edition_keys = {\n-            seed.key for seed in self.seeds if seed and seed.type.key == '/type/edition'\n-        }\n-\n+        edition_keys = {s.document.key for s in self.get_seeds() if s.type == 'edition'}\n         editions = web.ctx.site.get_many(list(edition_keys))\n-\n         return {\n             \"count\": len(editions),\n             \"offset\": offset,\n@@ -186,24 +213,19 @@ class List(Thing):\n         This works even for lists with too many seeds as it doesn't try to\n         return editions in the order of last-modified.\n         \"\"\"\n-        edition_keys = {\n-            seed.key for seed in self.seeds if seed and seed.type.key == '/type/edition'\n-        }\n+        # Direct edition seeds\n+        edition_keys = {s.document.key for s in self.get_seeds() if s.type == 'edition'}\n \n-        def get_query_term(seed):\n-            if seed.type.key == \"/type/work\":\n-                return \"key:%s\" % seed.key.split(\"/\")[-1]\n-            if seed.type.key == \"/type/author\":\n-                return \"author_key:%s\" % seed.key.split(\"/\")[-1]\n+        # Build query terms for works and authors to fetch their editions from solr\n+        def get_query_term(seed: 'Seed'):\n+            if seed.type == \"work\":\n+                return \"key:%s\" % seed.document.key.split(\"/\")[-1]\n+            if seed.type == \"author\":\n+                return \"author_key:%s\" % seed.document.key.split(\"/\")[-1]\n \n-        query_terms = [get_query_term(seed) for seed in self.seeds]\n+        query_terms = [get_query_term(s) for s in self.get_seeds()]\n         query_terms = [q for q in query_terms if q]  # drop Nones\n-        edition_keys = set(self._get_edition_keys_from_solr(query_terms))\n-\n-        # Add all editions\n-        edition_keys.update(\n-            seed.key for seed in self.seeds if seed and seed.type.key == '/type/edition'\n-        )\n+        edition_keys.update(self._get_edition_keys_from_solr(query_terms) or [])\n \n         return [doc.dict() for doc in web.ctx.site.get_many(list(edition_keys))]\n \n@@ -402,14 +424,18 @@ class Seed:\n \n     value: Thing | SeedSubjectString\n \n-    def __init__(self, list: List, value: Thing | SeedSubjectString):\n+    def __init__(self, list: List, value: Thing | SeedSubjectString | SeedDict):\n         self._list = list\n         self._type = None\n \n         self.value = value\n+        self.note: str | None = None\n         if isinstance(value, str):\n             self.key = value\n             self._type = \"subject\"\n+        elif isinstance(value, dict):\n+            self.key = value['key']\n+            self.note = value.get('note')\n         else:\n             self.key = value.key\n \n@@ -417,6 +443,8 @@ class Seed:\n     def document(self) -> Subject | Thing:\n         if isinstance(self.value, str):\n             return get_subject(self.get_subject_url(self.value))\n+        elif isinstance(self.value, dict):\n+            return cast(Thing, self._list._site.get(self.value['key']))\n         else:\n             return self.value\n \n@@ -506,6 +534,8 @@ class Seed:\n             \"title\": self.title,\n             \"last_update\": self.last_update and self.last_update.isoformat() or None,\n         }\n+        if self.type != \"subject\" and self.note is not None:\n+            d[\"note\"] = self.note\n         if cover := self.get_cover():\n             d['picture'] = {\"url\": cover.url(\"S\")}\n         return d\n",
                "diff --git a/openlibrary/core/lists/model.py b/openlibrary/core/lists/model.py\nindex 5a3d056..31cd0d9 100644\n--- a/openlibrary/core/lists/model.py\n+++ b/openlibrary/core/lists/model.py\n@@ -83,15 +83,30 @@ class List(Thing):\n             - a `Thing`: author, edition or work object\n             - a key dict: {\"key\": \"...\"} for author, edition or work objects\n             - a string: for a subject\n+\n+        When a dict is provided, an optional 'note' key may be supplied to\n+        annotate the corresponding Thing seed with a public note. Subject\n+        string seeds do not accept notes.\n         \"\"\"\n+        note = None\n         if isinstance(seed, dict):\n+            note = seed.get('note')\n             seed = Thing(self._site, seed['key'], None)\n \n         if self._index_of_seed(seed) >= 0:\n+            # If the seed already exists, update its note if provided\n+            if note and isinstance(seed, Thing):\n+                if not hasattr(self, 'seed_notes') or self.seed_notes is None:\n+                    self.seed_notes = {}\n+                self.seed_notes[seed.key] = note\n             return False\n         else:\n             self.seeds = self.seeds or []\n             self.seeds.append(seed)\n+            if note and isinstance(seed, Thing):\n+                if not hasattr(self, 'seed_notes') or self.seed_notes is None:\n+                    self.seed_notes = {}\n+                self.seed_notes[seed.key] = note\n             return True\n \n     def remove_seed(self, seed: Thing | SeedDict | SeedSubjectString):\n@@ -100,7 +115,14 @@ class List(Thing):\n             seed = Thing(self._site, seed['key'], None)\n \n         if (index := self._index_of_seed(seed)) >= 0:\n-            self.seeds.pop(index)\n+            removed = self.seeds.pop(index)\n+            # Remove any associated note for this seed\n+            try:\n+                removed_key = removed.key\n+            except AttributeError:\n+                removed_key = removed if isinstance(removed, str) else None\n+            if removed_key and hasattr(self, 'seed_notes') and self.seed_notes:\n+                self.seed_notes.pop(removed_key, None)\n             return True\n         else:\n             return False\n@@ -508,6 +530,12 @@ class Seed:\n         }\n         if cover := self.get_cover():\n             d['picture'] = {\"url\": cover.url(\"S\")}\n+        # Include public note for non-subject seeds if present on the list\n+        if self.type != \"subject\":\n+            seed_notes = getattr(self._list, 'seed_notes', {}) or {}\n+            note = seed_notes.get(self.key)\n+            if note:\n+                d['note'] = note\n         return d\n \n     def __repr__(self):\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/openlibrary/core/lists/model.py b/openlibrary/core/lists/model.py\nindex 5a3d056..826d0e9 100644\n--- a/openlibrary/core/lists/model.py\n+++ b/openlibrary/core/lists/model.py\n@@ -22,8 +22,9 @@ import contextlib\n logger = logging.getLogger(\"openlibrary.lists.model\")\n \n \n-class SeedDict(TypedDict):\n+class SeedDict(TypedDict, total=False):\n     key: ThingKey\n+    note: str\n \n \n SeedSubjectString = str\n@@ -51,6 +52,9 @@ class List(Thing):\n     seeds: list[Thing | SeedSubjectString]\n     \"\"\"Members of the list. Either references or subject strings.\"\"\"\n \n+    seed_notes: dict[ThingKey, str] | None\n+    \"\"\"Optional public Markdown notes keyed by Thing key for non-subject seeds.\"\"\"\n+\n     def url(self, suffix=\"\", **params):\n         return self.get_url(suffix, **params)\n \n@@ -82,25 +86,54 @@ class List(Thing):\n         seed can be:\n             - a `Thing`: author, edition or work object\n             - a key dict: {\"key\": \"...\"} for author, edition or work objects\n+              Optionally supports {\"key\": \"...\", \"note\": \"...\"} to annotate the seed.\n             - a string: for a subject\n         \"\"\"\n+        # If a dict was provided, capture optional note and key before converting to Thing\n         if isinstance(seed, dict):\n-            seed = Thing(self._site, seed['key'], None)\n-\n-        if self._index_of_seed(seed) >= 0:\n-            return False\n+            key = seed.get('key')\n+            if not key:\n+                return False\n+            # Check for duplicate using key string to avoid constructing a Thing unnecessarily\n+            if self._index_of_seed(key) >= 0:\n+                return False\n+            # Store optional note for non-subject seeds\n+            note = seed.get('note')\n+            if note:\n+                self.seed_notes = getattr(self, \"seed_notes\", None) or {}\n+                # Only allow notes for Thing seeds, not subject pseudo-keys\n+                if not isinstance(key, str) or not key.startswith(\"/subjects/\"):\n+                    self.seed_notes[key] = note\n+            # Convert to Thing for storage\n+            seed = Thing(self._site, key, None)\n         else:\n-            self.seeds = self.seeds or []\n-            self.seeds.append(seed)\n-            return True\n+            # For Thing or subject string, perform duplicate check as usual\n+            if self._index_of_seed(seed) >= 0:\n+                return False\n+\n+        self.seeds = self.seeds or []\n+        self.seeds.append(seed)\n+        return True\n \n     def remove_seed(self, seed: Thing | SeedDict | SeedSubjectString):\n         \"\"\"Removes a seed for the list.\"\"\"\n+        key_str: str | None = None\n+\n         if isinstance(seed, dict):\n-            seed = Thing(self._site, seed['key'], None)\n+            key_str = seed.get('key')\n+            if key_str:\n+                seed = Thing(self._site, key_str, None)\n+            else:\n+                return False\n+        elif isinstance(seed, Thing):\n+            key_str = seed.key\n \n         if (index := self._index_of_seed(seed)) >= 0:\n             self.seeds.pop(index)\n+            # Remove any associated note for non-subject seeds\n+            if key_str and not key_str.startswith(\"/subjects/\"):\n+                if getattr(self, \"seed_notes\", None):\n+                    self.seed_notes.pop(key_str, None)\n             return True\n         else:\n             return False\n@@ -508,6 +541,12 @@ class Seed:\n         }\n         if cover := self.get_cover():\n             d['picture'] = {\"url\": cover.url(\"S\")}\n+        # Include optional public note for non-subject seeds\n+        if self.type != \"subject\":\n+            notes = getattr(self._list, \"seed_notes\", None) or {}\n+            note_val = notes.get(self.key)\n+            if note_val is not None:\n+                d[\"note\"] = note_val\n         return d\n \n     def __repr__(self):\ndiff --git a/openlibrary/plugins/openlibrary/lists.py b/openlibrary/plugins/openlibrary/lists.py\nindex 1d12c5f..4368783 100644\n--- a/openlibrary/plugins/openlibrary/lists.py\n+++ b/openlibrary/plugins/openlibrary/lists.py\n@@ -564,6 +564,7 @@ class list_seeds(delegate.page):\n \n         data.setdefault(\"add\", [])\n         data.setdefault(\"remove\", [])\n+        data.setdefault(\"notes\", {})\n \n         # support /subjects/foo and /books/OL1M along with subject:foo and {\"key\": \"/books/OL1M\"}.\n         process_seeds = lists_json().process_seeds\n@@ -574,10 +575,23 @@ class list_seeds(delegate.page):\n         for seed in process_seeds(data[\"remove\"]):\n             lst.remove_seed(seed)\n \n+        # Update notes for existing non-subject seeds\n+        notes = data.get(\"notes\") or {}\n+        if isinstance(notes, dict):\n+            lst.seed_notes = getattr(lst, \"seed_notes\", None) or {}\n+            for k, v in notes.items():\n+                # Only allow notes for Thing seeds\n+                if isinstance(k, str) and k.startswith(('/books', '/works', '/authors')):\n+                    if v:\n+                        lst.seed_notes[k] = v\n+                    else:\n+                        # Empty/None value clears the note\n+                        lst.seed_notes.pop(k, None)\n+\n         seeds = []\n         for seed in data[\"add\"] + data[\"remove\"]:\n             if isinstance(seed, dict):\n-                seeds.append(seed['key'])\n+                seeds.append(seed.get('key'))\n             else:\n                 seeds.append(seed)\n \n@@ -586,6 +600,7 @@ class list_seeds(delegate.page):\n             \"seeds\": seeds,\n             \"add\": data[\"add\"],\n             \"remove\": data[\"remove\"],\n+            \"notes\": data.get(\"notes\", {}),\n         }\n \n         d = lst._save(comment=\"Updated list.\", action=\"lists\", data=changeset_data)\n"
}