{
    "instance_id": "SWE-Bench-Pro__python__maintenance__bugfix__cf01f471",
    "original_id": "instance_ansible__ansible-9142be2f6cabbe6597c9254c5bb9186d17036d55-v0f01c69f1e2528b935359cfe578530722bca2c59",
    "1_model_selected_files": [
        "lib/ansible/executor/module_common.py",
        "lib/ansible/executor/interpreter_discovery.py",
        "lib/ansible/executor/task_executor.py",
        "lib/ansible/executor/discovery/python_target.py",
        "lib/ansible/constants.py"
    ],
    "2_embedding_selected_files": [
        "lib/ansible/executor/module_common.py",
        "lib/ansible/executor/interpreter_discovery.py",
        "lib/ansible/plugins/shell/sh.py",
        "lib/ansible/module_utils/common/respawn.py",
        "lib/ansible/plugins/action/script.py",
        "hacking/fix_test_syntax.py",
        "lib/ansible/modules/async_wrapper.py",
        "lib/ansible/modules/script.py",
        "hacking/build-ansible.py",
        "lib/ansible/plugins/become/sudo.py",
        "lib/ansible/modules/shell.py",
        "lib/ansible/plugins/action/__init__.py",
        "lib/ansible/module_utils/facts/system/python.py",
        "lib/ansible/plugins/become/su.py",
        "lib/ansible/modules/raw.py",
        "lib/ansible/module_utils/six/__init__.py",
        "lib/ansible/plugins/inventory/script.py",
        "lib/ansible/modules/setup.py",
        "lib/ansible/plugins/shell/powershell.py",
        "lib/ansible/plugins/action/raw.py",
        "lib/ansible/plugins/action/shell.py",
        "lib/ansible/__init__.py",
        "lib/ansible/modules/replace.py",
        "lib/ansible/plugins/become/runas.py",
        "lib/ansible/modules/cron.py",
        "examples/scripts/my_test.py",
        "lib/ansible/executor/__init__.py",
        "lib/ansible/executor/powershell/module_manifest.py",
        "lib/ansible/plugins/shell/cmd.py",
        "lib/ansible/plugins/doc_fragments/shell_windows.py",
        "ansible/setup.py",
        "lib/ansible/modules/expect.py",
        "lib/ansible/modules/__init__.py",
        "lib/ansible/utils/py3compat.py",
        "lib/ansible/cli/console.py",
        "hacking/build_library/build_ansible/announce.py",
        "lib/ansible/_vendor/__init__.py",
        "docs/docsite/sphinx_conf/ansible_conf.py",
        "lib/ansible/modules/pip.py",
        "lib/ansible/executor/process/__init__.py",
        "packaging/release/versionhelper/version_helper.py",
        "lib/ansible/module_utils/ansible_release.py",
        "lib/ansible/compat/__init__.py",
        "lib/ansible/__main__.py",
        "lib/ansible/modules/command.py",
        "lib/ansible/plugins/action/normal.py",
        "lib/ansible/modules/hostname.py",
        "lib/ansible/modules/apt.py",
        "lib/ansible/module_utils/_text.py",
        "lib/ansible/parsing/mod_args.py",
        "lib/ansible/plugins/action/template.py",
        "lib/ansible/modules/lineinfile.py",
        "lib/ansible/plugins/action/yum.py",
        "lib/ansible/release.py",
        "hacking/build_library/build_ansible/command_plugins/release_announcement.py",
        "lib/ansible/parsing/__init__.py",
        "lib/ansible/utils/hashing.py",
        "lib/ansible/modules/reboot.py",
        "lib/ansible/modules/git.py",
        "hacking/build_library/build_ansible/command_plugins/porting_guide.py",
        "lib/ansible/modules/copy.py",
        "lib/ansible/plugins/shell/__init__.py"
    ],
    "3_final_combined_files": [
        "lib/ansible/executor/module_common.py",
        "lib/ansible/executor/interpreter_discovery.py",
        "lib/ansible/executor/task_executor.py",
        "lib/ansible/plugins/shell/sh.py"
    ],
    "4_related_elements": {
        "lib/ansible/executor/module_common.py": [
            "variable: ANSIBALLZ_TEMPLATE\nvariable: NEW_STYLE_PYTHON_MODULE_RE\nvariable: CORE_LIBRARY_PATH_RE\nvariable: COLLECTION_PATH_RE\nfunction: _get_shebang\nfunction: modify_module\nfunction: _slurp\nfunction: _is_binary\nfunction: get_action_args_with_defaults"
        ],
        "lib/ansible/executor/interpreter_discovery.py": [
            "function: discover_interpreter"
        ],
        "lib/ansible/executor/task_executor.py": [
            "function: _execute\nfunction: _set_connection_options\nfunction: _set_plugin_options\nfunction: _get_action_handler\nfunction: start_connection"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "lib/ansible/executor/module_common.py": [
                    "function: _find_module_utils\nfunction: modify_module"
                ],
                "lib/ansible/executor/interpreter_discovery.py": [
                    ""
                ],
                "lib/ansible/executor/task_executor.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/executor/module_common.py b/lib/ansible/executor/module_common.py\nindex 84e5036..ab3b5d4 100644\n--- a/lib/ansible/executor/module_common.py\n+++ b/lib/ansible/executor/module_common.py\n@@ -1241,9 +1241,19 @@ def _find_module_utils(module_name, b_module_data, module_path, module_args, tas\n                                        'Look at traceback for that process for debugging information.')\n         zipdata = to_text(zipdata, errors='surrogate_or_strict')\n \n-        shebang, interpreter = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n-        if shebang is None:\n-            shebang = u'#!/usr/bin/python'\n+        # Honor the module's declared shebang/interpreter if present; otherwise fall back to default.\n+        b_lines = b_module_data.split(b\"\\n\", 1)\n+        if b_lines and b_lines[0].startswith(b\"#!\"):\n+            b_shebang = b_lines[0].strip()\n+            # Parse interpreter and any arguments from the declared shebang\n+            args = shlex.split(to_native(b_shebang[2:], errors='surrogate_or_strict'))\n+            args = [to_text(a, errors='surrogate_or_strict') for a in args]\n+            declared_interpreter = args[0]\n+            shebang, _interpreter = _get_shebang(declared_interpreter, task_vars, templar, args[1:], remote_is_local=remote_is_local)\n+        else:\n+            shebang, _interpreter = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n+            if shebang is None:\n+                shebang = u'#!/usr/bin/python'\n \n         # FUTURE: the module cache entry should be invalidated if we got this value from a host-dependent source\n         rlimit_nofile = C.config.get_config_value('PYTHON_MODULE_RLIMIT_NOFILE', variables=task_vars)\n",
                "diff --git a/lib/ansible/executor/module_common.py b/lib/ansible/executor/module_common.py\nindex 84e5036..5002a51 100644\n--- a/lib/ansible/executor/module_common.py\n+++ b/lib/ansible/executor/module_common.py\n@@ -612,7 +612,7 @@ def _get_shebang(interpreter, task_vars, templar, args=tuple(), remote_is_local=\n     interpreter_out = None\n \n     # looking for python, rest rely on matching vars\n-    if interpreter_name == 'python':\n+    if interpreter_name.startswith('python'):\n         # skip detection for network os execution, use playbook supplied one if possible\n         if remote_is_local:\n             interpreter_out = task_vars['ansible_playbook_python']\n@@ -1241,9 +1241,31 @@ def _find_module_utils(module_name, b_module_data, module_path, module_args, tas\n                                        'Look at traceback for that process for debugging information.')\n         zipdata = to_text(zipdata, errors='surrogate_or_strict')\n \n-        shebang, interpreter = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n-        if shebang is None:\n-            shebang = u'#!/usr/bin/python'\n+        # Determine interpreter from module's declared shebang if present; otherwise fall back to default.\n+        b_lines = b_module_data.split(b\"\\n\", 1)\n+        declared_interpreter = None\n+        module_declared_shebang = None\n+        if b_lines and b_lines[0].startswith(b\"#!\"):\n+            b_shebang = b_lines[0].strip()\n+            # shlex.split needs native string input\n+            args = shlex.split(to_native(b_shebang[2:], errors='surrogate_or_strict'))\n+            # _get_shebang expects text strings\n+            args = [to_text(a, errors='surrogate_or_strict') for a in args]\n+            declared_interpreter = args[0]\n+            # Apply overrides (inventory/config) if any; otherwise keep original shebang\n+            shebang, _ = _get_shebang(declared_interpreter, task_vars, templar, args[1:], remote_is_local=remote_is_local)\n+            if shebang is None:\n+                module_declared_shebang = to_text(b_shebang, errors='surrogate_or_strict', nonstring='passthru')\n+\n+        if declared_interpreter is None:\n+            # No shebang declared in module, use default interpreter selection\n+            shebang, _ = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n+            if shebang is None:\n+                shebang = u'#!/usr/bin/python'\n+        else:\n+            # Use override if provided; otherwise the module's original shebang\n+            if shebang is None:\n+                shebang = module_declared_shebang\n \n         # FUTURE: the module cache entry should be invalidated if we got this value from a host-dependent source\n         rlimit_nofile = C.config.get_config_value('PYTHON_MODULE_RLIMIT_NOFILE', variables=task_vars)\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "lib/ansible/executor/module_common.py": [
                    "function: _find_module_utils\nfunction: _get_shebang\nfunction: modify_module"
                ],
                "lib/ansible/executor/interpreter_discovery.py": [
                    ""
                ],
                "lib/ansible/executor/task_executor.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/lib/ansible/executor/module_common.py b/lib/ansible/executor/module_common.py\nindex 84e5036..92d94d2 100644\n--- a/lib/ansible/executor/module_common.py\n+++ b/lib/ansible/executor/module_common.py\n@@ -1241,9 +1241,24 @@ def _find_module_utils(module_name, b_module_data, module_path, module_args, tas\n                                        'Look at traceback for that process for debugging information.')\n         zipdata = to_text(zipdata, errors='surrogate_or_strict')\n \n-        shebang, interpreter = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n-        if shebang is None:\n-            shebang = u'#!/usr/bin/python'\n+        # Prefer the module's declared shebang interpreter if present; otherwise fall back to default.\n+        b_lines_for_shebang = b_module_data.split(b\"\\n\", 1)\n+        if b_lines_for_shebang and b_lines_for_shebang[0].startswith(b\"#!\"):\n+            b_shebang_line = b_lines_for_shebang[0].strip()\n+            # Parse interpreter and args from the module's shebang\n+            shebang_parts = shlex.split(to_native(b_shebang_line[2:], errors='surrogate_or_strict'))\n+            shebang_parts = [to_text(p, errors='surrogate_or_strict') for p in shebang_parts]\n+            interpreter = shebang_parts[0]\n+            interpreter_args = shebang_parts[1:]\n+            shebang, _ = _get_shebang(interpreter, task_vars, templar, interpreter_args, remote_is_local=remote_is_local)\n+            # If no override or resolution was applied, preserve the module's original shebang\n+            if shebang is None:\n+                shebang = to_text(b_shebang_line, errors='surrogate_or_strict', nonstring='passthru')\n+        else:\n+            # No shebang in the module, use a sensible default\n+            shebang, _ = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n+            if shebang is None:\n+                shebang = u'#!/usr/bin/python'\n \n         # FUTURE: the module cache entry should be invalidated if we got this value from a host-dependent source\n         rlimit_nofile = C.config.get_config_value('PYTHON_MODULE_RLIMIT_NOFILE', variables=task_vars)\n",
                "diff --git a/lib/ansible/executor/module_common.py b/lib/ansible/executor/module_common.py\nindex 84e5036..aa0019d 100644\n--- a/lib/ansible/executor/module_common.py\n+++ b/lib/ansible/executor/module_common.py\n@@ -1241,9 +1241,36 @@ def _find_module_utils(module_name, b_module_data, module_path, module_args, tas\n                                        'Look at traceback for that process for debugging information.')\n         zipdata = to_text(zipdata, errors='surrogate_or_strict')\n \n-        shebang, interpreter = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n+        # Determine the shebang to use for the ansiballz wrapper.\n+        # Prefer the module's declared shebang unless overridden by inventory/config.\n+        b_first_line = b_module_data.split(b\"\\n\", 1)[0]\n+        orig_shebang = None\n+        orig_interpreter = u'/usr/bin/python'  # sensible default if no shebang is present\n+        orig_args = []\n+\n+        if b_first_line.startswith(b\"#!\"):\n+            b_shebang = b_first_line.strip()\n+            # shlex.split on python-2.6 needs bytes. On python-3.x it needs text.\n+            parsed_args = shlex.split(to_native(b_shebang[2:], errors='surrogate_or_strict'))\n+            # Convert parsed args to text for _get_shebang\n+            parsed_args = [to_text(a, errors='surrogate_or_strict') for a in parsed_args]\n+            if parsed_args:\n+                orig_interpreter = parsed_args[0]\n+                orig_args = parsed_args[1:]\n+            # Preserve the exact original shebang line if no override is requested\n+            orig_shebang = to_text(b_shebang, nonstring='passthru', errors='surrogate_or_strict')\n+\n+        # Consult configuration/inventory for possible interpreter override\n+        shebang, interpreter = _get_shebang(orig_interpreter, task_vars, templar, args=tuple(orig_args), remote_is_local=remote_is_local)\n+\n         if shebang is None:\n-            shebang = u'#!/usr/bin/python'\n+            # No override: honor the module's declared shebang if present; otherwise fallback to default.\n+            if orig_shebang:\n+                shebang = orig_shebang\n+            else:\n+                shebang = u'#!' + orig_interpreter\n+                if orig_args:\n+                    shebang = shebang + u' ' + u' '.join(orig_args)\n \n         # FUTURE: the module cache entry should be invalidated if we got this value from a host-dependent source\n         rlimit_nofile = C.config.get_config_value('PYTHON_MODULE_RLIMIT_NOFILE', variables=task_vars)\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/lib/ansible/executor/module_common.py b/lib/ansible/executor/module_common.py\nindex 84e5036..ab3b5d4 100644\n--- a/lib/ansible/executor/module_common.py\n+++ b/lib/ansible/executor/module_common.py\n@@ -1241,9 +1241,19 @@ def _find_module_utils(module_name, b_module_data, module_path, module_args, tas\n                                        'Look at traceback for that process for debugging information.')\n         zipdata = to_text(zipdata, errors='surrogate_or_strict')\n \n-        shebang, interpreter = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n-        if shebang is None:\n-            shebang = u'#!/usr/bin/python'\n+        # Honor the module's declared shebang/interpreter if present; otherwise fall back to default.\n+        b_lines = b_module_data.split(b\"\\n\", 1)\n+        if b_lines and b_lines[0].startswith(b\"#!\"):\n+            b_shebang = b_lines[0].strip()\n+            # Parse interpreter and any arguments from the declared shebang\n+            args = shlex.split(to_native(b_shebang[2:], errors='surrogate_or_strict'))\n+            args = [to_text(a, errors='surrogate_or_strict') for a in args]\n+            declared_interpreter = args[0]\n+            shebang, _interpreter = _get_shebang(declared_interpreter, task_vars, templar, args[1:], remote_is_local=remote_is_local)\n+        else:\n+            shebang, _interpreter = _get_shebang(u'/usr/bin/python', task_vars, templar, remote_is_local=remote_is_local)\n+            if shebang is None:\n+                shebang = u'#!/usr/bin/python'\n \n         # FUTURE: the module cache entry should be invalidated if we got this value from a host-dependent source\n         rlimit_nofile = C.config.get_config_value('PYTHON_MODULE_RLIMIT_NOFILE', variables=task_vars)\n"
}