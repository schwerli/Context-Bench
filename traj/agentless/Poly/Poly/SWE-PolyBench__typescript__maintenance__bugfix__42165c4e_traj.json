{
    "instance_id": "SWE-PolyBench__typescript__maintenance__bugfix__42165c4e",
    "original_id": "coder__code-server-6278",
    "1_model_selected_files": [
        "src/node/constants.ts",
        "src/node/socket.ts",
        "src/node/cli.ts",
        "src/node/app.ts",
        "src/node/main.ts"
    ],
    "2_embedding_selected_files": [
        "src/node/vscodeSocket.ts",
        "src/node/main.ts",
        "src/node/wrapper.ts",
        "src/node/cli.ts",
        "ci/dev/watch.ts",
        "src/node/routes/vscode.ts",
        "src/node/entry.ts",
        "src/node/socket.ts",
        "src/node/app.ts",
        "src/node/util.ts",
        "src/node/http.ts",
        "src/node/routes/index.ts",
        "typings/pluginapi.d.ts",
        "src/node/settings.ts",
        "src/node/routes/domainProxy.ts",
        "src/node/plugin.ts",
        "src/node/update.ts",
        "src/node/routes/errors.ts",
        "src/common/http.ts",
        "src/node/routes/login.ts",
        "src/node/routes/pathProxy.ts",
        "src/node/constants.ts",
        "src/node/heart.ts",
        "src/node/proxy.ts",
        "src/node/wsRouter.ts",
        "src/common/util.ts",
        "src/node/routes/health.ts",
        "src/browser/serviceWorker.ts",
        "src/node/routes/update.ts",
        "src/node/routes/logout.ts",
        "src/common/emitter.ts",
        "typings/httpolyglot/index.d.ts",
        "src/node/routes/apps.ts",
        "src/node/i18n/index.ts"
    ],
    "3_final_combined_files": [
        "src/node/constants.ts",
        "src/node/socket.ts",
        "src/node/cli.ts",
        "src/node/vscodeSocket.ts",
        "src/node/main.ts",
        "src/node/wrapper.ts"
    ],
    "4_related_elements": {
        "src/node/constants.ts": [
            "variable: tmpdir"
        ],
        "src/node/socket.ts": [
            "class: SocketProxyProvider"
        ],
        "src/node/cli.ts": [
            "function: shouldOpenInExistingInstance\nvariable: options\nfunction: parse\nfunction: setDefaults"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "src/node/cli.ts": [
                    "function: shouldOpenInExistingInstance\nline: 750"
                ],
                "src/node/constants.ts": [
                    ""
                ],
                "src/node/socket.ts": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/node/cli.ts b/src/node/cli.ts\nindex 9fd3126..25ab66c 100644\n--- a/src/node/cli.ts\n+++ b/src/node/cli.ts\n@@ -1,10 +1,11 @@\n+\n import { field, Level, logger } from \"@coder/logger\"\n import { promises as fs } from \"fs\"\n import { load } from \"js-yaml\"\n import * as os from \"os\"\n import * as path from \"path\"\n import { generateCertificate, generatePassword, humanPath, paths, splitOnFirstEquals } from \"./util\"\n-import { DEFAULT_SOCKET_PATH, EditorSessionManagerClient } from \"./vscodeSocket\"\n+import { EditorSessionManagerClient } from \"./vscodeSocket\"\n \n export enum Feature {\n   // No current experimental features!\n@@ -747,7 +748,34 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n   }\n \n   const paths = getResolvedPathsFromArgs(args)\n-  const client = new EditorSessionManagerClient(DEFAULT_SOCKET_PATH)\n+\n+  // Determine a user-specific socket path to avoid clashes across users.\n+  const getUserTag = (): string => {\n+    try {\n+      if (typeof process.getuid === \"function\") {\n+        return String(process.getuid())\n+      }\n+    } catch (e) {\n+      // ignore\n+    }\n+    try {\n+      return os.userInfo().username\n+    } catch (e) {\n+      // fallback to hostname to at least vary\n+      return os.hostname()\n+    }\n+  }\n+\n+  const socketPath = (() => {\n+    if (process.env.CODE_SERVER_SOCKET_PATH && process.env.CODE_SERVER_SOCKET_PATH.trim()) {\n+      return process.env.CODE_SERVER_SOCKET_PATH\n+    }\n+    const baseDir =\n+      process.env.XDG_RUNTIME_DIR && process.env.XDG_RUNTIME_DIR.trim() ? process.env.XDG_RUNTIME_DIR : os.tmpdir()\n+    return path.join(baseDir, `code-server-ipc.${getUserTag()}.sock`)\n+  })()\n+\n+  const client = new EditorSessionManagerClient(socketPath)\n \n   // If we can't connect to the socket then there's no existing instance.\n   if (!(await client.canConnect())) {\n@@ -770,10 +798,10 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n   // 2. That a file or directory was passed.\n   // 3. That the socket is active.\n   if (Object.keys(args).length === 1 && typeof args._ !== \"undefined\" && args._.length > 0) {\n-    const socketPath = await client.getConnectedSocketPath(paths[0])\n-    if (socketPath) {\n+    const connectedSocketPath = await client.getConnectedSocketPath(paths[0])\n+    if (connectedSocketPath) {\n       logger.debug(\"Found existing code-server socket\")\n-      return socketPath\n+      return connectedSocketPath\n     }\n   }\n \n@@ -818,4 +846,4 @@ export const toCodeArgs = async (args: DefaultedArgs): Promise<CodeArgs> => {\n     port: args.port?.toString(),\n     log: args.log ? [args.log] : undefined,\n   }\n-}\n+}\n",
                "diff --git a/src/node/cli.ts b/src/node/cli.ts\nindex 9fd3126..4c296d9 100644\n--- a/src/node/cli.ts\n+++ b/src/node/cli.ts\n@@ -1,3 +1,4 @@\n+\n import { field, Level, logger } from \"@coder/logger\"\n import { promises as fs } from \"fs\"\n import { load } from \"js-yaml\"\n@@ -734,6 +735,18 @@ function bindAddrFromAllSources(...argsConfig: UserProvidedArgs[]): Addr {\n   return addr\n }\n \n+// New helper to compute a per-user IPC socket path to avoid conflicts across users.\n+function getPerUserIpcSocketPath(): string {\n+  if (process.platform === \"win32\") {\n+    // On Windows, rely on the default path provided by VS Code which uses named pipes.\n+    return DEFAULT_SOCKET_PATH\n+  }\n+  const runtimeDir = process.env.XDG_RUNTIME_DIR || os.tmpdir()\n+  const uid =\n+    typeof (process as any).getuid === \"function\" ? (process as any).getuid() : os.userInfo().uid\n+  return path.join(runtimeDir, `code-server-ipc-${uid}.sock`)\n+}\n+\n /**\n  * Determine if it looks like the user is trying to open a file or folder in an\n  * existing instance. The arguments here should be the arguments the user\n@@ -747,7 +760,7 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n   }\n \n   const paths = getResolvedPathsFromArgs(args)\n-  const client = new EditorSessionManagerClient(DEFAULT_SOCKET_PATH)\n+  const client = new EditorSessionManagerClient(getPerUserIpcSocketPath())\n \n   // If we can't connect to the socket then there's no existing instance.\n   if (!(await client.canConnect())) {\n@@ -818,4 +831,4 @@ export const toCodeArgs = async (args: DefaultedArgs): Promise<CodeArgs> => {\n     port: args.port?.toString(),\n     log: args.log ? [args.log] : undefined,\n   }\n-}\n+}\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "src/node/cli.ts": [
                    "function: shouldOpenInExistingInstance\nline: 7\nline: 750"
                ],
                "src/node/constants.ts": [
                    ""
                ],
                "src/node/socket.ts": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/node/cli.ts b/src/node/cli.ts\nindex 9fd3126..9433159 100644\n--- a/src/node/cli.ts\n+++ b/src/node/cli.ts\n@@ -1,10 +1,23 @@\n+\n import { field, Level, logger } from \"@coder/logger\"\n import { promises as fs } from \"fs\"\n import { load } from \"js-yaml\"\n import * as os from \"os\"\n import * as path from \"path\"\n import { generateCertificate, generatePassword, humanPath, paths, splitOnFirstEquals } from \"./util\"\n-import { DEFAULT_SOCKET_PATH, EditorSessionManagerClient } from \"./vscodeSocket\"\n+import { EditorSessionManagerClient } from \"./vscodeSocket\"\n+\n+// Compute a user-specific default IPC socket path to avoid cross-user conflicts.\n+// Allows overriding via CODE_SERVER_IPC_SOCKET environment variable.\n+const getUserIpcSocketPath = (): string => {\n+  if (process.env.CODE_SERVER_IPC_SOCKET) {\n+    return path.resolve(process.env.CODE_SERVER_IPC_SOCKET)\n+  }\n+  const tmp = os.tmpdir()\n+  const uid = typeof process.getuid === \"function\" ? process.getuid() : undefined\n+  const name = uid !== undefined ? `code-server-ipc-${uid}.sock` : `code-server-ipc-${os.userInfo().username}.sock`\n+  return path.join(tmp, name)\n+}\n \n export enum Feature {\n   // No current experimental features!\n@@ -747,7 +760,7 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n   }\n \n   const paths = getResolvedPathsFromArgs(args)\n-  const client = new EditorSessionManagerClient(DEFAULT_SOCKET_PATH)\n+  const client = new EditorSessionManagerClient(getUserIpcSocketPath())\n \n   // If we can't connect to the socket then there's no existing instance.\n   if (!(await client.canConnect())) {\n@@ -818,4 +831,4 @@ export const toCodeArgs = async (args: DefaultedArgs): Promise<CodeArgs> => {\n     port: args.port?.toString(),\n     log: args.log ? [args.log] : undefined,\n   }\n-}\n+}\n",
                "diff --git a/src/node/cli.ts b/src/node/cli.ts\nindex 9fd3126..5b2ecec 100644\n--- a/src/node/cli.ts\n+++ b/src/node/cli.ts\n@@ -1,3 +1,4 @@\n+\n import { field, Level, logger } from \"@coder/logger\"\n import { promises as fs } from \"fs\"\n import { load } from \"js-yaml\"\n@@ -746,11 +747,36 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n     return process.env.VSCODE_IPC_HOOK_CLI\n   }\n \n-  const paths = getResolvedPathsFromArgs(args)\n-  const client = new EditorSessionManagerClient(DEFAULT_SOCKET_PATH)\n+  const resolvedPaths = getResolvedPathsFromArgs(args)\n+  const socketPath = DEFAULT_SOCKET_PATH\n+\n+  // If the socket exists but is owned by another user, ignore it to avoid EPERM.\n+  try {\n+    const st = await fs.lstat(socketPath)\n+    const hasUid = typeof (st as any).uid === \"number\"\n+    const hasGetuid = typeof (process as any).getuid === \"function\"\n+    if (hasUid && hasGetuid && (st as any).uid !== (process as any).getuid()) {\n+      logger.debug(() => [\"Skipping existing instance socket owned by another user\", field(\"socketPath\", socketPath)])\n+      return undefined\n+    }\n+  } catch (err: any) {\n+    // If the socket doesn't exist, proceed. Any other error should not prevent startup.\n+    if (err && err.code !== \"ENOENT\") {\n+      logger.debug(() => [\"Skipping existing instance check due to stat error\", field(\"error\", String(err))])\n+      return undefined\n+    }\n+  }\n+\n+  const client = new EditorSessionManagerClient(socketPath)\n \n-  // If we can't connect to the socket then there's no existing instance.\n-  if (!(await client.canConnect())) {\n+  // If we can't connect to the socket or encounter a permission error,\n+  // then there's no existing instance for this user.\n+  try {\n+    if (!(await client.canConnect())) {\n+      return undefined\n+    }\n+  } catch (err: any) {\n+    logger.debug(() => [\"Skipping existing instance check due to connect error\", field(\"error\", String(err))])\n     return undefined\n   }\n \n@@ -761,7 +787,12 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n   }, 0)\n   if (openInFlagCount > 0) {\n     logger.debug(\"Found --reuse-window or --new-window\")\n-    return await client.getConnectedSocketPath(paths[0])\n+    try {\n+      return await client.getConnectedSocketPath(resolvedPaths[0])\n+    } catch (err: any) {\n+      logger.debug(() => [\"Failed to get connected socket path\", field(\"error\", String(err))])\n+      return undefined\n+    }\n   }\n \n   // It's possible the user is trying to spawn another instance of code-server.\n@@ -770,10 +801,15 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n   // 2. That a file or directory was passed.\n   // 3. That the socket is active.\n   if (Object.keys(args).length === 1 && typeof args._ !== \"undefined\" && args._.length > 0) {\n-    const socketPath = await client.getConnectedSocketPath(paths[0])\n-    if (socketPath) {\n-      logger.debug(\"Found existing code-server socket\")\n-      return socketPath\n+    try {\n+      const connectedSocketPath = await client.getConnectedSocketPath(resolvedPaths[0])\n+      if (connectedSocketPath) {\n+        logger.debug(\"Found existing code-server socket\")\n+        return connectedSocketPath\n+      }\n+    } catch (err: any) {\n+      logger.debug(() => [\"Failed to get connected socket path\", field(\"error\", String(err))])\n+      // Fall through to start a new instance.\n     }\n   }\n \n@@ -818,4 +854,4 @@ export const toCodeArgs = async (args: DefaultedArgs): Promise<CodeArgs> => {\n     port: args.port?.toString(),\n     log: args.log ? [args.log] : undefined,\n   }\n-}\n+}\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/src/node/cli.ts b/src/node/cli.ts\nindex 9fd3126..25ab66c 100644\n--- a/src/node/cli.ts\n+++ b/src/node/cli.ts\n@@ -1,10 +1,11 @@\n+\n import { field, Level, logger } from \"@coder/logger\"\n import { promises as fs } from \"fs\"\n import { load } from \"js-yaml\"\n import * as os from \"os\"\n import * as path from \"path\"\n import { generateCertificate, generatePassword, humanPath, paths, splitOnFirstEquals } from \"./util\"\n-import { DEFAULT_SOCKET_PATH, EditorSessionManagerClient } from \"./vscodeSocket\"\n+import { EditorSessionManagerClient } from \"./vscodeSocket\"\n \n export enum Feature {\n   // No current experimental features!\n@@ -747,7 +748,34 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n   }\n \n   const paths = getResolvedPathsFromArgs(args)\n-  const client = new EditorSessionManagerClient(DEFAULT_SOCKET_PATH)\n+\n+  // Determine a user-specific socket path to avoid clashes across users.\n+  const getUserTag = (): string => {\n+    try {\n+      if (typeof process.getuid === \"function\") {\n+        return String(process.getuid())\n+      }\n+    } catch (e) {\n+      // ignore\n+    }\n+    try {\n+      return os.userInfo().username\n+    } catch (e) {\n+      // fallback to hostname to at least vary\n+      return os.hostname()\n+    }\n+  }\n+\n+  const socketPath = (() => {\n+    if (process.env.CODE_SERVER_SOCKET_PATH && process.env.CODE_SERVER_SOCKET_PATH.trim()) {\n+      return process.env.CODE_SERVER_SOCKET_PATH\n+    }\n+    const baseDir =\n+      process.env.XDG_RUNTIME_DIR && process.env.XDG_RUNTIME_DIR.trim() ? process.env.XDG_RUNTIME_DIR : os.tmpdir()\n+    return path.join(baseDir, `code-server-ipc.${getUserTag()}.sock`)\n+  })()\n+\n+  const client = new EditorSessionManagerClient(socketPath)\n \n   // If we can't connect to the socket then there's no existing instance.\n   if (!(await client.canConnect())) {\n@@ -770,10 +798,10 @@ export const shouldOpenInExistingInstance = async (args: UserProvidedArgs): Prom\n   // 2. That a file or directory was passed.\n   // 3. That the socket is active.\n   if (Object.keys(args).length === 1 && typeof args._ !== \"undefined\" && args._.length > 0) {\n-    const socketPath = await client.getConnectedSocketPath(paths[0])\n-    if (socketPath) {\n+    const connectedSocketPath = await client.getConnectedSocketPath(paths[0])\n+    if (connectedSocketPath) {\n       logger.debug(\"Found existing code-server socket\")\n-      return socketPath\n+      return connectedSocketPath\n     }\n   }\n \n@@ -818,4 +846,4 @@ export const toCodeArgs = async (args: DefaultedArgs): Promise<CodeArgs> => {\n     port: args.port?.toString(),\n     log: args.log ? [args.log] : undefined,\n   }\n-}\n+}\n"
}