{
    "instance_id": "SWE-PolyBench__javascript__maintenance__bugfix__78039f77",
    "original_id": "sveltejs__svelte-1310",
    "1_model_selected_files": [
        "src/shared/spread.js"
    ],
    "2_embedding_selected_files": [
        "src/generators/dom/index.ts",
        "src/css/Stylesheet.ts",
        "src/generators/nodes/Element.ts",
        "src/generators/nodes/Attribute.ts",
        "src/generators/server-side-rendering/index.ts",
        "src/css/Selector.ts",
        "src/generators/nodes/Component.ts",
        "src/parse/read/style.ts",
        "src/validate/js/propValidators/onrender.ts",
        "src/utils/stringifyProps.ts",
        "src/validate/js/propValidators/components.ts",
        "svelte/store.js",
        "src/generators/Generator.ts",
        "src/generators/server-side-rendering/visitors/Element.ts",
        "src/generators/nodes/Text.ts",
        "src/utils/fixAttributeCasing.ts",
        "src/validate/js/propValidators/props.ts",
        "src/shared/transitions.js",
        "src/index.ts",
        "src/generators/dom/Block.ts",
        "src/generators/nodes/RawMustacheTag.ts",
        "src/validate/js/propValidators/computed.ts",
        "src/shared/index.js",
        "src/parse/state/mustache.ts",
        "src/generators/server-side-rendering/visitors/Component.ts",
        "src/validate/js/propValidators/onteardown.ts",
        "src/validate/html/validateElement.ts",
        "src/generators/nodes/Slot.ts",
        "src/parse/state/text.ts",
        "src/parse/state/tag.ts",
        "src/generators/nodes/shared/mungeAttribute.ts",
        "src/generators/nodes/Title.ts",
        "src/generators/nodes/MustacheTag.ts",
        "src/validate/js/propValidators/ondestroy.ts",
        "src/validate/js/propValidators/index.ts",
        "src/generators/server-side-rendering/visitors/shared/stringifyAttributeValue.ts",
        "src/generators/server-side-rendering/visitors/Text.ts",
        "src/generators/server-side-rendering/visitors/MustacheTag.ts",
        "src/validate/js/propValidators/data.ts",
        "src/shared/_build.js",
        "src/css/gatherPossibleValues.ts",
        "src/validate/js/propValidators/setup.ts",
        "src/generators/nodes/shared/Tag.ts",
        "src/validate/js/index.ts",
        "src/validate/js/propValidators/events.ts",
        "src/generators/nodes/EachBlock.ts",
        "src/validate/js/utils/checkForDupes.ts",
        "src/shared/dom.js",
        "src/validate/js/propValidators/transitions.ts",
        "svelte/rollup.config.js",
        "src/generators/nodes/Binding.ts",
        "src/parse/utils/html.ts",
        "src/parse/utils/entities.ts",
        "src/validate/js/propValidators/helpers.ts",
        "src/parse/state/fragment.ts",
        "src/validate/js/propValidators/actions.ts",
        "src/shared/keyed-each.js"
    ],
    "3_final_combined_files": [
        "src/shared/spread.js",
        "src/generators/dom/index.ts",
        "src/css/Stylesheet.ts",
        "src/generators/nodes/Element.ts"
    ],
    "4_related_elements": {
        "src/shared/spread.js": [
            "function: getSpreadUpdate"
        ],
        "src/generators/dom/index.ts": [
            "class: DomGenerator\nfunction: dom"
        ],
        "src/css/Stylesheet.ts": [
            "class: Stylesheet\nclass: Rule\nclass: Atrule"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "src/css/Stylesheet.ts": [
                    "function: Rule.isUsed\nfunction: Rule.apply"
                ],
                "src/shared/spread.js": [
                    ""
                ],
                "src/generators/dom/index.ts": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/css/Stylesheet.ts b/src/css/Stylesheet.ts\nindex 1fb071a..3d81f0e 100644\n--- a/src/css/Stylesheet.ts\n+++ b/src/css/Stylesheet.ts\n@@ -13,22 +13,29 @@ class Rule {\n \tdeclarations: Declaration[];\n \tnode: Node;\n \tparent: Atrule;\n+\thasSpread: boolean;\n \n \tconstructor(node: Node, stylesheet, parent?: Atrule) {\n \t\tthis.node = node;\n \t\tthis.parent = parent;\n+\t\tthis.hasSpread = false;\n \t\tthis.selectors = node.selector.children.map((node: Node) => new Selector(node, stylesheet));\n \t\tthis.declarations = node.block.children.map((node: Node) => new Declaration(node));\n \t}\n \n \tapply(node: Element, stack: Element[]) {\n \t\tthis.selectors.forEach(selector => selector.apply(node, stack)); // TODO move the logic in here?\n+\t\t// If the element has spread props, we cannot determine classes/attributes statically.\n+\t\t// Mark this stylesheet as having dynamic attributes so rules are preserved.\n+\t\tif (node && node.attributes && node.attributes.some(attr => attr.type === 'Spread')) {\n+\t\t\tthis.hasSpread = true;\n+\t\t}\n \t}\n \n \tisUsed(dev: boolean) {\n \t\tif (this.parent && this.parent.node.type === 'Atrule' && this.parent.node.name === 'keyframes') return true;\n \t\tif (this.declarations.length === 0) return dev;\n-\t\treturn this.selectors.some(s => s.used);\n+\t\treturn this.hasSpread || this.selectors.some(s => s.used);\n \t}\n \n \tminify(code: MagicString, cascade: boolean, dev: boolean) {\n",
                "diff --git a/src/css/Stylesheet.ts b/src/css/Stylesheet.ts\nindex 1fb071a..32e0ac8 100644\n--- a/src/css/Stylesheet.ts\n+++ b/src/css/Stylesheet.ts\n@@ -270,6 +270,7 @@ export default class Stylesheet {\n \n \thasStyles: boolean;\n \tid: string;\n+\thasAttributeSpread: boolean;\n \n \tchildren: (Rule|Atrule)[];\n \tkeyframes: Map<string, string>;\n@@ -287,6 +288,20 @@ export default class Stylesheet {\n \t\tthis.keyframes = new Map();\n \n \t\tthis.nodesWithCssClass = new Set();\n+\t\tthis.hasAttributeSpread = false;\n+\n+\t\tif (this.parsed && (this.parsed as any).html) {\n+\t\t\twalk((this.parsed as any).html, {\n+\t\t\t\tenter: (node: Node) => {\n+\t\t\t\t\tif ((node as any).type === 'Attribute' && (node as any).isSpread) {\n+\t\t\t\t\t\tthis.hasAttributeSpread = true;\n+\t\t\t\t\t}\n+\t\t\t\t\tif ((node as any).type === 'Spread') {\n+\t\t\t\t\t\tthis.hasAttributeSpread = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n \n \t\tif (parsed.css && parsed.css.children.length) {\n \t\t\tthis.id = `svelte-${hash(parsed.css.content.styles)}`;\n@@ -395,7 +410,7 @@ export default class Stylesheet {\n \n \t\tlet c = 0;\n \t\tthis.children.forEach(child => {\n-\t\t\tif (this.cascade || child.isUsed(this.dev)) {\n+\t\t\tif (this.cascade || this.hasAttributeSpread || child.isUsed(this.dev)) {\n \t\t\t\tcode.remove(c, child.node.start);\n \t\t\t\tchild.minify(code, this.cascade, this.dev);\n \t\t\t\tc = child.node.end;\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "src/css/Stylesheet.ts": [
                    "function: Rule.isUsed\nfunction: Stylesheet.constructor\nfunction: Stylesheet.render\nfunction: Stylesheet.warnOnUnusedSelectors"
                ],
                "src/shared/spread.js": [
                    ""
                ],
                "src/generators/dom/index.ts": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/css/Stylesheet.ts b/src/css/Stylesheet.ts\nindex 1fb071a..d57a35f 100644\n--- a/src/css/Stylesheet.ts\n+++ b/src/css/Stylesheet.ts\n@@ -22,6 +22,24 @@ class Rule {\n \t}\n \n \tapply(node: Element, stack: Element[]) {\n+\t\t// If the element has a spread of attributes (e.g. {{...props}}),\n+\t\t// we can't accurately determine which selectors might match at build time.\n+\t\t// Conservatively mark selectors as used so CSS isn't incorrectly DCE'd.\n+\t\tconst anyNode: any = node;\n+\t\tconst attrs = (anyNode && anyNode.attributes) || [];\n+\t\tconst hasSpread = Array.isArray(attrs) && attrs.some((attr: any) => {\n+\t\t\treturn attr && (\n+\t\t\t\tattr.type === 'Spread' ||\n+\t\t\t\t(attr.type === 'Attribute' && (attr.isSpread || attr.spread))\n+\t\t\t);\n+\t\t});\n+\n+\t\tif (hasSpread) {\n+\t\t\tthis.selectors.forEach(selector => {\n+\t\t\t\t(selector as any).used = true;\n+\t\t\t});\n+\t\t}\n+\n \t\tthis.selectors.forEach(selector => selector.apply(node, stack)); // TODO move the logic in here?\n \t}\n \n",
                "diff --git a/src/css/Stylesheet.ts b/src/css/Stylesheet.ts\nindex 1fb071a..2fc9ef9 100644\n--- a/src/css/Stylesheet.ts\n+++ b/src/css/Stylesheet.ts\n@@ -275,6 +275,7 @@ export default class Stylesheet {\n \tkeyframes: Map<string, string>;\n \n \tnodesWithCssClass: Set<Node>;\n+\thasSpreadAttributes: boolean;\n \n \tconstructor(source: string, parsed: Parsed, filename: string, cascade: boolean, dev: boolean) {\n \t\tthis.source = source;\n@@ -287,6 +288,7 @@ export default class Stylesheet {\n \t\tthis.keyframes = new Map();\n \n \t\tthis.nodesWithCssClass = new Set();\n+\t\tthis.hasSpreadAttributes = false;\n \n \t\tif (parsed.css && parsed.css.children.length) {\n \t\t\tthis.id = `svelte-${hash(parsed.css.content.styles)}`;\n@@ -350,6 +352,13 @@ export default class Stylesheet {\n \tapply(node: Element) {\n \t\tif (!this.hasStyles) return;\n \n+\t\t// If the element has a spread attribute, it may receive classes dynamically.\n+\t\t// Preserve CSS (disable DCE) and ensure the scoping class is applied to this node.\n+\t\tif ((<any>node).attributes && (<any>node).attributes.some((attr: any) => attr.type === 'Spread')) {\n+\t\t\tthis.hasSpreadAttributes = true;\n+\t\t\tthis.nodesWithCssClass.add(node);\n+\t\t}\n+\n \t\tconst stack: Element[] = [];\n \t\tlet parent: Node = node;\n \t\twhile (parent = parent.parent) {\n@@ -395,7 +404,7 @@ export default class Stylesheet {\n \n \t\tlet c = 0;\n \t\tthis.children.forEach(child => {\n-\t\t\tif (this.cascade || child.isUsed(this.dev)) {\n+\t\t\tif (this.cascade || this.hasSpreadAttributes || child.isUsed(this.dev)) {\n \t\t\t\tcode.remove(c, child.node.start);\n \t\t\t\tchild.minify(code, this.cascade, this.dev);\n \t\t\t\tc = child.node.end;\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/src/css/Stylesheet.ts b/src/css/Stylesheet.ts\nindex 1fb071a..3d81f0e 100644\n--- a/src/css/Stylesheet.ts\n+++ b/src/css/Stylesheet.ts\n@@ -13,22 +13,29 @@ class Rule {\n \tdeclarations: Declaration[];\n \tnode: Node;\n \tparent: Atrule;\n+\thasSpread: boolean;\n \n \tconstructor(node: Node, stylesheet, parent?: Atrule) {\n \t\tthis.node = node;\n \t\tthis.parent = parent;\n+\t\tthis.hasSpread = false;\n \t\tthis.selectors = node.selector.children.map((node: Node) => new Selector(node, stylesheet));\n \t\tthis.declarations = node.block.children.map((node: Node) => new Declaration(node));\n \t}\n \n \tapply(node: Element, stack: Element[]) {\n \t\tthis.selectors.forEach(selector => selector.apply(node, stack)); // TODO move the logic in here?\n+\t\t// If the element has spread props, we cannot determine classes/attributes statically.\n+\t\t// Mark this stylesheet as having dynamic attributes so rules are preserved.\n+\t\tif (node && node.attributes && node.attributes.some(attr => attr.type === 'Spread')) {\n+\t\t\tthis.hasSpread = true;\n+\t\t}\n \t}\n \n \tisUsed(dev: boolean) {\n \t\tif (this.parent && this.parent.node.type === 'Atrule' && this.parent.node.name === 'keyframes') return true;\n \t\tif (this.declarations.length === 0) return dev;\n-\t\treturn this.selectors.some(s => s.used);\n+\t\treturn this.hasSpread || this.selectors.some(s => s.used);\n \t}\n \n \tminify(code: MagicString, cascade: boolean, dev: boolean) {\n"
}