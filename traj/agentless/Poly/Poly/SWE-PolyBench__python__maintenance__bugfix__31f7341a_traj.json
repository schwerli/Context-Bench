{
    "instance_id": "SWE-PolyBench__python__maintenance__bugfix__31f7341a",
    "original_id": "keras-team__keras-19838",
    "1_model_selected_files": [
        "keras/src/losses/losses.py",
        "keras/src/losses/losses_test.py"
    ],
    "2_embedding_selected_files": [
        "keras/src/legacy/backend.py",
        "keras/src/layers/preprocessing/hashed_crossing_test.py",
        "keras/src/ops/nn_test.py",
        "keras/src/trainers/data_adapters/tf_dataset_adapter_test.py",
        "keras/src/backend/numpy/nn.py",
        "keras/src/applications/imagenet_utils_test.py",
        "keras/src/ops/numpy_test.py",
        "keras/src/layers/core/dense_test.py",
        "keras/src/ops/numpy.py",
        "keras/src/ops/nn.py",
        "keras/src/layers/reshaping/up_sampling1d_test.py",
        "keras/src/layers/reshaping/reshape_test.py",
        "keras/src/backend/torch/nn.py",
        "keras/src/layers/reshaping/flatten_test.py",
        "keras/src/layers/reshaping/up_sampling3d_test.py",
        "keras/src/metrics/accuracy_metrics_test.py",
        "keras/src/layers/regularization/spatial_dropout_test.py",
        "keras/src/ops/image_test.py",
        "keras/src/backend/jax/nn.py",
        "keras/src/layers/preprocessing/category_encoding_test.py",
        "keras/src/losses/losses_test.py",
        "keras/src/layers/convolutional/conv_transpose_test.py",
        "keras/src/layers/reshaping/cropping3d_test.py",
        "keras/src/layers/attention/multi_head_attention_test.py",
        "keras/src/layers/convolutional/depthwise_conv_test.py",
        "keras/src/layers/preprocessing/random_crop_test.py",
        "keras/src/losses/loss_test.py",
        "keras/src/layers/core/input_layer_test.py",
        "keras/src/layers/convolutional/conv_test.py",
        "keras/src/layers/preprocessing/resizing_test.py",
        "keras/src/backend/tensorflow/nn.py",
        "keras/src/optimizers/optimizer_sparse_test.py",
        "keras/src/losses/losses.py",
        "keras/src/layers/convolutional/separable_conv_test.py",
        "keras/src/metrics/f_score_metrics_test.py",
        "keras/src/layers/reshaping/cropping2d_test.py",
        "keras/src/ops/math_test.py",
        "keras/src/layers/reshaping/cropping1d_test.py",
        "keras/src/backend/tensorflow/numpy.py",
        "keras/src/layers/reshaping/permute_test.py",
        "keras/src/layers/preprocessing/center_crop_test.py",
        "keras/src/layers/preprocessing/random_flip_test.py",
        "keras/src/layers/reshaping/up_sampling2d_test.py",
        "keras/src/layers/preprocessing/hashing_test.py",
        "integration_tests/dataset_tests/cifar10_test.py",
        "keras/src/layers/preprocessing/feature_space_test.py"
    ],
    "3_final_combined_files": [
        "keras/src/losses/losses.py",
        "keras/src/losses/losses_test.py",
        "keras/src/legacy/backend.py",
        "keras/src/layers/preprocessing/hashed_crossing_test.py",
        "keras/src/ops/nn_test.py"
    ],
    "4_related_elements": {
        "keras/src/losses/losses.py": [
            "function: sparse_categorical_crossentropy\nclass: SparseCategoricalCrossentropy\nclass: LossFunctionWrapper\nfunction: categorical_crossentropy"
        ],
        "keras/src/legacy/backend.py": [
            "function: sparse_categorical_crossentropy\nfunction: categorical_crossentropy\nfunction: expand_dims\nfunction: one_hot"
        ],
        "keras/src/losses/losses_test.py": [
            "class: SparseCategoricalCrossentropyTest"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "keras/src/losses/losses.py": [
                    "function: sparse_categorical_crossentropy\nline: 1715\nline: 1716\nline: 1717\nline: 1718\nline: 1719"
                ],
                "keras/src/losses/losses_test.py": [
                    ""
                ],
                "keras/src/legacy/backend.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/keras/src/losses/losses.py b/keras/src/losses/losses.py\nindex 8bb588b..70208d6 100644\n--- a/keras/src/losses/losses.py\n+++ b/keras/src/losses/losses.py\n@@ -1713,11 +1713,14 @@ def sparse_categorical_crossentropy(\n \n     if ignore_class is not None:\n         res_shape = ops.shape(y_pred)[:-1]\n-        valid_mask = ops.not_equal(y_true, ops.cast(ignore_class, y_pred.dtype))\n+        # Build a boolean mask of valid (non-ignored) targets.\n+        valid_mask = ops.not_equal(y_true, ops.cast(ignore_class, y_true.dtype))\n+        # Zero-out ignored positions in y_true to keep labels in a valid range.\n         y_true = y_true * ops.cast(valid_mask, y_true.dtype)\n-        y_pred = y_pred * ops.cast(\n-            ops.expand_dims(valid_mask, -1), y_pred.dtype\n-        )\n+        # Apply the same mask to y_pred. Rely on broadcasting instead of\n+        # expanding dims so that 4D targets (e.g., [..., 1]) don't produce\n+        # a 5D output tensor.\n+        y_pred = y_pred * ops.cast(valid_mask, y_pred.dtype)\n \n     res = ops.sparse_categorical_crossentropy(\n         y_true,\n",
                "diff --git a/keras/src/losses/losses.py b/keras/src/losses/losses.py\nindex 8bb588b..21a45fc 100644\n--- a/keras/src/losses/losses.py\n+++ b/keras/src/losses/losses.py\n@@ -1712,11 +1712,18 @@ def sparse_categorical_crossentropy(\n     \"\"\"\n \n     if ignore_class is not None:\n+        # Create a mask of valid (non-ignored) targets.\n         res_shape = ops.shape(y_pred)[:-1]\n-        valid_mask = ops.not_equal(y_true, ops.cast(ignore_class, y_pred.dtype))\n-        y_true = y_true * ops.cast(valid_mask, y_true.dtype)\n+        valid_mask_y_true = ops.not_equal(\n+            y_true, ops.cast(ignore_class, y_pred.dtype)\n+        )\n+        # Zero-out ignored target indices to avoid out-of-range errors.\n+        y_true = y_true * ops.cast(valid_mask_y_true, y_true.dtype)\n+        # Reshape mask to match y_pred excluding the class axis.\n+        valid_mask_pred = ops.reshape(valid_mask_y_true, res_shape)\n+        # Apply the mask to predictions.\n         y_pred = y_pred * ops.cast(\n-            ops.expand_dims(valid_mask, -1), y_pred.dtype\n+            ops.expand_dims(valid_mask_pred, -1), y_pred.dtype\n         )\n \n     res = ops.sparse_categorical_crossentropy(\n@@ -1727,11 +1734,10 @@ def sparse_categorical_crossentropy(\n     )\n \n     if ignore_class is not None:\n-        valid_mask = ops.reshape(valid_mask, res_shape)\n-        res = ops.where(valid_mask, res, 0.0)\n+        res = ops.where(valid_mask_pred, res, 0.0)\n \n         try:\n-            res._keras_mask = valid_mask\n+            res._keras_mask = valid_mask_pred\n         except AttributeError:\n             pass\n \n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "keras/src/losses/losses.py": [
                    "function: sparse_categorical_crossentropy\nline: 1718\nline: 1719\nline: 1720"
                ],
                "keras/src/losses/losses_test.py": [
                    ""
                ],
                "keras/src/legacy/backend.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/keras/src/losses/losses.py b/keras/src/losses/losses.py\nindex 8bb588b..5ee24de 100644\n--- a/keras/src/losses/losses.py\n+++ b/keras/src/losses/losses.py\n@@ -1715,9 +1715,10 @@ def sparse_categorical_crossentropy(\n         res_shape = ops.shape(y_pred)[:-1]\n         valid_mask = ops.not_equal(y_true, ops.cast(ignore_class, y_pred.dtype))\n         y_true = y_true * ops.cast(valid_mask, y_true.dtype)\n-        y_pred = y_pred * ops.cast(\n-            ops.expand_dims(valid_mask, -1), y_pred.dtype\n-        )\n+        # Multiply directly with the valid_mask; broadcasting will handle\n+        # both cases where y_true has rank equal to y_pred (with a singleton\n+        # class dimension) or rank one less (no class dimension).\n+        y_pred = y_pred * ops.cast(valid_mask, y_pred.dtype)\n \n     res = ops.sparse_categorical_crossentropy(\n         y_true,\n",
                "diff --git a/keras/src/losses/losses.py b/keras/src/losses/losses.py\nindex 8bb588b..2cb54cc 100644\n--- a/keras/src/losses/losses.py\n+++ b/keras/src/losses/losses.py\n@@ -1715,8 +1715,10 @@ def sparse_categorical_crossentropy(\n         res_shape = ops.shape(y_pred)[:-1]\n         valid_mask = ops.not_equal(y_true, ops.cast(ignore_class, y_pred.dtype))\n         y_true = y_true * ops.cast(valid_mask, y_true.dtype)\n+        # Broadcast the mask to the shape of y_pred so it can be applied\n+        # across the class axis regardless of input rank/layout.\n         y_pred = y_pred * ops.cast(\n-            ops.expand_dims(valid_mask, -1), y_pred.dtype\n+            ops.broadcast_to(valid_mask, ops.shape(y_pred)), y_pred.dtype\n         )\n \n     res = ops.sparse_categorical_crossentropy(\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/keras/src/losses/losses.py b/keras/src/losses/losses.py\nindex 8bb588b..70208d6 100644\n--- a/keras/src/losses/losses.py\n+++ b/keras/src/losses/losses.py\n@@ -1713,11 +1713,14 @@ def sparse_categorical_crossentropy(\n \n     if ignore_class is not None:\n         res_shape = ops.shape(y_pred)[:-1]\n-        valid_mask = ops.not_equal(y_true, ops.cast(ignore_class, y_pred.dtype))\n+        # Build a boolean mask of valid (non-ignored) targets.\n+        valid_mask = ops.not_equal(y_true, ops.cast(ignore_class, y_true.dtype))\n+        # Zero-out ignored positions in y_true to keep labels in a valid range.\n         y_true = y_true * ops.cast(valid_mask, y_true.dtype)\n-        y_pred = y_pred * ops.cast(\n-            ops.expand_dims(valid_mask, -1), y_pred.dtype\n-        )\n+        # Apply the same mask to y_pred. Rely on broadcasting instead of\n+        # expanding dims so that 4D targets (e.g., [..., 1]) don't produce\n+        # a 5D output tensor.\n+        y_pred = y_pred * ops.cast(valid_mask, y_pred.dtype)\n \n     res = ops.sparse_categorical_crossentropy(\n         y_true,\n"
}