{
    "instance_id": "SWE-PolyBench__typescript__maintenance__bugfix__708894b2",
    "original_id": "microsoft__vscode-110094",
    "1_model_selected_files": [
        "src/vs/editor/common/controller/cursorTypeOperations.ts",
        "src/vs/editor/common/modes/supports/characterPair.ts",
        "src/vs/editor/common/modes/languageConfiguration.ts",
        "src/vs/workbench/contrib/codeEditor/browser/languageConfigurationExtensionPoint.ts",
        "src/vs/editor/common/controller/cursor.ts"
    ],
    "2_embedding_selected_files": [
        "src/vs/editor/common/modes/supports/characterPair.ts",
        "src/vs/editor/common/modes/languageConfiguration.ts",
        "src/vs/workbench/contrib/codeEditor/browser/languageConfigurationExtensionPoint.ts",
        "extensions/typescript-language-features/src/languageFeatures/tagClosing.ts",
        "src/vs/editor/common/controller/cursorTypeOperations.ts",
        "extensions/html-language-features/client/src/tagClosing.ts",
        "src/vs/editor/common/modes/supports/richEditBrackets.ts",
        "src/vs/editor/contrib/bracketMatching/bracketMatching.ts",
        "src/vs/editor/common/modes/languageConfigurationRegistry.ts",
        "src/vs/editor/standalone/common/monarch/monarchCompile.ts",
        "src/vs/editor/common/modes/supports/electricCharacter.ts",
        "extensions/emmet/src/balance.ts",
        "src/vs/editor/common/modes/tokenization/typescript.ts",
        "src/vs/editor/common/modes/supports/onEnter.ts",
        "extensions/vscode-api-tests/src/singlefolder-tests/languages.test.ts",
        "src/vs/editor/standalone/common/monarch/monarchLexer.ts",
        "src/vs/editor/contrib/smartSelect/bracketSelections.ts",
        "src/vs/workbench/contrib/tasks/common/problemMatcher.ts",
        "src/vs/editor/contrib/snippet/snippetParser.ts",
        "src/vs/editor/common/modes/supports.ts",
        "src/vs/editor/contrib/find/replacePattern.ts",
        "extensions/php/build/update-grammar.js",
        "extensions/merge-conflict/src/mergeConflictParser.ts",
        "extensions/emmet/src/matchTag.ts",
        "extensions/html-language-features/client/src/htmlClient.ts",
        "src/vs/editor/common/model/textModel.ts",
        "extensions/typescript-language-features/src/languageFeatures/languageConfiguration.ts",
        "src/vs/base/common/marked/marked.js",
        "extensions/emmet/src/splitJoinTag.ts",
        "src/vs/workbench/contrib/welcome/walkThrough/browser/editor/vs_code_editor_walkthrough.ts",
        "extensions/typescript-language-features/src/languageFeatures/completions.ts",
        "extensions/vscode-api-tests/src/singlefolder-tests/editor.test.ts",
        "src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts",
        "extensions/markdown-language-features/src/features/smartSelect.ts",
        "src/vs/workbench/contrib/preferences/common/smartSnippetInserter.ts",
        "src/vs/workbench/services/themes/common/textMateScopeMatcher.ts",
        "extensions/json/build/update-grammars.js",
        "extensions/emmet/src/abbreviationActions.ts",
        "src/vs/editor/common/config/editorOptions.ts",
        "src/vs/vscode.d.ts",
        "src/vs/workbench/api/common/extHostLanguageFeatures.ts",
        "extensions/typescript-basics/build/update-grammars.js",
        "src/vs/editor/standalone/common/monarch/monarchCommon.ts",
        "src/vs/workbench/services/themes/common/plistParser.ts",
        "extensions/vscode-api-tests/src/singlefolder-tests/workspace.test.ts",
        "src/vs/editor/common/controller/cursorDeleteOperations.ts",
        "src/vs/monaco.d.ts",
        "extensions/emmet/src/util.ts",
        "extensions/configuration-editing/src/settingsDocumentHelper.ts",
        "extensions/typescript-language-features/src/languageFeatures/quickFix.ts"
    ],
    "3_final_combined_files": [
        "src/vs/editor/common/modes/supports/characterPair.ts",
        "src/vs/editor/common/modes/languageConfiguration.ts",
        "src/vs/editor/common/controller/cursorTypeOperations.ts",
        "src/vs/workbench/contrib/codeEditor/browser/languageConfigurationExtensionPoint.ts"
    ],
    "4_related_elements": {
        "src/vs/editor/common/modes/supports/characterPair.ts": [
            "class: AutoClosingPairs\nfunction: AutoClosingPairs.constructor\nclass: CharacterPairSupport\nfunction: CharacterPairSupport.shouldAutoClosePair\nvariable: CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED"
        ],
        "src/vs/editor/common/modes/languageConfiguration.ts": [
            "class: StandardAutoClosingPairConditional"
        ],
        "src/vs/editor/common/controller/cursorTypeOperations.ts": [
            "function: TypeOperations._findAutoClosingPairOpen\nfunction: TypeOperations._isAutoClosingOpenCharType\nfunction: TypeOperations._isBeforeClosingBrace\nfunction: TypeOperations._autoClosingPairIsSymmetric\nfunction: TypeOperations._runAutoClosingOpenCharType\nfunction: TypeOperations.typeWithInterceptors\nfunction: TypeOperations.compositionEndWithInterceptors\nfunction: TypeOperations._isAutoClosingOvertype\nfunction: TypeOperations._runAutoClosingOvertype\nclass: TypeWithAutoClosingCommand"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "src/vs/editor/common/controller/cursorTypeOperations.ts": [
                    "function: TypeOperations._isBeforeClosingBrace\nfunction: TypeOperations._isAutoClosingOpenCharType"
                ],
                "src/vs/editor/common/modes/supports/characterPair.ts": [
                    ""
                ],
                "src/vs/editor/common/modes/languageConfiguration.ts": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/vs/editor/common/controller/cursorTypeOperations.ts b/src/vs/editor/common/controller/cursorTypeOperations.ts\nindex 800f4ee..1850919 100644\n--- a/src/vs/editor/common/controller/cursorTypeOperations.ts\n+++ b/src/vs/editor/common/controller/cursorTypeOperations.ts\n@@ -503,14 +503,35 @@ export class TypeOperations {\n \t\treturn (open.indexOf(close) >= 0 || close.indexOf(open) >= 0);\n \t}\n \n+\tprivate static _autoClosingPairOpensOverlap(a: StandardAutoClosingPairConditional, b: StandardAutoClosingPairConditional): boolean {\n+\t\tconst aOpen = a.open;\n+\t\tconst bOpen = b.open;\n+\t\treturn aOpen.startsWith(bOpen) || bOpen.startsWith(aOpen);\n+\t}\n+\n \tprivate static _isBeforeClosingBrace(config: CursorConfiguration, autoClosingPair: StandardAutoClosingPairConditional, characterAfter: string) {\n+\t\t// Allow auto-closing only if:\n+\t\t// - The next character can start the closing sequence of THIS pair, or\n+\t\t// - There is another non-conflicting auto-closing pair following.\n+\t\t// This avoids conflicts where pairs have overlapping open sequences, e.g., '(' and '(*'.\n \t\tconst otherAutoClosingPairs = config.autoClosingPairsClose2.get(characterAfter);\n+\n+\t\t// If the next character starts the closing sequence for this pair, allow it.\n+\t\tif (autoClosingPair.close.length > 0 && autoClosingPair.close.charAt(0) === characterAfter) {\n+\t\t\treturn true;\n+\t\t}\n+\n \t\tif (!otherAutoClosingPairs) {\n \t\t\treturn false;\n \t\t}\n \n \t\tconst thisBraceIsSymmetric = TypeOperations._autoClosingPairIsSymmetric(autoClosingPair);\n \t\tfor (const otherAutoClosingPair of otherAutoClosingPairs) {\n+\t\t\t// If the other pair's open overlaps with this pair's open (e.g., '(' and '(*'),\n+\t\t\t// do not consider this \"before closing brace\" to avoid conflicting auto-closes.\n+\t\t\tif (TypeOperations._autoClosingPairOpensOverlap(autoClosingPair, otherAutoClosingPair)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tconst otherBraceIsSymmetric = TypeOperations._autoClosingPairIsSymmetric(otherAutoClosingPair);\n \t\t\tif (!thisBraceIsSymmetric && otherBraceIsSymmetric) {\n \t\t\t\tcontinue;\n",
                "diff --git a/src/vs/editor/common/controller/cursorTypeOperations.ts b/src/vs/editor/common/controller/cursorTypeOperations.ts\nindex 800f4ee..792453d 100644\n--- a/src/vs/editor/common/controller/cursorTypeOperations.ts\n+++ b/src/vs/editor/common/controller/cursorTypeOperations.ts\n@@ -619,7 +619,27 @@ export class TypeOperations {\n \t\tlet commands: ICommand[] = [];\n \t\tfor (let i = 0, len = selections.length; i < len; i++) {\n \t\t\tconst selection = selections[i];\n-\t\t\tcommands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPair.close);\n+\n+\t\t\t// Adjust the close string to avoid duplicating characters that already exist to the right of the cursor.\n+\t\t\t// This handles cases where multiple auto-closing pairs overlap, e.g. \"(*\" with \"*)\" and \"(\" with \")\".\n+\t\t\tlet closeCharacter = autoClosingPair.close;\n+\n+\t\t\tif (selection.isEmpty()) {\n+\t\t\t\tconst position = selection.getPosition();\n+\t\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n+\n+\t\t\t\tif (position.column <= lineText.length) {\n+\t\t\t\t\tconst characterAfter = lineText.charAt(position.column - 1);\n+\n+\t\t\t\t\t// If the computed close string ends with the character already present to the right,\n+\t\t\t\t\t// drop that character from the inserted close to prevent duplicates such as \"(**))\".\n+\t\t\t\t\tif (closeCharacter.length > 1 && closeCharacter.charAt(closeCharacter.length - 1) === characterAfter) {\n+\t\t\t\t\t\tcloseCharacter = closeCharacter.substring(0, closeCharacter.length - 1);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tcommands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, closeCharacter);\n \t\t}\n \t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n \t\t\tshouldPushStackElementBefore: true,\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "src/vs/editor/common/controller/cursorTypeOperations.ts": [
                    "function: TypeOperations._isBeforeClosingBrace\nfunction: TypeOperations._isAutoClosingOpenCharType\nfunction: TypeOperations._runAutoClosingOpenCharType\nfunction: TypeWithAutoClosingCommand.computeCursorState"
                ],
                "src/vs/editor/common/modes/supports/characterPair.ts": [
                    ""
                ],
                "src/vs/editor/common/modes/languageConfiguration.ts": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/vs/editor/common/controller/cursorTypeOperations.ts b/src/vs/editor/common/controller/cursorTypeOperations.ts\nindex 800f4ee..b1bac00 100644\n--- a/src/vs/editor/common/controller/cursorTypeOperations.ts\n+++ b/src/vs/editor/common/controller/cursorTypeOperations.ts\n@@ -504,6 +504,15 @@ export class TypeOperations {\n \t}\n \n \tprivate static _isBeforeClosingBrace(config: CursorConfiguration, autoClosingPair: StandardAutoClosingPairConditional, characterAfter: string) {\n+\t\t// Only consider this a \"before closing brace\" situation if the next character\n+\t\t// matches the first character of the closing sequence we intend to insert.\n+\t\t// This avoids conflicts between overlapping auto-closing pairs such as\n+\t\t// '(' -> ')' and '(*' -> '*)', where typing '*' before an auto-inserted ')'\n+\t\t// would otherwise lead to duplicating closings like '(**))'.\n+\t\tif (autoClosingPair.close.length === 0 || autoClosingPair.close.charAt(0) !== characterAfter) {\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tconst otherAutoClosingPairs = config.autoClosingPairsClose2.get(characterAfter);\n \t\tif (!otherAutoClosingPairs) {\n \t\t\treturn false;\n",
                "diff --git a/src/vs/editor/common/controller/cursorTypeOperations.ts b/src/vs/editor/common/controller/cursorTypeOperations.ts\nindex 800f4ee..3a9bfd8 100644\n--- a/src/vs/editor/common/controller/cursorTypeOperations.ts\n+++ b/src/vs/editor/common/controller/cursorTypeOperations.ts\n@@ -499,8 +499,9 @@ export class TypeOperations {\n \t}\n \n \tprivate static _autoClosingPairIsSymmetric(autoClosingPair: StandardAutoClosingPairConditional): boolean {\n-\t\tconst { open, close } = autoClosingPair;\n-\t\treturn (open.indexOf(close) >= 0 || close.indexOf(open) >= 0);\n+\t\t// A symmetric auto-closing pair is one where the open and close are identical (e.g., quotes).\n+\t\t// Using strict equality avoids false positives for pairs that merely share characters.\n+\t\treturn autoClosingPair.open === autoClosingPair.close;\n \t}\n \n \tprivate static _isBeforeClosingBrace(config: CursorConfiguration, autoClosingPair: StandardAutoClosingPairConditional, characterAfter: string) {\n@@ -619,7 +620,22 @@ export class TypeOperations {\n \t\tlet commands: ICommand[] = [];\n \t\tfor (let i = 0, len = selections.length; i < len; i++) {\n \t\t\tconst selection = selections[i];\n-\t\t\tcommands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPair.close);\n+\n+\t\t\t// Avoid inserting duplicate closing characters when the next character already matches\n+\t\t\t// the end of the auto-closing pair's close string. This handles overlapping pairs like\n+\t\t\t// \"(*\" -> \"*)\" when a \")\" is already present (e.g., from \"(\" -> \")\").\n+\t\t\tlet closeToInsert = autoClosingPair.close;\n+\t\t\tconst position = selection.getPosition();\n+\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n+\n+\t\t\tif (lineText.length > position.column - 1 && closeToInsert.length > 0) {\n+\t\t\t\tconst characterAfter = lineText.charAt(position.column - 1);\n+\t\t\t\tif (closeToInsert.charAt(closeToInsert.length - 1) === characterAfter) {\n+\t\t\t\t\tcloseToInsert = closeToInsert.substring(0, closeToInsert.length - 1);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tcommands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, closeToInsert);\n \t\t}\n \t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n \t\t\tshouldPushStackElementBefore: true,\n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/src/vs/editor/common/controller/cursorTypeOperations.ts b/src/vs/editor/common/controller/cursorTypeOperations.ts\nindex 800f4ee..1850919 100644\n--- a/src/vs/editor/common/controller/cursorTypeOperations.ts\n+++ b/src/vs/editor/common/controller/cursorTypeOperations.ts\n@@ -503,14 +503,35 @@ export class TypeOperations {\n \t\treturn (open.indexOf(close) >= 0 || close.indexOf(open) >= 0);\n \t}\n \n+\tprivate static _autoClosingPairOpensOverlap(a: StandardAutoClosingPairConditional, b: StandardAutoClosingPairConditional): boolean {\n+\t\tconst aOpen = a.open;\n+\t\tconst bOpen = b.open;\n+\t\treturn aOpen.startsWith(bOpen) || bOpen.startsWith(aOpen);\n+\t}\n+\n \tprivate static _isBeforeClosingBrace(config: CursorConfiguration, autoClosingPair: StandardAutoClosingPairConditional, characterAfter: string) {\n+\t\t// Allow auto-closing only if:\n+\t\t// - The next character can start the closing sequence of THIS pair, or\n+\t\t// - There is another non-conflicting auto-closing pair following.\n+\t\t// This avoids conflicts where pairs have overlapping open sequences, e.g., '(' and '(*'.\n \t\tconst otherAutoClosingPairs = config.autoClosingPairsClose2.get(characterAfter);\n+\n+\t\t// If the next character starts the closing sequence for this pair, allow it.\n+\t\tif (autoClosingPair.close.length > 0 && autoClosingPair.close.charAt(0) === characterAfter) {\n+\t\t\treturn true;\n+\t\t}\n+\n \t\tif (!otherAutoClosingPairs) {\n \t\t\treturn false;\n \t\t}\n \n \t\tconst thisBraceIsSymmetric = TypeOperations._autoClosingPairIsSymmetric(autoClosingPair);\n \t\tfor (const otherAutoClosingPair of otherAutoClosingPairs) {\n+\t\t\t// If the other pair's open overlaps with this pair's open (e.g., '(' and '(*'),\n+\t\t\t// do not consider this \"before closing brace\" to avoid conflicting auto-closes.\n+\t\t\tif (TypeOperations._autoClosingPairOpensOverlap(autoClosingPair, otherAutoClosingPair)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tconst otherBraceIsSymmetric = TypeOperations._autoClosingPairIsSymmetric(otherAutoClosingPair);\n \t\t\tif (!thisBraceIsSymmetric && otherBraceIsSymmetric) {\n \t\t\t\tcontinue;\n"
}