{
    "instance_id": "SWE-PolyBench__python__evolution__feature__8bb50331",
    "original_id": "huggingface__transformers-13989",
    "1_model_selected_files": [
        "src/transformers/models/auto/auto_factory.py",
        "src/transformers/models/auto/configuration_auto.py",
        "src/transformers/models/auto/modeling_auto.py"
    ],
    "2_embedding_selected_files": [],
    "3_final_combined_files": [
        "src/transformers/models/auto/auto_factory.py",
        "src/transformers/models/auto/configuration_auto.py",
        "src/transformers/models/auto/modeling_auto.py"
    ],
    "4_related_elements": {
        "src/transformers/models/auto/configuration_auto.py": [
            "variable: CONFIG_MAPPING_NAMES\nvariable: CONFIG_ARCHIVE_MAP_MAPPING_NAMES\nvariable: MODEL_NAMES_MAPPING\nvariable: SPECIAL_MODEL_TYPE_TO_MODULE_NAME\nfunction: model_type_to_module_name\nfunction: config_class_to_model_type\nclass: _LazyConfigMapping\nvariable: CONFIG_MAPPING\nclass: AutoConfig"
        ],
        "src/transformers/models/auto/auto_factory.py": [
            "function: _get_model_class\nclass: _BaseAutoModelClass\nfunction: auto_class_update\nfunction: get_values\nfunction: getattribute_from_module\nclass: _LazyAutoMapping"
        ],
        "src/transformers/models/auto/modeling_auto.py": [
            "variable: MODEL_MAPPING_NAMES\nvariable: MODEL_FOR_PRETRAINING_MAPPING_NAMES\nvariable: MODEL_WITH_LM_HEAD_MAPPING_NAMES\nvariable: MODEL_FOR_CAUSAL_LM_MAPPING_NAMES\nvariable: MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES\nvariable: MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES\nvariable: MODEL_FOR_MASKED_LM_MAPPING_NAMES\nvariable: MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES\nvariable: MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES\nvariable: MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES\nvariable: MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES\nvariable: MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES\nvariable: MODEL_FOR_TABLE_QUESTION_ANSWERING_MAPPING_NAMES\nvariable: MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES\nvariable: MODEL_FOR_MULTIPLE_CHOICE_MAPPING_NAMES\nvariable: MODEL_FOR_NEXT_SENTENCE_PREDICTION_MAPPING_NAMES\nvariable: MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES\nvariable: MODEL_FOR_CTC_MAPPING_NAMES\nvariable: MODEL_MAPPING\nvariable: MODEL_FOR_PRETRAINING_MAPPING\nvariable: MODEL_WITH_LM_HEAD_MAPPING\nvariable: MODEL_FOR_CAUSAL_LM_MAPPING\nvariable: MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING\nvariable: MODEL_FOR_IMAGE_SEGMENTATION_MAPPING\nvariable: MODEL_FOR_MASKED_LM_MAPPING\nvariable: MODEL_FOR_OBJECT_DETECTION_MAPPING\nvariable: MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING\nvariable: MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING\nvariable: MODEL_FOR_QUESTION_ANSWERING_MAPPING\nvariable: MODEL_FOR_TABLE_QUESTION_ANSWERING_MAPPING\nvariable: MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING\nvariable: MODEL_FOR_MULTIPLE_CHOICE_MAPPING\nvariable: MODEL_FOR_NEXT_SENTENCE_PREDICTION_MAPPING\nvariable: MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING\nvariable: MODEL_FOR_CTC_MAPPING\nvariable: MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING\nclass: AutoModel\nclass: AutoModelForPreTraining\nclass: _AutoModelWithLMHead\nclass: AutoModelForCausalLM\nclass: AutoModelForMaskedLM\nclass: AutoModelForSeq2SeqLM\nclass: AutoModelForSequenceClassification\nclass: AutoModelForQuestionAnswering\nclass: AutoModelForTableQuestionAnswering\nclass: AutoModelForTokenClassification\nclass: AutoModelForMultipleChoice\nclass: AutoModelForNextSentencePrediction\nclass: AutoModelForImageClassification\nclass: AutoModelForImageSegmentation\nclass: AutoModelForObjectDetection\nclass: AutoModelForAudioClassification\nclass: AutoModelForCTC\nclass: AutoModelForSpeechSeq2Seq\nclass: AutoModelWithLMHead"
        ]
    },
    "5_sampled_edit_locs_and_patches": [
        {
            "sample_index": 0,
            "edit_locs": {
                "src/transformers/models/auto/configuration_auto.py": [
                    "class: _LazyConfigMapping"
                ],
                "src/transformers/models/auto/auto_factory.py": [
                    "class: _LazyAutoMapping"
                ],
                "src/transformers/models/auto/modeling_auto.py": [
                    "line: 22"
                ]
            },
            "patches": [
                "diff --git a/src/transformers/models/auto/auto_factory.py b/src/transformers/models/auto/auto_factory.py\nindex ebaf744..13ff9a9 100644\n--- a/src/transformers/models/auto/auto_factory.py\n+++ b/src/transformers/models/auto/auto_factory.py\n@@ -505,7 +505,8 @@ class _LazyAutoMapping(OrderedDict):\n \n     def __init__(self, config_mapping, model_mapping):\n         self._config_mapping = config_mapping\n-        self._reverse_config_mapping = {v: k for k, v in config_mapping.items()}\n+        # Build reverse mapping keyed by config class names to support custom configs and lazy loading.\n+        self._reverse_config_mapping = {v.__name__: k for k, v in config_mapping.items()}\n         self._model_mapping = model_mapping\n         self._modules = {}\n \n@@ -562,4 +563,4 @@ class _LazyAutoMapping(OrderedDict):\n         if not hasattr(item, \"__name__\") or item.__name__ not in self._reverse_config_mapping:\n             return False\n         model_type = self._reverse_config_mapping[item.__name__]\n-        return model_type in self._model_mapping\n+        return model_type in self._model_mapping\ndiff --git a/src/transformers/models/auto/configuration_auto.py b/src/transformers/models/auto/configuration_auto.py\nindex 1e29320..db34a06 100644\n--- a/src/transformers/models/auto/configuration_auto.py\n+++ b/src/transformers/models/auto/configuration_auto.py\n@@ -281,10 +281,23 @@ class _LazyConfigMapping(OrderedDict):\n         if key not in self._mapping:\n             raise KeyError(key)\n         value = self._mapping[key]\n-        module_name = model_type_to_module_name(key)\n-        if module_name not in self._modules:\n-            self._modules[module_name] = importlib.import_module(f\".{module_name}\", \"transformers.models\")\n-        return getattr(self._modules[module_name], value)\n+        # If the value is a string (class name), import from the transformers.models submodule.\n+        # If the value is already a class object (custom/user-provided), return it directly.\n+        if isinstance(value, str):\n+            module_name = model_type_to_module_name(key)\n+            if module_name not in self._modules:\n+                self._modules[module_name] = importlib.import_module(f\".{module_name}\", \"transformers.models\")\n+            return getattr(self._modules[module_name], value)\n+        else:\n+            return value\n+\n+    def __setitem__(self, key, value):\n+        # Allow users to register custom configs by setting either a class object or a class name string.\n+        self._mapping[key] = value\n+\n+    def update(self, other):\n+        # Allow bulk updates (e.g., dict of model_type -> config class)\n+        self._mapping.update(other)\n \n     def keys(self):\n         return self._mapping.keys()\n@@ -301,6 +314,9 @@ class _LazyConfigMapping(OrderedDict):\n     def __contains__(self, item):\n         return item in self._mapping\n \n+    def __len__(self):\n+        return len(self._mapping)\n+\n \n CONFIG_MAPPING = _LazyConfigMapping(CONFIG_MAPPING_NAMES)\n \n",
                "diff --git a/src/transformers/models/auto/auto_factory.py b/src/transformers/models/auto/auto_factory.py\nindex ebaf744..e27a920 100644\n--- a/src/transformers/models/auto/auto_factory.py\n+++ b/src/transformers/models/auto/auto_factory.py\n@@ -495,27 +495,69 @@ def getattribute_from_module(module, attr):\n \n class _LazyAutoMapping(OrderedDict):\n     \"\"\"\n-    \" A mapping config to object (model or tokenizer for instance) that will load keys and values when it is accessed.\n-\n+    A mapping from a config class to an object (model or tokenizer for instance) that will load keys and values\n+    when it is accessed, while allowing user extensions.\n     Args:\n-\n         - config_mapping: The map model type to config class\n-        - model_mapping: The map model type to model (or tokenizer) class\n+        - model_mapping: The map model type to model (or tokenizer) class name (string)\n     \"\"\"\n \n     def __init__(self, config_mapping, model_mapping):\n         self._config_mapping = config_mapping\n-        self._reverse_config_mapping = {v: k for k, v in config_mapping.items()}\n         self._model_mapping = model_mapping\n         self._modules = {}\n+        # Built lazily: map config class name -> model_type\n+        self._reverse_config_mapping = {}\n+        # Extra user-defined map: model_type -> actual class object\n+        self._extra_model_mapping = OrderedDict()\n+\n+    def _ensure_reverse_mapping(self):\n+        # Build mapping from config class name -> model_type using union of available model types\n+        reverse = {}\n+        model_types = set(self._model_mapping.keys()) | set(self._extra_model_mapping.keys())\n+        for model_type in model_types:\n+            try:\n+                cfg_cls = self._config_mapping[model_type]\n+            except KeyError:\n+                # Skip model types that don't have a registered config\n+                continue\n+            reverse[getattr(cfg_cls, \"__name__\", str(cfg_cls))] = model_type\n+        self._reverse_config_mapping = reverse\n \n     def __getitem__(self, key):\n-        model_type = self._reverse_config_mapping[key.__name__]\n+        # key should be a config class\n+        if not hasattr(key, \"__name__\"):\n+            raise KeyError(key)\n+        if key.__name__ not in self._reverse_config_mapping:\n+            self._ensure_reverse_mapping()\n+        model_type = self._reverse_config_mapping.get(key.__name__)\n+        if model_type is None:\n+            raise KeyError(key)\n+        if model_type in self._extra_model_mapping:\n+            return self._extra_model_mapping[model_type]\n         if model_type not in self._model_mapping:\n             raise KeyError(key)\n         model_name = self._model_mapping[model_type]\n         return self._load_attr_from_module(model_type, model_name)\n \n+    def __setitem__(self, key, value):\n+        # Allow registering custom models either by model_type string or config class.\n+        if isinstance(key, str):\n+            self._extra_model_mapping[key] = value\n+            return\n+        if not hasattr(key, \"__name__\"):\n+            raise KeyError(key)\n+        if key.__name__ not in self._reverse_config_mapping:\n+            self._ensure_reverse_mapping()\n+        model_type = self._reverse_config_mapping.get(key.__name__)\n+        if model_type is None:\n+            # Users should first register their config in CONFIG_MAPPING or use a model_type string key here.\n+            raise KeyError(\n+                f\"Config class {key} is not registered in CONFIG_MAPPING; please add it there first or \"\n+                f\"use a model_type string key when registering the model.\"\n+            )\n+        self._extra_model_mapping[model_type] = value\n+\n     def _load_attr_from_module(self, model_type, attr):\n         module_name = model_type_to_module_name(model_type)\n         if module_name not in self._modules:\n@@ -523,11 +565,14 @@ class _LazyAutoMapping(OrderedDict):\n         return getattribute_from_module(self._modules[module_name], attr)\n \n     def keys(self):\n-        return [\n-            self._load_attr_from_module(key, name)\n-            for key, name in self._config_mapping.items()\n-            if key in self._model_mapping.keys()\n-        ]\n+        model_types = set(self._model_mapping.keys()) | set(self._extra_model_mapping.keys())\n+        result = []\n+        for model_type in model_types:\n+            try:\n+                result.append(self._config_mapping[model_type])\n+            except KeyError:\n+                continue\n+        return result\n \n     def get(self, key, default):\n         try:\n@@ -539,27 +584,41 @@ class _LazyAutoMapping(OrderedDict):\n         return bool(self.keys())\n \n     def values(self):\n-        return [\n-            self._load_attr_from_module(key, name)\n-            for key, name in self._model_mapping.items()\n-            if key in self._config_mapping.keys()\n-        ]\n+        model_types = set(self._model_mapping.keys()) | set(self._extra_model_mapping.keys())\n+        values = []\n+        for model_type in model_types:\n+            if model_type in self._extra_model_mapping:\n+                values.append(self._extra_model_mapping[model_type])\n+            elif model_type in self._model_mapping:\n+                values.append(self._load_attr_from_module(model_type, self._model_mapping[model_type]))\n+        return values\n \n     def items(self):\n-        return [\n-            (\n-                self._load_attr_from_module(key, self._config_mapping[key]),\n-                self._load_attr_from_module(key, self._model_mapping[key]),\n-            )\n-            for key in self._model_mapping.keys()\n-            if key in self._config_mapping.keys()\n-        ]\n+        model_types = set(self._model_mapping.keys()) | set(self._extra_model_mapping.keys())\n+        items = []\n+        for model_type in model_types:\n+            try:\n+                cfg_cls = self._config_mapping[model_type]\n+            except KeyError:\n+                continue\n+            if model_type in self._extra_model_mapping:\n+                mdl_cls = self._extra_model_mapping[model_type]\n+            else:\n+                if model_type not in self._model_mapping:\n+                    continue\n+                mdl_cls = self._load_attr_from_module(model_type, self._model_mapping[model_type])\n+            items.append((cfg_cls, mdl_cls))\n+        return items\n \n     def __iter__(self):\n-        return iter(self._model_mapping.keys())\n+        return iter(set(self._model_mapping.keys()) | set(self._extra_model_mapping.keys()))\n \n     def __contains__(self, item):\n-        if not hasattr(item, \"__name__\") or item.__name__ not in self._reverse_config_mapping:\n+        if not hasattr(item, \"__name__\"):\n+            return False\n+        if item.__name__ not in self._reverse_config_mapping:\n+            self._ensure_reverse_mapping()\n+        model_type = self._reverse_config_mapping.get(item.__name__)\n+        if model_type is None:\n             return False\n-        model_type = self._reverse_config_mapping[item.__name__]\n-        return model_type in self._model_mapping\n+        return model_type in self._model_mapping or model_type in self._extra_model_mapping\ndiff --git a/src/transformers/models/auto/configuration_auto.py b/src/transformers/models/auto/configuration_auto.py\nindex 1e29320..8769a20 100644\n--- a/src/transformers/models/auto/configuration_auto.py\n+++ b/src/transformers/models/auto/configuration_auto.py\n@@ -270,14 +270,21 @@ def config_class_to_model_type(config):\n \n class _LazyConfigMapping(OrderedDict):\n     \"\"\"\n-    A dictionary that lazily load its values when they are requested.\n+    A dictionary that lazily loads its values when they are requested, while allowing user extensions.\n     \"\"\"\n \n     def __init__(self, mapping):\n+        # Base mapping: model_type -> attribute name (string) inside transformers.models.<module>\n         self._mapping = mapping\n+        # Extra user-defined entries: model_type -> actual class object\n+        self._extra_content = OrderedDict()\n         self._modules = {}\n \n     def __getitem__(self, key):\n+        # First, check user-defined content\n+        if key in self._extra_content:\n+            return self._extra_content[key]\n+        # Then, check built-in lazy mapping\n         if key not in self._mapping:\n             raise KeyError(key)\n         value = self._mapping[key]\n@@ -286,14 +293,22 @@ class _LazyConfigMapping(OrderedDict):\n             self._modules[module_name] = importlib.import_module(f\".{module_name}\", \"transformers.models\")\n         return getattr(self._modules[module_name], value)\n \n+    def __setitem__(self, key, value):\n+        # Allow users to register custom configs by direct assignment\n+        # key: model_type (string), value: config class object\n+        self._extra_content[key] = value\n+\n     def keys(self):\n-        return self._mapping.keys()\n+        # Include both built-in and user-defined keys\n+        return list(self._mapping.keys()) + list(self._extra_content.keys())\n \n     def values(self):\n-        return [self[k] for k in self._mapping.keys()]\n+        # Return classes for all keys, loading built-ins lazily\n+        return [self[k] for k in self.keys()]\n \n     def items(self):\n-        return [(k, self[k]) for k in self._mapping.keys()]\n+        # Return (model_type, config_class) pairs for all keys\n+        return [(k, self[k]) for k in self.keys()]\n \n     def __iter__(self):\n         return iter(self._mapping.keys())\n"
            ]
        },
        {
            "sample_index": 1,
            "edit_locs": {
                "src/transformers/models/auto/configuration_auto.py": [
                    "function: _LazyConfigMapping.__getitem__\nfunction: _LazyConfigMapping.__setitem__\nfunction: _LazyConfigMapping.update"
                ],
                "src/transformers/models/auto/auto_factory.py": [
                    "function: _LazyAutoMapping.__init__\nfunction: _LazyAutoMapping.__getitem__\nfunction: _LazyAutoMapping.__setitem__\nfunction: _LazyAutoMapping.keys\nfunction: _LazyAutoMapping.values\nfunction: _LazyAutoMapping.items\nfunction: _LazyAutoMapping.__iter__\nfunction: _LazyAutoMapping.get\nfunction: _LazyAutoMapping.__contains__"
                ],
                "src/transformers/models/auto/modeling_auto.py": [
                    ""
                ]
            },
            "patches": [
                "diff --git a/src/transformers/models/auto/auto_factory.py b/src/transformers/models/auto/auto_factory.py\nindex ebaf744..02c3e01 100644\n--- a/src/transformers/models/auto/auto_factory.py\n+++ b/src/transformers/models/auto/auto_factory.py\n@@ -499,19 +499,31 @@ class _LazyAutoMapping(OrderedDict):\n \n     Args:\n \n-        - config_mapping: The map model type to config class\n-        - model_mapping: The map model type to model (or tokenizer) class\n+        - config_mapping: The map model type to config class (names for built-ins)\n+        - model_mapping: The map model type to model (or tokenizer) class (names for built-ins)\n+\n+    This mapping now supports user-registered pairs of config class -> model class via standard dict assignment.\n     \"\"\"\n \n     def __init__(self, config_mapping, model_mapping):\n+        super().__init__()\n         self._config_mapping = config_mapping\n         self._reverse_config_mapping = {v: k for k, v in config_mapping.items()}\n         self._model_mapping = model_mapping\n         self._modules = {}\n+        # Store any user-provided (config class -> model class) pairs here.\n+        self._extra_content = OrderedDict()\n+\n+    def __setitem__(self, key, value):\n+        # Allow direct registration of custom config->model mapping.\n+        self._extra_content[key] = value\n \n     def __getitem__(self, key):\n-        model_type = self._reverse_config_mapping[key.__name__]\n-        if model_type not in self._model_mapping:\n+        # First return any user-provided entry.\n+        if key in self._extra_content:\n+            return self._extra_content[key]\n+        model_type = self._reverse_config_mapping.get(key.__name__)\n+        if model_type is None or model_type not in self._model_mapping:\n             raise KeyError(key)\n         model_name = self._model_mapping[model_type]\n         return self._load_attr_from_module(model_type, model_name)\n@@ -522,12 +534,26 @@ class _LazyAutoMapping(OrderedDict):\n             self._modules[module_name] = importlib.import_module(f\".{module_name}\", \"transformers.models\")\n         return getattribute_from_module(self._modules[module_name], attr)\n \n-    def keys(self):\n-        return [\n-            self._load_attr_from_module(key, name)\n-            for key, name in self._config_mapping.items()\n-            if key in self._model_mapping.keys()\n+    def items(self):\n+        # Built-in items (config class -> model class)\n+        builtin_items = [\n+            (\n+                self._load_attr_from_module(key, self._config_mapping[key]),\n+                self._load_attr_from_module(key, self._model_mapping[key]),\n+            )\n+            for key in self._model_mapping.keys()\n+            if key in self._config_mapping.keys()\n         ]\n+        extras_keys = set(self._extra_content.keys())\n+        # Filter out built-in items that are overridden by extras.\n+        builtin_items = [pair for pair in builtin_items if pair[0] not in extras_keys]\n+        return list(self._extra_content.items()) + builtin_items\n+\n+    def keys(self):\n+        return [k for k, _ in self.items()]\n+\n+    def values(self):\n+        return [v for _, v in self.items()]\n \n     def get(self, key, default):\n         try:\n@@ -538,28 +564,14 @@ class _LazyAutoMapping(OrderedDict):\n     def __bool__(self):\n         return bool(self.keys())\n \n-    def values(self):\n-        return [\n-            self._load_attr_from_module(key, name)\n-            for key, name in self._model_mapping.items()\n-            if key in self._config_mapping.keys()\n-        ]\n-\n-    def items(self):\n-        return [\n-            (\n-                self._load_attr_from_module(key, self._config_mapping[key]),\n-                self._load_attr_from_module(key, self._model_mapping[key]),\n-            )\n-            for key in self._model_mapping.keys()\n-            if key in self._config_mapping.keys()\n-        ]\n-\n     def __iter__(self):\n-        return iter(self._model_mapping.keys())\n+        # Iterate over config classes (user-registered first, then built-ins not overridden)\n+        return iter(self.keys())\n \n     def __contains__(self, item):\n+        if item in self._extra_content:\n+            return True\n         if not hasattr(item, \"__name__\") or item.__name__ not in self._reverse_config_mapping:\n             return False\n         model_type = self._reverse_config_mapping[item.__name__]\n-        return model_type in self._model_mapping\n+        return model_type in self._model_mapping\ndiff --git a/src/transformers/models/auto/configuration_auto.py b/src/transformers/models/auto/configuration_auto.py\nindex 1e29320..7cf3482 100644\n--- a/src/transformers/models/auto/configuration_auto.py\n+++ b/src/transformers/models/auto/configuration_auto.py\n@@ -270,14 +270,28 @@ def config_class_to_model_type(config):\n \n class _LazyConfigMapping(OrderedDict):\n     \"\"\"\n-    A dictionary that lazily load its values when they are requested.\n+    A dictionary that lazily load its values when they are requested, while allowing users to register\n+    custom mappings via standard dict assignment.\n+\n+    Built-in mappings are stored as model_type -> class name and lazily imported from transformers.models.\n+    User-registered mappings can directly store model_type -> class objects and are returned without import.\n     \"\"\"\n \n     def __init__(self, mapping):\n+        super().__init__()\n         self._mapping = mapping\n         self._modules = {}\n+        # Store any user-provided overrides/additions here (model_type -> class object)\n+        self._extra_content = OrderedDict()\n+\n+    def __setitem__(self, key, value):\n+        # Allow users to register custom config classes directly.\n+        self._extra_content[key] = value\n \n     def __getitem__(self, key):\n+        # First return any user-provided entry.\n+        if key in self._extra_content:\n+            return self._extra_content[key]\n         if key not in self._mapping:\n             raise KeyError(key)\n         value = self._mapping[key]\n@@ -287,19 +301,25 @@ class _LazyConfigMapping(OrderedDict):\n         return getattr(self._modules[module_name], value)\n \n     def keys(self):\n-        return self._mapping.keys()\n+        # extras take precedence over built-ins\n+        return list(self._extra_content.keys()) + [k for k in self._mapping.keys() if k not in self._extra_content]\n \n     def values(self):\n-        return [self[k] for k in self._mapping.keys()]\n+        return [self[k] for k in self.keys()]\n \n     def items(self):\n-        return [(k, self[k]) for k in self._mapping.keys()]\n+        return [(k, self[k]) for k in self.keys()]\n+\n+    def update(self, other):\n+        # Support bulk updates for user-registered mappings.\n+        for k, v in other.items():\n+            self.__setitem__(k, v)\n \n     def __iter__(self):\n-        return iter(self._mapping.keys())\n+        return iter(self.keys())\n \n     def __contains__(self, item):\n-        return item in self._mapping\n+        return item in self._extra_content or item in self._mapping\n \n \n CONFIG_MAPPING = _LazyConfigMapping(CONFIG_MAPPING_NAMES)\n",
                "diff --git a/src/transformers/models/auto/auto_factory.py b/src/transformers/models/auto/auto_factory.py\nindex ebaf744..9c5fe5c 100644\n--- a/src/transformers/models/auto/auto_factory.py\n+++ b/src/transformers/models/auto/auto_factory.py\n@@ -505,23 +505,41 @@ class _LazyAutoMapping(OrderedDict):\n \n     def __init__(self, config_mapping, model_mapping):\n         self._config_mapping = config_mapping\n-        self._reverse_config_mapping = {v: k for k, v in config_mapping.items()}\n+        # Build reverse mapping keyed by config class name.\n+        self._reverse_config_mapping = {v.__name__: k for k, v in config_mapping.items()}\n         self._model_mapping = model_mapping\n         self._modules = {}\n \n+    def _rebuild_reverse_mapping(self):\n+        # Recompute to reflect any dynamic registrations.\n+        self._reverse_config_mapping = {v.__name__: k for k, v in self._config_mapping.items()}\n+\n     def __getitem__(self, key):\n-        model_type = self._reverse_config_mapping[key.__name__]\n-        if model_type not in self._model_mapping:\n+        # key is a config class.\n+        model_type = self._reverse_config_mapping.get(key.__name__)\n+        if model_type is None:\n+            # Try to rebuild in case of dynamic additions.\n+            self._rebuild_reverse_mapping()\n+            model_type = self._reverse_config_mapping.get(key.__name__)\n+        if model_type is None or model_type not in self._model_mapping:\n             raise KeyError(key)\n-        model_name = self._model_mapping[model_type]\n-        return self._load_attr_from_module(model_type, model_name)\n+        model_name_or_class = self._model_mapping[model_type]\n+        return self._load_attr_from_module(model_type, model_name_or_class)\n \n     def _load_attr_from_module(self, model_type, attr):\n+        # Support direct class objects (custom models) without importing from transformers.models.\n+        if not isinstance(attr, str):\n+            return attr\n         module_name = model_type_to_module_name(model_type)\n         if module_name not in self._modules:\n             self._modules[module_name] = importlib.import_module(f\".{module_name}\", \"transformers.models\")\n         return getattribute_from_module(self._modules[module_name], attr)\n \n+    def __setitem__(self, key, value):\n+        # Allow users to register custom models dynamically by model_type.\n+        # key is the model_type (string), value can be a class or a string to be lazily imported.\n+        self._model_mapping[key] = value\n+\n     def keys(self):\n         return [\n             self._load_attr_from_module(key, name)\n@@ -559,7 +577,10 @@ class _LazyAutoMapping(OrderedDict):\n         return iter(self._model_mapping.keys())\n \n     def __contains__(self, item):\n-        if not hasattr(item, \"__name__\") or item.__name__ not in self._reverse_config_mapping:\n+        if not hasattr(item, \"__name__\"):\n             return False\n-        model_type = self._reverse_config_mapping[item.__name__]\n-        return model_type in self._model_mapping\n+        model_type = self._reverse_config_mapping.get(item.__name__)\n+        if model_type is None:\n+            self._rebuild_reverse_mapping()\n+            model_type = self._reverse_config_mapping.get(item.__name__)\n+        return model_type in self._model_mapping\ndiff --git a/src/transformers/models/auto/configuration_auto.py b/src/transformers/models/auto/configuration_auto.py\nindex 1e29320..c446b4a 100644\n--- a/src/transformers/models/auto/configuration_auto.py\n+++ b/src/transformers/models/auto/configuration_auto.py\n@@ -281,11 +281,19 @@ class _LazyConfigMapping(OrderedDict):\n         if key not in self._mapping:\n             raise KeyError(key)\n         value = self._mapping[key]\n+        # Support direct class objects (custom configs) without importing from transformers.models.\n+        if not isinstance(value, str):\n+            return value\n         module_name = model_type_to_module_name(key)\n         if module_name not in self._modules:\n             self._modules[module_name] = importlib.import_module(f\".{module_name}\", \"transformers.models\")\n         return getattr(self._modules[module_name], value)\n \n+    def __setitem__(self, key, value):\n+        # Allow users to register custom configs dynamically.\n+        self._mapping[key] = value\n+        # No eager import; loading remains lazy.\n+\n     def keys(self):\n         return self._mapping.keys()\n \n"
            ]
        }
    ],
    "6_final_selected_patch": "diff --git a/src/transformers/models/auto/auto_factory.py b/src/transformers/models/auto/auto_factory.py\nindex ebaf744..13ff9a9 100644\n--- a/src/transformers/models/auto/auto_factory.py\n+++ b/src/transformers/models/auto/auto_factory.py\n@@ -505,7 +505,8 @@ class _LazyAutoMapping(OrderedDict):\n \n     def __init__(self, config_mapping, model_mapping):\n         self._config_mapping = config_mapping\n-        self._reverse_config_mapping = {v: k for k, v in config_mapping.items()}\n+        # Build reverse mapping keyed by config class names to support custom configs and lazy loading.\n+        self._reverse_config_mapping = {v.__name__: k for k, v in config_mapping.items()}\n         self._model_mapping = model_mapping\n         self._modules = {}\n \n@@ -562,4 +563,4 @@ class _LazyAutoMapping(OrderedDict):\n         if not hasattr(item, \"__name__\") or item.__name__ not in self._reverse_config_mapping:\n             return False\n         model_type = self._reverse_config_mapping[item.__name__]\n-        return model_type in self._model_mapping\n+        return model_type in self._model_mapping\ndiff --git a/src/transformers/models/auto/configuration_auto.py b/src/transformers/models/auto/configuration_auto.py\nindex 1e29320..db34a06 100644\n--- a/src/transformers/models/auto/configuration_auto.py\n+++ b/src/transformers/models/auto/configuration_auto.py\n@@ -281,10 +281,23 @@ class _LazyConfigMapping(OrderedDict):\n         if key not in self._mapping:\n             raise KeyError(key)\n         value = self._mapping[key]\n-        module_name = model_type_to_module_name(key)\n-        if module_name not in self._modules:\n-            self._modules[module_name] = importlib.import_module(f\".{module_name}\", \"transformers.models\")\n-        return getattr(self._modules[module_name], value)\n+        # If the value is a string (class name), import from the transformers.models submodule.\n+        # If the value is already a class object (custom/user-provided), return it directly.\n+        if isinstance(value, str):\n+            module_name = model_type_to_module_name(key)\n+            if module_name not in self._modules:\n+                self._modules[module_name] = importlib.import_module(f\".{module_name}\", \"transformers.models\")\n+            return getattr(self._modules[module_name], value)\n+        else:\n+            return value\n+\n+    def __setitem__(self, key, value):\n+        # Allow users to register custom configs by setting either a class object or a class name string.\n+        self._mapping[key] = value\n+\n+    def update(self, other):\n+        # Allow bulk updates (e.g., dict of model_type -> config class)\n+        self._mapping.update(other)\n \n     def keys(self):\n         return self._mapping.keys()\n@@ -301,6 +314,9 @@ class _LazyConfigMapping(OrderedDict):\n     def __contains__(self, item):\n         return item in self._mapping\n \n+    def __len__(self):\n+        return len(self._mapping)\n+\n \n CONFIG_MAPPING = _LazyConfigMapping(CONFIG_MAPPING_NAMES)\n \n"
}