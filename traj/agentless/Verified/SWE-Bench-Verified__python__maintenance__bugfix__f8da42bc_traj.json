{
  "instance_id": "SWE-Bench-Verified__python__maintenance__bugfix__f8da42bc",
  "original_id": "django__django-13449",
  "1_model_selected_files": [
    "django/db/models/functions/window.py",
    "django/db/backends/sqlite3/operations.py",
    "django/db/models/expressions.py",
    "django/db/models/sql/compiler.py"
  ],
  "2_embedding_selected_files": [
    "django/db/backends/sqlite3/operations.py",
    "django/db/models/expressions.py",
    "django/db/backends/sqlite3/base.py",
    "django/db/models/functions/window.py",
    "django/db/backends/base/operations.py",
    "django/db/backends/base/features.py",
    "django/db/backends/sqlite3/features.py",
    "django/db/models/functions/mixins.py",
    "django/db/models/__init__.py",
    "django/db/backends/sqlite3/__init__.py",
    "django/db/models/sql/compiler.py",
    "django/db/models/aggregates.py",
    "django/db/models/sql/subqueries.py",
    "django/db/backends/utils.py",
    "django/db/models/functions/comparison.py",
    "django/db/backends/base/base.py",
    "django/db/backends/sqlite3/introspection.py",
    "django/db/models/fields/__init__.py",
    "django/db/models/functions/datetime.py",
    "django/db/models/lookups.py",
    "django/db/models/sql/__init__.py",
    "django/db/backends/sqlite3/client.py",
    "django/db/models/functions/math.py",
    "django/db/models/query_utils.py",
    "django/db/models/sql/query.py",
    "django/db/backends/sqlite3/schema.py",
    "django/db/models/query.py",
    "django/db/models/functions/text.py",
    "django/db/backends/base/schema.py",
    "django/db/models/base.py",
    "django/db/models/functions/__init__.py",
    "django/db/models/sql/datastructures.py",
    "django/db/models/sql/constants.py",
    "django/db/models/fields/related_lookups.py",
    "django/db/models/fields/related.py",
    "django/db/models/sql/where.py",
    "django/db/backends/sqlite3/creation.py",
    "django/db/models/fields/related_descriptors.py",
    "django/db/utils.py",
    "django/db/backends/base/__init__.py",
    "django/db/backends/__init__.py",
    "django/db/models/fields/json.py",
    "django/db/models/constraints.py",
    "django/db/backends/base/creation.py",
    "django/db/backends/base/validation.py",
    "django/db/transaction.py"
  ],
  "3_final_combined_files": [
    "django/db/backends/sqlite3/operations.py",
    "django/db/models/expressions.py",
    "django/db/models/functions/window.py",
    "django/db/backends/sqlite3/base.py"
  ],
  "4_related_elements": {
    "django/db/models/expressions.py": [
      "class: SQLiteNumericMixin\nclass: Func\nclass: Window\nfunction: BaseExpression.select_format"
    ],
    "django/db/models/functions/window.py": [
      "class: LagLeadFunction\nclass: Lag\nclass: Lead\nclass: FirstValue\nclass: LastValue\nclass: NthValue"
    ],
    "django/db/backends/sqlite3/operations.py": [
      ""
    ]
  },
  "5_sampled_edit_locs_and_patches": [
    {
      "sample_index": 0,
      "edit_locs": {
        "django/db/models/expressions.py": [
          "\nline: 1256\nclass: Window"
        ],
        "django/db/models/functions/window.py": [
          "\nfunction: LagLeadFunction.as_sqlite"
        ]
      },
      "patches": [
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..1e73e7e 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1302,7 +1302,17 @@ class Window(Expression):\n         connection.ops.check_expression_support(self)\n         if not connection.features.supports_over_clause:\n             raise NotSupportedError('This backend does not support window expressions.')\n-        expr_sql, params = compiler.compile(self.source_expression)\n+        # Compile the source expression without applying its output_field cast,\n+        # so we can cast the entire window expression afterward. This avoids\n+        # generating invalid SQL like CAST(LAG(...) AS ...) OVER (...).\n+        source_output_field = getattr(self.source_expression, 'output_field', None)\n+        try:\n+            self.source_expression.output_field = None\n+            expr_sql, params = compiler.compile(self.source_expression)\n+        finally:\n+            # Restore the original output_field on the source expression.\n+            self.source_expression.output_field = source_output_field\n+\n         window_sql, window_params = [], []\n \n         if self.partition_by is not None:\n@@ -1327,10 +1337,19 @@ class Window(Expression):\n         params.extend(window_params)\n         template = template or self.template\n \n-        return template % {\n+        window_expr_sql = template % {\n             'expression': expr_sql,\n             'window': ''.join(window_sql).strip()\n-        }, params\n+        }\n+\n+        # Cast the entire window expression if an output_field is defined.\n+        out_field = self.output_field or source_output_field\n+        if out_field:\n+            db_type = out_field.db_type(connection)\n+            if db_type:\n+                window_expr_sql = 'CAST(%s AS %s)' % (window_expr_sql, db_type)\n+\n+        return window_expr_sql, params\n \n     def __str__(self):\n         return '{} OVER ({}{}{})'.format(\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..d3b9c4c 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1325,11 +1325,21 @@ class Window(Expression):\n             window_params.extend(frame_params)\n \n         params.extend(window_params)\n+        window_clause = ''.join(window_sql).strip()\n         template = template or self.template\n \n+        # If the compiled source expression is wrapped in a CAST(), insert the\n+        # OVER (...) clause inside the CAST so that the window clause applies\n+        # to the window function rather than to CAST(), which is invalid SQL\n+        # on some backends (e.g., SQLite).\n+        if expr_sql.startswith('CAST(') and ' AS ' in expr_sql:\n+            idx = expr_sql.rfind(' AS ')\n+            expr_with_over = expr_sql[:idx] + ' OVER (' + window_clause + ')' + expr_sql[idx:]\n+            return expr_with_over, params\n+\n         return template % {\n             'expression': expr_sql,\n-            'window': ''.join(window_sql).strip()\n+            'window': window_clause\n         }, params\n \n     def __str__(self):\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..bdb54b4 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1286,11 +1286,15 @@ class Window(Expression):\n                     'order_by must be either an Expression or a sequence of '\n                     'expressions.'\n                 )\n-        super().__init__(output_field=output_field)\n+        # Ensure any type casting applies to the entire window expression,\n+        # not just the inner source expression. If no explicit output_field\n+        # is provided, inherit it from the source expression.\n+        resolved_output_field = output_field if output_field is not None else getattr(expression, 'output_field', None)\n+        super().__init__(output_field=resolved_output_field)\n         self.source_expression = self._parse_expressions(expression)[0]\n \n     def _resolve_output_field(self):\n-        return self.source_expression.output_field\n+        return self.output_field\n \n     def get_source_expressions(self):\n         return [self.source_expression, self.partition_by, self.order_by, self.frame]\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..a3463c4 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1325,12 +1325,28 @@ class Window(Expression):\n             window_params.extend(frame_params)\n \n         params.extend(window_params)\n-        template = template or self.template\n+        window_str = ''.join(window_sql).strip()\n+        tmpl = template or self.template\n+\n+        # If the compiled source expression is wrapped in a CAST(), ensure the\n+        # OVER clause applies to the inner window function rather than to CAST.\n+        # This generates: CAST(<func> OVER (<window>) AS <type>)\n+        # instead of the invalid: CAST(<func> AS <type>) OVER (<window>)\n+        expr_upper = expr_sql.upper()\n+        if expr_upper.startswith('CAST('):\n+            as_index = expr_upper.rfind(' AS ')\n+            # Basic validation to ensure we're dealing with a standard CAST().\n+            if as_index != -1 and expr_sql.endswith(')'):\n+                inner = expr_sql[5:as_index]  # between 'CAST(' and ' AS '\n+                type_and_paren = expr_sql[as_index + 4:]  # includes type and closing ')'\n+                final_sql = 'CAST(%s OVER (%s) AS %s' % (inner, window_str, type_and_paren)\n+            else:\n+                # Fallback to default behavior if CAST structure is unexpected.\n+                final_sql = tmpl % {'expression': expr_sql, 'window': window_str}\n+        else:\n+            final_sql = tmpl % {'expression': expr_sql, 'window': window_str}\n \n-        return template % {\n-            'expression': expr_sql,\n-            'window': ''.join(window_sql).strip()\n-        }, params\n+        return final_sql, params\n \n     def __str__(self):\n         return '{} OVER ({}{}{})'.format(\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..953838d 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1324,12 +1324,30 @@ class Window(Expression):\n             window_sql.append(' ' + frame_sql)\n             window_params.extend(frame_params)\n \n-        params.extend(window_params)\n+        window_str = ''.join(window_sql).strip()\n         template = template or self.template\n \n+        # If the compiled expression is wrapped in a CAST(), attach the OVER clause\n+        # to the inner window function and keep the CAST around the whole result.\n+        # This produces valid SQL on backends like SQLite which require OVER to\n+        # follow the window function directly.\n+        expr_sql_stripped = expr_sql.strip()\n+        upper_expr = expr_sql_stripped.upper()\n+        if upper_expr.startswith('CAST(') and upper_expr.endswith(')'):\n+            inner = expr_sql_stripped[5:-1]  # strip leading 'CAST(' and trailing ')'\n+            # Find the last ' AS ' which separates the expression and the type.\n+            idx = inner.upper().rfind(' AS ')\n+            if idx != -1:\n+                cast_expr = inner[:idx]\n+                cast_type = inner[idx + 4:]\n+                final_sql = 'CAST(%s OVER (%s) AS %s)' % (cast_expr, window_str, cast_type)\n+                params.extend(window_params)\n+                return final_sql, params\n+\n+        params.extend(window_params)\n         return template % {\n             'expression': expr_sql,\n-            'window': ''.join(window_sql).strip()\n+            'window': window_str\n         }, params\n \n     def __str__(self):\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..fff220d 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1324,13 +1324,33 @@ class Window(Expression):\n             window_sql.append(' ' + frame_sql)\n             window_params.extend(frame_params)\n \n+        # Combine params from the window components.\n         params.extend(window_params)\n         template = template or self.template\n-\n-        return template % {\n-            'expression': expr_sql,\n-            'window': ''.join(window_sql).strip()\n-        }, params\n+        window_clause = ''.join(window_sql).strip()\n+\n+        # If the compiled source expression is wrapped in CAST(... AS ...),\n+        # reposition the CAST to wrap the entire window expression:\n+        # CAST(<func> OVER (<window>) AS <type>)\n+        # This avoids invalid SQL like CAST(<func> AS <type>) OVER (...),\n+        # which SQLite (and others) reject.\n+        expr_stripped = expr_sql.strip()\n+        upper = expr_stripped.upper()\n+        final_sql = None\n+        if upper.startswith('CAST(') and expr_stripped.endswith(')'):\n+            # Find the ' AS ' separating inner expression and cast type.\n+            as_index = upper.rfind(' AS ')\n+            if as_index != -1:\n+                inner = expr_stripped[5:as_index]  # between 'CAST(' and ' AS '\n+                cast_type = expr_stripped[as_index + 4:-1].strip()  # after ' AS ' to closing ')'\n+                final_sql = 'CAST(%s OVER (%s) AS %s)' % (inner, window_clause, cast_type)\n+\n+        if final_sql is None:\n+            final_sql = template % {\n+                'expression': expr_sql,\n+                'window': window_clause\n+            }\n+        return final_sql, params\n \n     def __str__(self):\n         return '{} OVER ({}{}{})'.format(\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..bdc80b5 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1325,12 +1325,26 @@ class Window(Expression):\n             window_params.extend(frame_params)\n \n         params.extend(window_params)\n+        window_clause = ''.join(window_sql).strip()\n         template = template or self.template\n \n-        return template % {\n-            'expression': expr_sql,\n-            'window': ''.join(window_sql).strip()\n-        }, params\n+        # Build SQL for window expression, ensuring OVER is inside any CAST wrapper.\n+        # Some backends (e.g., SQLite) require the OVER clause to be part of the\n+        # window function call, not outside a CAST.\n+        upper_expr = expr_sql.upper()\n+        if upper_expr.startswith('CAST(') and ' AS ' in upper_expr and upper_expr.endswith(')'):\n+            # Parse CAST(inner_expression AS data_type) and inject OVER into inner_expression.\n+            as_index = upper_expr.rfind(' AS ')\n+            inner_expression = expr_sql[len('CAST('):as_index].strip()\n+            data_type = expr_sql[as_index + 4:-1].strip()\n+            over_sql = 'CAST(%s OVER (%s) AS %s)' % (inner_expression, window_clause, data_type)\n+        else:\n+            over_sql = template % {\n+                'expression': expr_sql,\n+                'window': window_clause\n+            }\n+\n+        return over_sql, params\n \n     def __str__(self):\n         return '{} OVER ({}{}{})'.format(\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..9482748 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1302,7 +1302,12 @@ class Window(Expression):\n         connection.ops.check_expression_support(self)\n         if not connection.features.supports_over_clause:\n             raise NotSupportedError('This backend does not support window expressions.')\n-        expr_sql, params = compiler.compile(self.source_expression)\n+        # Compile the source expression directly to avoid backend-specific casts\n+        # being applied to only the function call. Any necessary cast should\n+        # wrap the entire window expression, e.g.:\n+        # CAST(LAG(...) OVER (...) AS NUMERIC)\n+        expr_sql, expr_params = self.source_expression.as_sql(compiler, connection)\n+        params = list(expr_params)\n         window_sql, window_params = [], []\n \n         if self.partition_by is not None:\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..10297ce 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1326,10 +1326,50 @@ class Window(Expression):\n \n         params.extend(window_params)\n         template = template or self.template\n+        window_str = ''.join(window_sql).strip()\n+\n+        # On backends like SQLite, casting the inner function before the OVER\n+        # clause (e.g. CAST(LAG(...) AS NUMERIC) OVER (...)) is invalid. If the\n+        # compiled source expression is wrapped in CAST(...), move the CAST to\n+        # wrap the entire window expression instead (i.e. CAST(LAG(...) OVER (...) AS ...)).\n+        if connection.vendor == 'sqlite':\n+            upper_sql = expr_sql.upper()\n+            if upper_sql.startswith('CAST('):\n+                # Parse CAST(inner_expr AS type)\n+                start = expr_sql.find('(') + 1\n+                depth = 1\n+                end = None\n+                for idx in range(start, len(expr_sql)):\n+                    ch = expr_sql[idx]\n+                    if ch == '(':\n+                        depth += 1\n+                    elif ch == ')':\n+                        depth -= 1\n+                        if depth == 0:\n+                            end = idx\n+                            break\n+                if end is not None:\n+                    suffix = expr_sql[end + 1:].strip()\n+                    suffix_upper = suffix.upper()\n+                    if suffix_upper.startswith('AS'):\n+                        # Handle optional space after AS\n+                        if suffix_upper.startswith('AS '):\n+                            type_part = suffix[3:]\n+                        else:\n+                            type_part = suffix[2:]\n+                        type_part = type_part.strip()\n+                        # Strip trailing ')' if present\n+                        if type_part.endswith(')'):\n+                            cast_type = type_part[:-1].strip()\n+                        else:\n+                            cast_type = type_part\n+                        inner_expr = expr_sql[start:end]\n+                        sql = 'CAST(%s OVER (%s) AS %s)' % (inner_expr, window_str, cast_type)\n+                        return sql, params\n \n         return template % {\n             'expression': expr_sql,\n-            'window': ''.join(window_sql).strip()\n+            'window': window_str\n         }, params\n \n     def __str__(self):\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..90b82c8 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1326,11 +1326,32 @@ class Window(Expression):\n \n         params.extend(window_params)\n         template = template or self.template\n+        window_str = ''.join(window_sql).strip()\n+\n+        # Ensure any CAST wraps the entire window expression, not only\n+        # the inner function call. Some backends (e.g. SQLite) may cast\n+        # the source expression which produces invalid SQL like:\n+        # CAST(LAG(...) AS NUMERIC) OVER (...). The correct form is:\n+        # CAST(LAG(...) OVER (...) AS NUMERIC).\n+        upper_expr = expr_sql.upper()\n+        if upper_expr.startswith('CAST(') and ' AS ' in upper_expr and upper_expr.endswith(')'):\n+            # Parse CAST(inner_expr AS type) and rebuild as\n+            # CAST(inner_expr OVER (...) AS type).\n+            as_index = upper_expr.rfind(' AS ')\n+            inner = expr_sql[5:as_index]\n+            type_str = expr_sql[as_index + 4:-1].strip()\n+            window_expr = template % {\n+                'expression': inner,\n+                'window': window_str\n+            }\n+            final_sql = 'CAST(%s AS %s)' % (window_expr, type_str)\n+        else:\n+            final_sql = template % {\n+                'expression': expr_sql,\n+                'window': window_str\n+            }\n \n-        return template % {\n-            'expression': expr_sql,\n-            'window': ''.join(window_sql).strip()\n-        }, params\n+        return final_sql, params\n \n     def __str__(self):\n         return '{} OVER ({}{}{})'.format(\n"
      ]
    },
    {
      "sample_index": 1,
      "edit_locs": {
        "django/db/models/functions/window.py": [
          "\nfunction: LagLeadFunction.as_sqlite\nfunction: FirstValue.as_sqlite\nfunction: LastValue.as_sqlite\nfunction: NthValue.as_sqlite"
        ],
        "django/db/models/expressions.py": [
          "\nfunction: Window.as_sqlite"
        ]
      },
      "patches": [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    {
      "sample_index": 2,
      "edit_locs": {
        "django/db/models/expressions.py": [
          "\nfunction: Window.as_sqlite"
        ]
      },
      "patches": [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    {
      "sample_index": 3,
      "edit_locs": {
        "django/db/models/expressions.py": [
          "\nfunction: SQLiteNumericMixin.as_sqlite\nfunction: Window.as_sqlite"
        ]
      },
      "patches": [
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..ec1e761 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -19,12 +19,24 @@ class SQLiteNumericMixin:\n     \"\"\"\n     Some expressions with output_field=DecimalField() must be cast to\n     numeric to be properly filtered.\n+\n+    Be careful with window functions on SQLite: attaching OVER (...) to CAST(...)\n+    is invalid SQL (e.g. CAST(LAG(...) AS NUMERIC) OVER (...)). In such cases,\n+    avoid casting here so that the window expression can be rendered correctly.\n     \"\"\"\n     def as_sqlite(self, compiler, connection, **extra_context):\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n-                sql = 'CAST(%s AS NUMERIC)' % sql\n+                upper_sql = sql.upper().lstrip()\n+                # Detect common window functions to avoid generating invalid\n+                # \"CAST(func(...) AS NUMERIC) OVER (...)\" syntax on SQLite.\n+                window_funcs = ('LAG(', 'LEAD(', 'FIRST_VALUE(', 'LAST_VALUE(', 'NTH_VALUE(')\n+                if upper_sql.startswith(window_funcs) or ' OVER ' in upper_sql:\n+                    # Skip casting here; window clause must apply to the function call itself.\n+                    pass\n+                else:\n+                    sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n         return sql, params\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..e4a145d 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -19,11 +19,19 @@ class SQLiteNumericMixin:\n     \"\"\"\n     Some expressions with output_field=DecimalField() must be cast to\n     numeric to be properly filtered.\n+\n+    Avoid casting inner parts of window functions (e.g. LAG(...)) because\n+    SQLite doesn't allow CAST(...) OVER (...). In such cases, rely on the\n+    window expression itself without casting here.\n     \"\"\"\n     def as_sqlite(self, compiler, connection, **extra_context):\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n+                # Don't cast inner expressions of window functions to avoid\n+                # generating invalid SQL like: CAST(LAG(...) AS NUMERIC) OVER (...).\n+                if getattr(self, 'contains_over_clause', False):\n+                    return sql, params\n                 sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..d38dfe6 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -24,6 +24,13 @@ class SQLiteNumericMixin:\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n+                # Avoid casting here when the expression is used inside a window function.\n+                # In SQLite, the OVER clause must immediately follow the window function call.\n+                # Casting only the function before OVER causes a syntax error:\n+                # CAST(LAG(...) AS NUMERIC) OVER (...) -> invalid\n+                # Window should produce: CAST((LAG(...) OVER (...)) AS NUMERIC) if casting is needed.\n+                if extra_context.get('window'):\n+                    return sql, params\n                 sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..7ccdfc8 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -19,11 +19,22 @@ class SQLiteNumericMixin:\n     \"\"\"\n     Some expressions with output_field=DecimalField() must be cast to\n     numeric to be properly filtered.\n+\n+    Avoid casting window function calls (e.g., Lag/Lead, etc.) because\n+    wrapping the function call itself causes invalid SQL on SQLite:\n+    CAST(LAG(...) AS NUMERIC) OVER (...) is invalid. Instead, window\n+    functions should remain uncast here so the OVER clause can be applied\n+    correctly.\n     \"\"\"\n     def as_sqlite(self, compiler, connection, **extra_context):\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n+                # Skip casting for window functions to prevent invalid\n+                # \"CAST(... ) OVER (...)\" SQL on SQLite.\n+                module = getattr(self.__class__, '__module__', '')\n+                if module.endswith('.window') or 'django.db.models.functions.window' in module:\n+                    return sql, params\n                 sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..e0c3430 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -24,7 +24,12 @@ class SQLiteNumericMixin:\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n-                sql = 'CAST(%s AS NUMERIC)' % sql\n+                func_name = getattr(self, 'function', None)\n+                # Avoid casting window functions (e.g., LAG/LEAD) before the OVER clause\n+                # as that produces invalid SQL on SQLite. The cast should apply to the\n+                # entire window expression, not just the inner function.\n+                if not (func_name and func_name.upper() in {'LAG', 'LEAD', 'FIRST_VALUE', 'LAST_VALUE', 'NTH_VALUE'}):\n+                    sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n         return sql, params\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..c559f1f 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -24,7 +24,14 @@ class SQLiteNumericMixin:\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n-                sql = 'CAST(%s AS NUMERIC)' % sql\n+                # Avoid wrapping window functions (e.g. LAG/LEAD) in CAST() before\n+                # the OVER clause. SQLite requires CAST() to wrap the entire\n+                # window expression, not just the function call. Since the OVER\n+                # clause is appended by the Window expression, skip casting here\n+                # for window functions to prevent \"near OVER: syntax error\".\n+                sql_upper = sql.lstrip().upper()\n+                if not (sql_upper.startswith('LAG(') or sql_upper.startswith('LEAD(')):\n+                    sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n         return sql, params\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..5f47b1e 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -24,6 +24,13 @@ class SQLiteNumericMixin:\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n+                # Avoid casting window function arguments (e.g. LAG/LEAD) because\n+                # in SQLite a window function must be immediately followed by OVER.\n+                # Casting the inner function produces invalid SQL like:\n+                # CAST(LAG(... ) AS NUMERIC) OVER (...), which SQLite rejects.\n+                upper_sql = sql.lstrip().upper()\n+                if upper_sql.startswith('LAG(') or upper_sql.startswith('LEAD(') or upper_sql.startswith('FIRST_VALUE(') or upper_sql.startswith('LAST_VALUE(') or upper_sql.startswith('NTH_VALUE('):\n+                    return sql, params\n                 sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..86c8379 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -19,11 +19,24 @@ class SQLiteNumericMixin:\n     \"\"\"\n     Some expressions with output_field=DecimalField() must be cast to\n     numeric to be properly filtered.\n+\n+    On SQLite, window functions like LAG/LEAD must have their OVER clause\n+    applied directly to the function call. Wrapping the function call in\n+    CAST() before OVER causes a syntax error. In such cases, skip casting\n+    here and allow the window expression to be compiled without CAST.\n     \"\"\"\n     def as_sqlite(self, compiler, connection, **extra_context):\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n+                # Skip casting for window functions to avoid generating\n+                # invalid \"CAST(function(...) AS NUMERIC) OVER (...)\" SQL.\n+                func_name = getattr(self, 'function', None)\n+                if isinstance(func_name, str) and func_name.upper() in {'LAG', 'LEAD', 'FIRST_VALUE', 'LAST_VALUE', 'NTH_VALUE'}:\n+                    return sql, params\n+                # Allow callers to explicitly skip casting via context.\n+                if extra_context.get('skip_sqlite_cast'):\n+                    return sql, params\n                 sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..02f6e73 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -24,6 +24,15 @@ class SQLiteNumericMixin:\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n+                # Avoid casting inner function calls of window functions (e.g. LAG)\n+                # as it results in invalid SQL like: CAST(LAG(...) AS NUMERIC) OVER (...).\n+                # Instead, leave window-compatible functions uncast here so the OVER\n+                # clause can be attached properly. If needed, casting should be applied\n+                # to the full window expression elsewhere.\n+                upper_sql = sql.upper()\n+                window_funcs = ('LAG(', 'LEAD(', 'FIRST_VALUE(', 'LAST_VALUE(', 'NTH_VALUE(')\n+                if any(upper_sql.startswith(name) for name in window_funcs):\n+                    return sql, params\n                 sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..82b7133 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -19,11 +19,33 @@ class SQLiteNumericMixin:\n     \"\"\"\n     Some expressions with output_field=DecimalField() must be cast to\n     numeric to be properly filtered.\n+\n+    On SQLite, window functions are rendered with a trailing OVER (...)\n+    clause by the outer Window expression. Casting the inner function\n+    call here would produce invalid SQL, e.g.:\n+        CAST(LAG(...) AS NUMERIC) OVER (...)\n+    which SQLite rejects. To avoid this, skip casting for known window\n+    and aggregate functions so the OVER clause can be attached directly\n+    to the function. If needed, casting should be handled at the outer\n+    level.\n     \"\"\"\n     def as_sqlite(self, compiler, connection, **extra_context):\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n-            if self.output_field.get_internal_type() == 'DecimalField':\n+            if getattr(self, 'output_field', None) and self.output_field.get_internal_type() == 'DecimalField':\n+                # Detect if this is a function likely to be used with an OVER clause.\n+                func_name = None\n+                open_paren = sql.find('(')\n+                if open_paren > 0:\n+                    func_name = sql[:open_paren].strip().upper()\n+                window_or_agg_funcs = {\n+                    'LAG', 'LEAD', 'ROW_NUMBER', 'RANK', 'DENSE_RANK',\n+                    'FIRST_VALUE', 'LAST_VALUE', 'NTILE', 'NTH_VALUE',\n+                    'SUM', 'MIN', 'MAX', 'COUNT', 'AVG',\n+                }\n+                # Skip casting for window/aggregate functions to avoid invalid \"CAST(...) OVER (...)\" SQL.\n+                if func_name in window_or_agg_funcs:\n+                    return sql, params\n                 sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n"
      ]
    }
  ],
  "6_final_selected_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 3ac1bb9..ec1e761 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -19,12 +19,24 @@ class SQLiteNumericMixin:\n     \"\"\"\n     Some expressions with output_field=DecimalField() must be cast to\n     numeric to be properly filtered.\n+\n+    Be careful with window functions on SQLite: attaching OVER (...) to CAST(...)\n+    is invalid SQL (e.g. CAST(LAG(...) AS NUMERIC) OVER (...)). In such cases,\n+    avoid casting here so that the window expression can be rendered correctly.\n     \"\"\"\n     def as_sqlite(self, compiler, connection, **extra_context):\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n-                sql = 'CAST(%s AS NUMERIC)' % sql\n+                upper_sql = sql.upper().lstrip()\n+                # Detect common window functions to avoid generating invalid\n+                # \"CAST(func(...) AS NUMERIC) OVER (...)\" syntax on SQLite.\n+                window_funcs = ('LAG(', 'LEAD(', 'FIRST_VALUE(', 'LAST_VALUE(', 'NTH_VALUE(')\n+                if upper_sql.startswith(window_funcs) or ' OVER ' in upper_sql:\n+                    # Skip casting here; window clause must apply to the function call itself.\n+                    pass\n+                else:\n+                    sql = 'CAST(%s AS NUMERIC)' % sql\n         except FieldError:\n             pass\n         return sql, params\n",
  "7_resolved": true
}