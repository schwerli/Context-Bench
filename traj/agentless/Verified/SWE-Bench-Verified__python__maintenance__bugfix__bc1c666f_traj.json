{
  "instance_id": "SWE-Bench-Verified__python__maintenance__bugfix__bc1c666f",
  "original_id": "sympy__sympy-12489",
  "1_model_selected_files": [
    "sympy/combinatorics/permutations.py"
  ],
  "2_embedding_selected_files": [
    "sympy/combinatorics/permutations.py",
    "sympy/combinatorics/__init__.py",
    "sympy/combinatorics/perm_groups.py",
    "sympy/combinatorics/polyhedron.py",
    "sympy/combinatorics/partitions.py",
    "sympy/core/core.py",
    "sympy/core/basic.py",
    "sympy/combinatorics/subsets.py",
    "sympy/core/singleton.py",
    "sympy/core/sympify.py",
    "sympy/core/assumptions.py",
    "sympy/core/numbers.py",
    "sympy/combinatorics/util.py",
    "sympy/core/function.py",
    "sympy/core/operations.py",
    "sympy/core/expr.py",
    "sympy/combinatorics/named_groups.py",
    "sympy/combinatorics/free_groups.py",
    "sympy/combinatorics/generators.py",
    "sympy/__init__.py",
    "sympy/core/compatibility.py",
    "sympy/core/coreerrors.py",
    "sympy/core/trace.py",
    "sympy/combinatorics/prufer.py",
    "sympy/combinatorics/fp_groups.py",
    "sympy/combinatorics/tensor_can.py",
    "sympy/core/__init__.py",
    "sympy/core/decorators.py",
    "sympy/core/add.py",
    "sympy/core/symbol.py",
    "sympy/core/backend.py",
    "sympy/core/benchmarks/__init__.py",
    "sympy/core/relational.py",
    "sympy/core/logic.py",
    "sympy/core/exprtools.py",
    "sympy/core/mul.py",
    "sympy/setup.py"
  ],
  "3_final_combined_files": [
    "sympy/combinatorics/permutations.py",
    "sympy/combinatorics/__init__.py",
    "sympy/combinatorics/perm_groups.py"
  ],
  "4_related_elements": {
    "sympy/combinatorics/permutations.py": [
      "class: Permutation\nvariable: Perm\nvariable: _af_new"
    ],
    "sympy/combinatorics/perm_groups.py": [
      "class: PermutationGroup\nvariable: rmul\nvariable: _af_new\nfunction: _orbit\nfunction: _orbits\nfunction: _orbit_transversal\nfunction: _stabilizer"
    ],
    "sympy/combinatorics/__init__.py": [
      ""
    ]
  },
  "5_sampled_edit_locs_and_patches": [
    {
      "sample_index": 0,
      "edit_locs": {
        "sympy/combinatorics/permutations.py": [
          "\nfunction: Permutation.__new__\nfunction: Permutation._af_new\nfunction: Permutation.rmul_with_af\nfunction: Permutation.mul_inv\nfunction: Permutation.__mul__\nfunction: Permutation.__pow__\nfunction: Permutation.__xor__\nfunction: Permutation.next_lex\nfunction: Permutation.unrank_nonlex\nfunction: Permutation.__invert__\nfunction: Permutation.commutator\nfunction: Permutation.from_inversion_vector\nfunction: Permutation.random\nfunction: Permutation.unrank_lex\nfunction: Permutation.__rmul__\nfunction: Permutation.__add__\nfunction: Permutation.next_nonlex\nfunction: Permutation.josephus\nfunction: Permutation.__call__"
        ]
      },
      "patches": [
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..52407e2 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,27 +924,27 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n-        \"\"\"A method to produce a Permutation object from a list;\n+    @classmethod\n+    def _af_new(cls, perm):\n+        \"\"\"A method to produce a Permutation (or subclass) object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n         ========\n \n-        >>> from sympy.combinatorics.permutations import Perm\n-        >>> Perm.print_cyclic = False\n+        >>> from sympy.combinatorics.permutations import Permutation\n+        >>> Permutation.print_cyclic = False\n         >>> a = [2,1,3,0]\n-        >>> p = Perm._af_new(a)\n+        >>> p = Permutation._af_new(a)\n         >>> p\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,8 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        cls = type(args[0]) if args else Perm\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1236,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n-        \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        \"\"\"This is needed to coerce other to Permutation in rmul.\"\"\"\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1301,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1342,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1437,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1520,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1630,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1662,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1725,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2126,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2708,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2735,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2754,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2788,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..c263bfc 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,9 +857,9 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n@@ -867,9 +867,9 @@ class Permutation(Basic):\n                     return a\n                 return Perm(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,27 +924,27 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n         ========\n \n-        >>> from sympy.combinatorics.permutations import Perm\n-        >>> Perm.print_cyclic = False\n+        >>> from sympy.combinatorics.permutations import Permutation\n+        >>> Permutation.print_cyclic = False\n         >>> a = [2,1,3,0]\n-        >>> p = Perm._af_new(a)\n+        >>> p = Permutation._af_new(a)\n         >>> p\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,7 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = type(args[0])._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..a89c14b 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,7 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = args[0].__class__._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,7 +1235,7 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..5d854fd 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -878,7 +878,6 @@ class Permutation(Basic):\n             raise ValueError(\"Permutation argument must be a list of ints, \"\n                              \"a list of lists, Permutation or Cycle.\")\n \n-\n         # safe to assume args are valid; this also makes a copy\n         # of the args\n         args = list(args[0])\n@@ -924,8 +923,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +943,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1158,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1218,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1234,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1299,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1340,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1435,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1518,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1570,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,10 +1628,10 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n-    def unrank_nonlex(self, n, r):\n+    def unrank_nonlex(cls, n, r):\n         \"\"\"\n         This is a linear time unranking algorithm that does not\n         respect lexicographic order [3].\n@@ -1661,7 +1660,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return cls._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1723,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2124,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2706,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2733,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2752,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2786,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..6bcd71a 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = self.__class__.unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..46277fb 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1337,11 +1337,11 @@ class Permutation(Basic):\n         >>> p**4\n         Permutation([0, 1, 2, 3])\n         \"\"\"\n-        if type(n) == Perm:\n+        if isinstance(n, Perm):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..8779e14 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = self.__class__.unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,7 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = args[0].__class__._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..0d1a5d9 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n-        \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        \"\"\"This is needed to coerce other to Permutation in rmul.\"\"\"\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..7571943 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,17 +857,17 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n                 return _af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,7 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = args[0].__class__._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..9dc3a55 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n"
      ]
    },
    {
      "sample_index": 1,
      "edit_locs": {
        "sympy/combinatorics/permutations.py": [
          "\nfunction: Permutation._af_new\nfunction: Permutation.__new__\nfunction: Permutation.__add__\nfunction: Permutation.rmul_with_af\nfunction: Permutation.mul_inv\nfunction: Permutation.__rmul__\nfunction: Permutation.__mul__\nfunction: Permutation.__pow__\nfunction: Permutation.__xor__\nfunction: Permutation.__invert__\nfunction: Permutation.next_lex\nfunction: Permutation.unrank_nonlex\nfunction: Permutation.next_nonlex\nfunction: Permutation.from_sequence\nfunction: Permutation.unrank_trotterjohnson\nfunction: Permutation.josephus\nfunction: Permutation.from_inversion_vector\nfunction: Permutation.random\nfunction: Permutation.unrank_lex\nline: 2830\nline: 2831"
        ]
      },
      "patches": [
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..ad1ac71 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return a.__class__(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n-        \"\"\"A method to produce a Permutation object from a list;\n+    @classmethod\n+    def _af_new(cls, perm):\n+        \"\"\"A method to produce a Permutation-like object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = self.__class__.unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..8a3b6e8 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~cls([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return cls._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return cls(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n@@ -2827,5 +2827,4 @@ def _merge(arr, temp, left, mid, right):\n         arr[left:right + 1] = temp[left:right + 1]\n     return inv_count\n \n-Perm = Permutation\n-_af_new = Perm._af_new\n+Perm = Permutation\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..dc806ab 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,7 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = args[0].__class__._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self.__class__._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self.__class__._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self.__class__._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self.__class__._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self.__class__._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self.__class__._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n@@ -2828,4 +2828,4 @@ def _merge(arr, temp, left, mid, right):\n     return inv_count\n \n Perm = Permutation\n-_af_new = Perm._af_new\n+# _af_new = Perm._af_new\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..7bbf439 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,21 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n-            if isinstance(a, Perm):  # g\n+            if isinstance(a, Permutation):  # g\n                 if size is None or size == a.size:\n-                    return a\n-                return Perm(a.array_form, size=size)\n+                    if isinstance(a, cls):\n+                        return a\n+                    return cls(a.array_form, size=a.size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +926,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +946,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1161,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1221,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1237,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1302,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1343,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1438,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1521,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1631,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1663,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return cls._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1726,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2425,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2709,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return cls(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2736,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2755,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2789,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n@@ -2827,5 +2829,4 @@ def _merge(arr, temp, left, mid, right):\n         arr[left:right + 1] = temp[left:right + 1]\n     return inv_count\n \n-Perm = Permutation\n-_af_new = Perm._af_new\n+Perm = Permutation\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..c25f665 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..e8b87d9 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n-        \"\"\"A method to produce a Permutation object from a list;\n+    @classmethod\n+    def _af_new(cls, perm):\n+        \"\"\"A method to produce a Permutation object (or subclass) from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = self.__class__.unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n-        \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        \"\"\"This is needed to coerce other to Permutation in rmul.\"\"\"\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..bc7b115 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = self.__class__.unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,8 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        cls = args[0].__class__ if args else Permutation\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1236,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self.__class__._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1301,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1337,11 +1338,11 @@ class Permutation(Basic):\n         >>> p**4\n         Permutation([0, 1, 2, 3])\n         \"\"\"\n-        if type(n) == Perm:\n+        if isinstance(n, Permutation):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self.__class__._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1437,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self.__class__._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1500,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1520,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self.__class__._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1630,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1662,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1725,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2424,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2708,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2735,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2754,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2788,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..a898686 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,22 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n-                    return a\n-                return Perm(a.array_form, size=size)\n+                    if a.__class__ is cls:\n+                        return a\n+                    else:\n+                        return cls(a.array_form, size=a.size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +927,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +947,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1162,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1222,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1238,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self.__class__._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1303,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1436,7 +1439,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self.__class__._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1502,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1522,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self.__class__._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1632,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1664,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1727,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2426,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2710,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2737,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2756,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2790,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..eed2156 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other) * self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n@@ -2827,5 +2827,4 @@ def _merge(arr, temp, left, mid, right):\n         arr[left:right + 1] = temp[left:right + 1]\n     return inv_count\n \n-Perm = Permutation\n-_af_new = Perm._af_new\n+Perm = Permutation\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..e1b09a3 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n-        \"\"\"A method to produce a Permutation object from a list;\n+    @classmethod\n+    def _af_new(cls, perm):\n+        \"\"\"A method to produce a Permutation (or subclass) object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n-        \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        \"\"\"This is needed to coerce other to Permutation in rmul.\"\"\"\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1477,7 +1477,7 @@ class Permutation(Basic):\n         return res\n \n     @classmethod\n-    def from_sequence(self, i, key=None):\n+    def from_sequence(cls, i, key=None):\n         \"\"\"Return the permutation needed to obtain ``i`` from the sorted\n         elements of ``i``. If custom sorting is desired, a key can be given.\n \n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~cls([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n"
      ]
    },
    {
      "sample_index": 2,
      "edit_locs": {
        "sympy/combinatorics/permutations.py": [
          "\nfunction: Permutation._af_new\nfunction: Permutation.__new__\nfunction: Permutation.__add__\nfunction: Permutation.__rmul__\nfunction: Permutation.__mul__\nfunction: Permutation.__pow__\nfunction: Permutation.__xor__\nfunction: Permutation.__invert__\nfunction: Permutation.__call__\nfunction: Permutation.rmul_with_af\nfunction: Permutation.mul_inv\nfunction: Permutation.next_lex\nfunction: Permutation.unrank_nonlex\nfunction: Permutation.unrank_trotterjohnson\nfunction: Permutation.next_trotterjohnson\nfunction: Permutation.josephus\nfunction: Permutation.from_inversion_vector\nfunction: Permutation.random\nfunction: Permutation.unrank_lex\nline: 868\nline: 860\nline: 862\nline: 871\nline: 872\nline: 927\nline: 947\nline: 2831"
        ]
      },
      "patches": [
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..a113596 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return self._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..cc918eb 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..ada51b0 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,7 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = args[0].__class__._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,7 +1235,7 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..cca4d52 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..3788e9d 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n-                    return a\n-                return Perm(a.array_form, size=size)\n+                    return a if isinstance(a, cls) else cls(a.array_form, size=a.size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n-        \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        \"\"\"This is needed to coerce other to Permutation in rmul.\"\"\"\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1337,11 +1337,11 @@ class Permutation(Basic):\n         >>> p**4\n         Permutation([0, 1, 2, 3])\n         \"\"\"\n-        if type(n) == Perm:\n+        if isinstance(n, Permutation):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..baaba3b 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n-        \"\"\"A method to produce a Permutation object from a list;\n+    @classmethod\n+    def _af_new(cls, perm):\n+        \"\"\"A method to produce a Permutation (or subclass) object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~cls([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return self._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..bce05fa 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1337,11 +1337,11 @@ class Permutation(Basic):\n         >>> p**4\n         Permutation([0, 1, 2, 3])\n         \"\"\"\n-        if type(n) == Perm:\n+        if isinstance(n, Permutation):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,10 +1629,10 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n-    def unrank_nonlex(self, n, r):\n+    def unrank_nonlex(cls, n, r):\n         \"\"\"\n         This is a linear time unranking algorithm that does not\n         respect lexicographic order [3].\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return cls._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2390,7 +2390,7 @@ class Permutation(Basic):\n         return rank\n \n     @classmethod\n-    def unrank_trotterjohnson(self, size, rank):\n+    def unrank_trotterjohnson(cls, size, rank):\n         \"\"\"\n         Trotter Johnson permutation unranking. See [4] section 2.4.\n \n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2661,7 +2661,7 @@ class Permutation(Basic):\n         return sum([abs(a[i] - b[i]) for i in range(len(a))])\n \n     @classmethod\n-    def josephus(self, m, n, s=1):\n+    def josephus(cls, m, n, s=1):\n         \"\"\"Return as a permutation the shuffling of range(n) using the Josephus\n         scheme in which every m-th item is selected until all have been chosen.\n         The returned permutation has elements listed by the order in which they\n@@ -2707,10 +2707,10 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return cls(perm)\n \n     @classmethod\n-    def from_inversion_vector(self, inversion):\n+    def from_inversion_vector(cls, inversion):\n         \"\"\"\n         Calculates the permutation from the inversion vector.\n \n@@ -2734,10 +2734,10 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n-    def random(self, n):\n+    def random(cls, n):\n         \"\"\"\n         Generates a random permutation of length ``n``.\n \n@@ -2753,10 +2753,10 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     @classmethod\n-    def unrank_lex(self, size, rank):\n+    def unrank_lex(cls, size, rank):\n         \"\"\"\n         Lexicographic permutation unranking.\n \n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n@@ -2827,5 +2827,4 @@ def _merge(arr, temp, left, mid, right):\n         arr[left:right + 1] = temp[left:right + 1]\n     return inv_count\n \n-Perm = Permutation\n-_af_new = Perm._af_new\n+Perm = Permutation\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..3e3c26e 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n-        \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        \"\"\"This is needed to coerce other to this Permutation class in rmul.\"\"\"\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,10 +1629,10 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n-    def unrank_nonlex(self, n, r):\n+    def unrank_nonlex(cls, n, r):\n         \"\"\"\n         This is a linear time unranking algorithm that does not\n         respect lexicographic order [3].\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return cls._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2390,7 +2390,7 @@ class Permutation(Basic):\n         return rank\n \n     @classmethod\n-    def unrank_trotterjohnson(self, size, rank):\n+    def unrank_trotterjohnson(cls, size, rank):\n         \"\"\"\n         Trotter Johnson permutation unranking. See [4] section 2.4.\n \n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2661,7 +2661,7 @@ class Permutation(Basic):\n         return sum([abs(a[i] - b[i]) for i in range(len(a))])\n \n     @classmethod\n-    def josephus(self, m, n, s=1):\n+    def josephus(cls, m, n, s=1):\n         \"\"\"Return as a permutation the shuffling of range(n) using the Josephus\n         scheme in which every m-th item is selected until all have been chosen.\n         The returned permutation has elements listed by the order in which they\n@@ -2707,10 +2707,10 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return cls(perm)\n \n     @classmethod\n-    def from_inversion_vector(self, inversion):\n+    def from_inversion_vector(cls, inversion):\n         \"\"\"\n         Calculates the permutation from the inversion vector.\n \n@@ -2734,10 +2734,10 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return cls._af_new(perm)\n \n     @classmethod\n-    def random(self, n):\n+    def random(cls, n):\n         \"\"\"\n         Generates a random permutation of length ``n``.\n \n@@ -2753,10 +2753,10 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     @classmethod\n-    def unrank_lex(self, size, rank):\n+    def unrank_lex(cls, size, rank):\n         \"\"\"\n         Lexicographic permutation unranking.\n \n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return cls._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n@@ -2827,5 +2827,4 @@ def _merge(arr, temp, left, mid, right):\n         arr[left:right + 1] = temp[left:right + 1]\n     return inv_count\n \n-Perm = Permutation\n-_af_new = Perm._af_new\n+Perm = Permutation\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..90d620a 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,23 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n-                    return a\n-                return Perm(a.array_form, size=size)\n+                    # preserve instance if same class, otherwise create new of cls\n+                    if isinstance(a, cls):\n+                        return a\n+                    else:\n+                        return cls(a.array_form, size=a.size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -878,7 +882,6 @@ class Permutation(Basic):\n             raise ValueError(\"Permutation argument must be a list of ints, \"\n                              \"a list of lists, Permutation or Cycle.\")\n \n-\n         # safe to assume args are valid; this also makes a copy\n         # of the args\n         args = list(args[0])\n@@ -924,8 +927,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +947,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1162,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1222,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,7 +1238,7 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n@@ -1300,7 +1303,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1344,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1439,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1522,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1632,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1664,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2423,7 +2426,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2480,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return self._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2710,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2737,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2756,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2790,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n@@ -2828,4 +2831,4 @@ def _merge(arr, temp, left, mid, right):\n     return inv_count\n \n Perm = Permutation\n-_af_new = Perm._af_new\n+# _af_new alias removed to allow subclassing to use cls._af_new\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..96e7458 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1226,7 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = args[0].__class__._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2828,4 +2828,4 @@ def _merge(arr, temp, left, mid, right):\n     return inv_count\n \n Perm = Permutation\n-_af_new = Perm._af_new\n+_af_new = lambda perm: Perm._af_new(perm)\n"
      ]
    },
    {
      "sample_index": 3,
      "edit_locs": {
        "sympy/combinatorics/permutations.py": [
          "\nfunction: Permutation._af_new\nline: 927\nline: 928\nline: 947\nfunction: Permutation.__new__\nline: 860\nline: 862\nline: 868\nline: 871\nline: 872\nfunction: Permutation.__rmul__\nfunction: Permutation.__mul__\nfunction: Permutation.rmul_with_af\nfunction: Permutation.mul_inv\nfunction: Permutation.__pow__\nfunction: Permutation.__xor__\nfunction: Permutation.__invert__\nfunction: Permutation.__call__\nline: 1574\nfunction: Permutation.next_lex\nline: 1632\nfunction: Permutation.unrank_nonlex\nline: 1664\nfunction: Permutation.next_nonlex\nline: 1727\nfunction: Permutation.__add__\nline: 1162\nfunction: Permutation.from_sequence\nfunction: Permutation.unrank_trotterjohnson\nline: 2426\nfunction: Permutation.next_trotterjohnson\nline: 2480\nfunction: Permutation.josephus\nline: 2710\nfunction: Permutation.from_inversion_vector\nline: 2737\nfunction: Permutation.random\nline: 2756\nfunction: Permutation.unrank_lex\nline: 2790\nfunction: Permutation.commutator\nline: 2128\nline: 2129"
        ]
      },
      "patches": [
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..a50b1c8 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..f7d4d9d 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = self.__class__.unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*self.__class__(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return self._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..1c11d64 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1337,11 +1337,11 @@ class Permutation(Basic):\n         >>> p**4\n         Permutation([0, 1, 2, 3])\n         \"\"\"\n-        if type(n) == Perm:\n+        if isinstance(n, Perm):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return self._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..db24b22 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = self.__class__.unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return self._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..3aefd20 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,19 +924,19 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n-        \"\"\"A method to produce a Permutation object from a list;\n+    @classmethod\n+    def _af_new(cls, perm):\n+        \"\"\"A method to produce a Permutation (or subclass) object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n         ========\n \n-        >>> from sympy.combinatorics.permutations import Perm\n+        >>> from sympy.combinatorics.permutations import Permutation as Perm\n         >>> Perm.print_cyclic = False\n         >>> a = [2,1,3,0]\n         >>> p = Perm._af_new(a)\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..f907e75 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n-        \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        \"\"\"This is needed to coerce other to Permutation in rmul.\"\"\"\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return type(self)._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..2988ae5 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +924,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..d4a1bbe 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return self._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..8fa13a9 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,22 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n-                    return a\n-                return Perm(a.array_form, size=size)\n+                    # Preserve instance if already of this class; otherwise coerce to this class\n+                    if isinstance(a, cls):\n+                        return a\n+                    return cls(a.array_form, size=a.size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,8 +927,8 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n@@ -944,7 +947,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1162,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1226,7 +1229,7 @@ class Permutation(Basic):\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = type(args[0])._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1238,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return type(self)._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1303,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1344,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return type(self)._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1439,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return type(self)._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1502,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1522,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return type(self)._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1574,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1632,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1664,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1727,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2128,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return type(self)._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2426,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2480,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return type(self)._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2710,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2737,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2756,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2790,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
        "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..ef64332 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n-        \"\"\"A method to produce a Permutation object from a list;\n+    @classmethod\n+    def _af_new(cls, perm):\n+        \"\"\"A method to produce a Permutation (or subclass) object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = type(self).unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return type(self)(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1571,7 +1571,7 @@ class Permutation(Basic):\n                     raise TypeError('unrecognized argument')\n         else:\n             # P(1, 2, 3)\n-            return self*Permutation(Cycle(*i), size=self.size)\n+            return self*type(self)(Cycle(*i), size=self.size)\n \n     def atoms(self):\n         \"\"\"\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return type(self).unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2125,7 +2125,7 @@ class Permutation(Basic):\n         invb = [None]*n\n         for i in range(n):\n             invb[b[i]] = i\n-        return _af_new([a[b[inva[i]]] for i in invb])\n+        return self._af_new([a[b[inva[i]]] for i in invb])\n \n     def signature(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2477,7 +2477,7 @@ class Permutation(Basic):\n                     done = True\n         if m == 0:\n             return None\n-        return _af_new(pi)\n+        return self._af_new(pi)\n \n     def get_precedence_matrix(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n"
      ]
    }
  ],
  "6_final_selected_patch": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..ad1ac71 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,19 @@ class Permutation(Basic):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+            return cls._af_new(list(range(size or 0)))\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size))\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+                return a.__class__(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+                return cls._af_new(a.list(size))\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n-        \"\"\"A method to produce a Permutation object from a list;\n+    @classmethod\n+    def _af_new(cls, perm):\n+        \"\"\"A method to produce a Permutation-like object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n@@ -1159,7 +1159,7 @@ class Permutation(Basic):\n \n         \"\"\"\n         rank = (self.rank() + other) % self.cardinality\n-        rv = Perm.unrank_lex(self.size, rank)\n+        rv = self.__class__.unrank_lex(self.size, rank)\n         rv._rank = rank\n         return rv\n \n@@ -1219,14 +1219,14 @@ class Permutation(Basic):\n             rv = args[i]*rv\n         return rv\n \n-    @staticmethod\n-    def rmul_with_af(*args):\n+    @classmethod\n+    def rmul_with_af(cls, *args):\n         \"\"\"\n         same as rmul, but the elements of args are Permutation objects\n         which have _array_form\n         \"\"\"\n         a = [x._array_form for x in args]\n-        rv = _af_new(_af_rmuln(*a))\n+        rv = cls._af_new(_af_rmuln(*a))\n         return rv\n \n     def mul_inv(self, other):\n@@ -1235,11 +1235,11 @@ class Permutation(Basic):\n         \"\"\"\n         a = _af_invert(self._array_form)\n         b = other._array_form\n-        return _af_new(_af_rmul(a, b))\n+        return self._af_new(_af_rmul(a, b))\n \n     def __rmul__(self, other):\n         \"\"\"This is needed to coerse other to Permutation in rmul.\"\"\"\n-        return Perm(other)*self\n+        return self.__class__(other)*self\n \n     def __mul__(self, other):\n         \"\"\"\n@@ -1300,7 +1300,7 @@ class Permutation(Basic):\n         else:\n             b.extend(list(range(len(b), len(a))))\n             perm = [b[i] for i in a] + b[len(a):]\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def commutes_with(self, other):\n         \"\"\"\n@@ -1341,7 +1341,7 @@ class Permutation(Basic):\n             raise NotImplementedError(\n                 'p**p is not defined; do you mean p^p (conjugate)?')\n         n = int(n)\n-        return _af_new(_af_pow(self.array_form, n))\n+        return self._af_new(_af_pow(self.array_form, n))\n \n     def __rxor__(self, i):\n         \"\"\"Return self(i) when ``i`` is an int.\n@@ -1436,7 +1436,7 @@ class Permutation(Basic):\n         p = self._array_form\n         for i in range(self.size):\n             a[h[i]] = h[p[i]]\n-        return _af_new(a)\n+        return self._af_new(a)\n \n     def transpositions(self):\n         \"\"\"\n@@ -1499,7 +1499,7 @@ class Permutation(Basic):\n             ic.sort(key=lambda x: key(x[0]))\n         else:\n             ic.sort()\n-        return ~Permutation([i[1] for i in ic])\n+        return ~self([i[1] for i in ic])\n \n     def __invert__(self):\n         \"\"\"\n@@ -1519,7 +1519,7 @@ class Permutation(Basic):\n         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n         True\n         \"\"\"\n-        return _af_new(_af_invert(self._array_form))\n+        return self._af_new(_af_invert(self._array_form))\n \n     def __iter__(self):\n         \"\"\"Yield elements from array form.\n@@ -1629,7 +1629,7 @@ class Permutation(Basic):\n                 perm[j], perm[i] = perm[i], perm[j]\n                 i += 1\n                 j -= 1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def unrank_nonlex(self, n, r):\n@@ -1661,7 +1661,7 @@ class Permutation(Basic):\n         n = int(n)\n         r = r % ifac(n)\n         _unrank1(n, r, id_perm)\n-        return _af_new(id_perm)\n+        return self._af_new(id_perm)\n \n     def rank_nonlex(self, inv_perm=None):\n         \"\"\"\n@@ -1724,7 +1724,7 @@ class Permutation(Basic):\n         r = self.rank_nonlex()\n         if r == ifac(self.size) - 1:\n             return None\n-        return Perm.unrank_nonlex(self.size, r + 1)\n+        return self.__class__.unrank_nonlex(self.size, r + 1)\n \n     def rank(self):\n         \"\"\"\n@@ -2423,7 +2423,7 @@ class Permutation(Basic):\n                     perm[i] = perm[i - 1]\n                 perm[k] = j - 1\n             r2 = r1\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     def next_trotterjohnson(self):\n         \"\"\"\n@@ -2707,7 +2707,7 @@ class Permutation(Basic):\n                 Q.append(Q.popleft())\n             perm.append(Q.popleft())\n         perm.extend(list(Q))\n-        return Perm(perm)\n+        return self(perm)\n \n     @classmethod\n     def from_inversion_vector(self, inversion):\n@@ -2734,7 +2734,7 @@ class Permutation(Basic):\n         except IndexError:\n             raise ValueError(\"The inversion vector is not valid.\")\n         perm.extend(N)\n-        return _af_new(perm)\n+        return self._af_new(perm)\n \n     @classmethod\n     def random(self, n):\n@@ -2753,7 +2753,7 @@ class Permutation(Basic):\n         \"\"\"\n         perm_array = list(range(n))\n         random.shuffle(perm_array)\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     @classmethod\n     def unrank_lex(self, size, rank):\n@@ -2787,7 +2787,7 @@ class Permutation(Basic):\n                 if perm_array[j] > d - 1:\n                     perm_array[j] += 1\n             psize = new_psize\n-        return _af_new(perm_array)\n+        return self._af_new(perm_array)\n \n     # global flag to control how permutations are printed\n     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)\n",
  "7_resolved": false
}