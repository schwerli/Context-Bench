{
  "instance_id": "SWE-Bench-Verified__python__maintenance__bugfix__2ccbdc72",
  "original_id": "django__django-15930",
  "1_model_selected_files": [
    "django/db/models/expressions.py",
    "django/db/models/sql/where.py",
    "django/db/models/query_utils.py",
    "django/db/models/lookups.py"
  ],
  "2_embedding_selected_files": [
    "django/db/models/expressions.py",
    "django/db/models/sql/compiler.py",
    "django/db/backends/mysql/compiler.py",
    "django/db/backends/postgresql/operations.py",
    "django/db/backends/oracle/features.py",
    "django/db/backends/oracle/operations.py",
    "django/db/models/sql/where.py",
    "django/db/models/sql/__init__.py",
    "django/db/models/sql/subqueries.py",
    "django/db/backends/mysql/operations.py",
    "django/db/models/query_utils.py",
    "django/db/backends/sqlite3/operations.py",
    "django/db/backends/sqlite3/base.py",
    "django/db/backends/base/operations.py",
    "django/db/models/__init__.py",
    "django/db/backends/postgresql/introspection.py",
    "django/db/models/query.py",
    "django/db/models/fields/json.py",
    "django/db/models/base.py",
    "django/db/backends/base/features.py",
    "django/db/models/sql/query.py",
    "django/db/backends/oracle/introspection.py",
    "django/db/backends/postgresql/features.py",
    "django/db/models/functions/comparison.py",
    "django/db/models/lookups.py",
    "django/db/backends/postgresql/schema.py",
    "django/db/models/constraints.py",
    "django/db/models/fields/related_lookups.py",
    "django/db/backends/oracle/schema.py",
    "django/db/models/functions/text.py",
    "django/db/models/deletion.py",
    "django/db/models/utils.py",
    "django/db/backends/mysql/schema.py",
    "django/db/migrations/questioner.py",
    "django/db/backends/mysql/features.py",
    "django/db/models/sql/datastructures.py",
    "django/db/backends/oracle/base.py",
    "django/db/backends/base/schema.py",
    "django/db/models/fields/related.py",
    "django/db/models/aggregates.py",
    "django/db/backends/sqlite3/features.py",
    "django/db/backends/sqlite3/introspection.py",
    "django/db/migrations/operations/models.py",
    "django/db/backends/oracle/creation.py",
    "django/db/models/fields/__init__.py",
    "django/db/models/sql/constants.py",
    "django/db/models/indexes.py",
    "django/db/backends/postgresql/__init__.py",
    "django/db/migrations/executor.py",
    "django/db/backends/sqlite3/schema.py",
    "django/db/backends/sqlite3/__init__.py",
    "django/db/migrations/operations/special.py"
  ],
  "3_final_combined_files": [
    "django/db/models/expressions.py",
    "django/db/models/sql/where.py",
    "django/db/models/query_utils.py",
    "django/db/models/sql/compiler.py",
    "django/db/backends/mysql/compiler.py"
  ],
  "4_related_elements": {
    "django/db/models/expressions.py": [
      "class: When\nclass: Case"
    ],
    "django/db/models/sql/where.py": [
      "class: WhereNode\nclass: NothingNode\nvariable: AND\nvariable: OR\nvariable: XOR"
    ],
    "django/db/models/query_utils.py": [
      "class: Q"
    ]
  },
  "5_sampled_edit_locs_and_patches": [
    {
      "sample_index": 0,
      "edit_locs": {
        "django/db/models/expressions.py": [
          "\nfunction: When.as_sql"
        ]
      },
      "patches": [
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..4812d0e 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,12 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition simplifies to a no-op (e.g., ~Q(pk__in=[])), the\n+        # compiler may return an empty SQL fragment. In a CASE WHEN clause,\n+        # this results in invalid SQL (\"WHEN THEN ...\"). Treat such cases as\n+        # a tautology.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..b1c5968 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # An empty condition SQL indicates an always-true condition in some cases\n+        # (e.g., ~Q(pk__in=[])). Ensure we generate valid SQL for the WHEN clause.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..61f3dbc 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g., negated empty IN\n+        # producing a no-op/always-true condition), ensure the CASE WHEN remains\n+        # syntactically valid by substituting an always-true expression.\n+        if not condition_sql or not condition_sql.strip():\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..7126cda 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty (e.g., a Q object that simplifies\n+        # to an always-true predicate), use a tautology so the generated CASE\n+        # statement remains valid SQL.\n+        if not condition_sql.strip():\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..f1125f2 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        if not condition_sql:\n+            # Handle conditions that compile to no-op SQL (e.g., ~Q(pk__in=[])\n+            # which is a tautology and compiles to an empty WHERE). In a CASE\n+            # WHEN clause we must emit a valid boolean predicate.\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..78f2c9f 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,12 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g., an always-true\n+        # sentinel such as ~Q(pk__in=[])), provide an explicit TRUE expression\n+        # to keep the CASE syntax valid across backends.\n+        if not condition_sql:\n+            true_sql, true_params = compiler.compile(Value(True))\n+            condition_sql, condition_params = true_sql, true_params\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..46d0c06 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        if not condition_sql:\n+            # If the condition compiles to an empty string (e.g., a WhereNode that\n+            # represents an always-true condition like ~Q(pk__in=[])), ensure we\n+            # render a valid predicate within CASE/WHEN by using a tautology.\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..82160c1 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,12 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # Ensure a valid SQL predicate when the condition simplifies to an\n+        # \"always true\" no-op (e.g., ~Q(pk__in=[])), which may compile to an\n+        # empty string in WHERE contexts. Inside CASE WHEN, we must emit a\n+        # concrete predicate.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..77584fb 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty (e.g., from an empty WhereNode),\n+        # treat it as a tautology to avoid generating \"WHEN THEN\" which is invalid SQL.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..bd39e8f 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,17 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty, provide a valid SQL boolean expression.\n+        # This can occur with constructs like ~Q(pk__in=[]) which are effectively\n+        # tautologies but may compile to an empty condition in non-WHERE contexts.\n+        if not condition_sql:\n+            # If the original condition has a 'negated' attribute (e.g., Q objects),\n+            # use it to decide whether the empty condition should be treated as\n+            # always-true or always-false. Otherwise default to a tautology.\n+            if hasattr(self.condition, \"negated\"):\n+                condition_sql = \"1=1\" if self.condition.negated else \"0=1\"\n+            else:\n+                condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n"
      ]
    },
    {
      "sample_index": 1,
      "edit_locs": {
        "django/db/models/expressions.py": [
          "\nfunction: When.as_sql"
        ]
      },
      "patches": [
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..4f6f558 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty SQL string (e.g., a tautology like ~Q(pk__in=[])),\n+        # use a boolean TRUE literal to produce valid SQL in CASE WHEN.\n+        if not condition_sql:\n+            condition_sql, condition_params = compiler.compile(Value(True))\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..e751bd4 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty (e.g., from ~Q(pk__in=[])),\n+        # treat it as an always-true predicate to avoid generating\n+        # \"CASE WHEN THEN ...\" which is invalid SQL.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..8e53bd7 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty (e.g., ~Q(pk__in=[]) which is a tautology),\n+        # ensure we render a valid SQL condition inside WHEN.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..7416488 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to empty SQL (e.g., ~Q(pk__in=[])),\n+        # treat it as a tautology to avoid generating 'WHEN THEN'.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..5a9816a 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g., a tautology like ~Q(pk__in=[])),\n+        # ensure a valid boolean expression is produced for use in CASE/WHEN.\n+        if not condition_sql or not condition_sql.strip():\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..53222dc 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,8 +1299,14 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n-        template_params[\"condition\"] = condition_sql\n-        sql_params.extend(condition_params)\n+        # If the compiled condition is empty (e.g., ~Q(pk__in=[])), treat it as TRUE.\n+        if not condition_sql:\n+            true_sql, true_params = compiler.compile(Value(True))\n+            template_params[\"condition\"] = true_sql\n+            sql_params.extend(true_params)\n+        else:\n+            template_params[\"condition\"] = condition_sql\n+            sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n         template_params[\"result\"] = result_sql\n         sql_params.extend(result_params)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..eccad7b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string, it represents an\n+        # \"always-true\" condition (e.g., ~Q(pk__in=[])). In a CASE WHEN\n+        # context, we must render an explicit tautology.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..c481beb 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        if not condition_sql:\n+            # If the condition compiles to empty SQL (e.g., ~Q(pk__in=[])),\n+            # treat it as a tautology to avoid generating 'WHEN THEN'.\n+            # Using a generic always-true predicate is portable across backends.\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..1188c29 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty (e.g., a trivially true Q object like ~Q(pk__in=[])),\n+        # substitute a SQL literal true condition to keep the CASE syntax valid.\n+        if not (condition_sql or \"\").strip():\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..21c6351 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty SQL fragment (e.g., an \"always true\"\n+        # condition like ~Q(pk__in=[])), provide an explicit SQL boolean expression.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n"
      ]
    },
    {
      "sample_index": 2,
      "edit_locs": {
        "django/db/models/expressions.py": [
          "\nfunction: When.as_sql"
        ]
      },
      "patches": [
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..7e53bab 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,12 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty SQL fragment (e.g., a tautology\n+        # like ~Q(pk__in=[])), substitute a backend-compatible TRUE literal so\n+        # that the generated CASE expression remains valid SQL.\n+        if not condition_sql:\n+            true_sql, true_params = compiler.compile(Value(True))\n+            condition_sql, condition_params = true_sql, true_params\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..6e5e3cc 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string, treat it as a tautology.\n+        # This can happen with expressions like ~Q(pk__in=[]), which should mean\n+        # \"always true\" rather than producing invalid SQL in CASE WHEN.\n+        if not condition_sql.strip():\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..caa037f 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty SQL fragment (e.g., ~Q(pk__in=[])\n+        # resulting in a tautology), treat it as a literal TRUE condition to\n+        # avoid generating \"WHEN THEN ...\" which is invalid SQL.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..2772e00 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g., an always-true\n+        # sentinel like ~Q(pk__in=[])), use an explicit true condition to\n+        # avoid generating invalid SQL like \"WHEN THEN\".\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..8862831 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g., ~Q(pk__in=[])),\n+        # treat it as a tautology so that CASE WHEN generates valid SQL.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..06d6f34 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,12 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g., a no-op that\n+        # represents \"always true\"), replace it with a TRUE literal to avoid\n+        # generating invalid \"WHEN THEN\" SQL.\n+        if not condition_sql:\n+            true_sql, true_params = compiler.compile(Value(True))\n+            condition_sql, condition_params = true_sql, true_params\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..3ec161a 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g., ~Q(pk__in=[])),\n+        # fall back to a SQL tautology to keep \"WHEN <condition>\" syntactically valid.\n+        if not condition_sql.strip():\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..5209bd8 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty, treat it as an always-true predicate.\n+        # This can happen with expressions like ~Q(pk__in=[]), which effectively\n+        # resolve to a truthy condition but produce an empty SQL fragment.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..a38cdf8 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty (e.g., ~Q(pk__in=[])), interpret it as a\n+        # tautology for use in CASE/WHEN contexts to avoid generating invalid SQL.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..1a488ea 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,19 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string, fallback to a boolean\n+        # literal to avoid generating invalid \"WHEN THEN\" SQL.\n+        if not condition_sql:\n+            cond = self.condition\n+            negated = getattr(cond, \"negated\", False)\n+            children = getattr(cond, \"children\", None)\n+            if isinstance(children, (list, tuple)) and len(children) == 0:\n+                # An empty condition (e.g., Q()) matches all rows.\n+                condition_sql, condition_params = compiler.compile(Value(True))\n+            else:\n+                # If the condition was negated (e.g., ~Q(pk__in=[])), treat it as\n+                # always true; otherwise, treat it as always false.\n+                condition_sql, condition_params = compiler.compile(Value(True if negated else False))\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n"
      ]
    },
    {
      "sample_index": 3,
      "edit_locs": {
        "django/db/models/expressions.py": [
          "\nfunction: When.as_sql"
        ]
      },
      "patches": [
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..edef9da 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,12 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # Handle empty conditions (e.g., Q(pk__in=[]) and its negation) to avoid\n+        # generating invalid \"WHEN THEN\" SQL. Treat an empty condition as a constant\n+        # boolean: negated -> TRUE, non-negated -> FALSE.\n+        if not condition_sql:\n+            condition_sql = \"1=1\" if getattr(self.condition, \"negated\", False) else \"1=0\"\n+            condition_params = []\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..f206536 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # Some conditions (e.g., an empty Q object) may compile to an empty\n+        # string which is valid in a WHERE clause but invalid in a CASE WHEN\n+        # expression. In that case, use a tautology to ensure valid SQL.\n+        if not condition_sql or not condition_sql.strip():\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..d992ce0 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty SQL fragment (e.g., an always-true\n+        # Q object like ~Q(pk__in=[])), ensure the CASE WHEN has a valid predicate.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..44e0e37 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty (e.g., tautology like ~Q(pk__in=[])),\n+        # use a backend-appropriate TRUE literal so the WHEN clause is valid SQL.\n+        if not condition_sql:\n+            condition_sql, condition_params = compiler.compile(Value(True))\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..6e591e7 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        if not condition_sql:\n+            # Handle no-op/always-true Q objects (e.g., ~Q(pk__in=[])) which may\n+            # compile to an empty WHERE fragment; ensure a valid SQL condition.\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..771ffe3 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the compiled condition is empty, it represents an always-true condition\n+        # (e.g., ~Q(pk__in=[])). In a CASE WHEN context, we must emit a valid SQL\n+        # predicate instead of an empty string to avoid syntax errors.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..7d2bc71 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,10 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g. an always-true Q),\n+        # render it explicitly as a SQL true predicate to keep CASE WHEN valid.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..e205526 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # Some conditions (e.g., ~Q(pk__in=[])) can compile to an empty string,\n+        # which is valid in a WHERE clause (meaning \"always true\") but invalid\n+        # inside CASE WHEN. In such cases, explicitly use a tautology.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..73d9654 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty string (e.g., a negated empty\n+        # IN clause like ~Q(field__in=[])), treat it as an always-true\n+        # predicate so the CASE WHEN remains valid SQL.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
        "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..bfc79ee 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,20 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition compiles to an empty SQL fragment, provide a sensible\n+        # default. This can happen for cases like Q(pk__in=[]) which is always\n+        # false, and its negation ~Q(pk__in=[]) which is always true.\n+        if not condition_sql:\n+            negated = getattr(self.condition, \"negated\", False)\n+            children = getattr(self.condition, \"children\", None)\n+            # An empty Q() (no children) is always true unless negated.\n+            if children == []:\n+                always_true = not negated\n+            else:\n+                # If the condition compiled to empty due to being unsatisfiable,\n+                # its negation should be always true, otherwise false.\n+                always_true = bool(negated)\n+            condition_sql = \"1=1\" if always_true else \"1=0\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n"
      ]
    }
  ],
  "6_final_selected_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..4812d0e 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,12 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # If the condition simplifies to a no-op (e.g., ~Q(pk__in=[])), the\n+        # compiler may return an empty SQL fragment. In a CASE WHEN clause,\n+        # this results in invalid SQL (\"WHEN THEN ...\"). Treat such cases as\n+        # a tautology.\n+        if not condition_sql:\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n",
  "7_resolved": true
}