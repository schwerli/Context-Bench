diff --git a/decmod.py b/decmod.py
new file mode 100644
index 000000000..6c8198061
--- /dev/null
+++ b/decmod.py
@@ -0,0 +1,7 @@
+import functools
+
+def mydecorator(f):
+    @functools.wraps(f)
+    def wrapper(*args, **kwargs):
+        return f(*args, **kwargs)
+    return wrapper
diff --git a/repro_decorated_init.py b/repro_decorated_init.py
new file mode 100644
index 000000000..80f7ab8f3
--- /dev/null
+++ b/repro_decorated_init.py
@@ -0,0 +1,35 @@
+import functools
+
+# Define a trivial decorator that preserves metadata
+
+def mydecorator(f):
+    @functools.wraps(f)
+    def wrapper(*args, **kwargs):
+        return f(*args, **kwargs)
+    return wrapper
+
+class Foo:
+    @mydecorator
+    def __init__(self, x):
+        """Init docstring for Foo.__init__"""
+        self.x = x
+
+# Build a minimal dummy app/config needed by napoleon._skip_member
+class DummyConfig:
+    napoleon_include_init_with_doc = True
+    napoleon_include_private_with_doc = False
+    napoleon_include_special_with_doc = False
+
+class DummyApp:
+    config = DummyConfig()
+
+
+def main():
+    from sphinx.ext import napoleon
+    # what='class' mimics autodoc calling skip_member for members of a class
+    result = napoleon._skip_member(DummyApp(), 'class', '__init__', Foo.__init__, False, None)
+    print("_skip_member result:", result)
+    # For decorated __init__, we expect False (i.e., do not skip), not None
+
+if __name__ == "__main__":
+    main()
diff --git a/repro_decorated_init_external.py b/repro_decorated_init_external.py
new file mode 100644
index 000000000..79a0f3244
--- /dev/null
+++ b/repro_decorated_init_external.py
@@ -0,0 +1,24 @@
+from decmod import mydecorator
+
+class Bar:
+    @mydecorator
+    def __init__(self):
+        """Init docstring for Bar.__init__ decorated by external decorator"""
+        pass
+
+class DummyConfig:
+    napoleon_include_init_with_doc = True
+    napoleon_include_private_with_doc = False
+    napoleon_include_special_with_doc = False
+
+class DummyApp:
+    config = DummyConfig()
+
+
+def main():
+    from sphinx.ext import napoleon
+    result = napoleon._skip_member(DummyApp(), 'class', '__init__', Bar.__init__, False, None)
+    print("_skip_member external decorator result:", result)
+
+if __name__ == "__main__":
+    main()
diff --git a/repro_decorated_init_nested.py b/repro_decorated_init_nested.py
new file mode 100644
index 000000000..fc75d1373
--- /dev/null
+++ b/repro_decorated_init_nested.py
@@ -0,0 +1,26 @@
+import functools
+from decmod import mydecorator
+
+class Outer:
+    class Inner:
+        @mydecorator
+        def __init__(self):
+            """Init docstring for Inner.__init__"""
+            pass
+
+class DummyConfig:
+    napoleon_include_init_with_doc = True
+    napoleon_include_private_with_doc = False
+    napoleon_include_special_with_doc = False
+
+class DummyApp:
+    config = DummyConfig()
+
+
+def main():
+    from sphinx.ext import napoleon
+    result = napoleon._skip_member(DummyApp(), 'class', '__init__', Outer.Inner.__init__, False, None)
+    print("_skip_member nested result:", result)
+
+if __name__ == "__main__":
+    main()
diff --git a/sphinx/ext/napoleon/__init__.py b/sphinx/ext/napoleon/__init__.py
index 10b1ff3a3..48ee5a845 100644
--- a/sphinx/ext/napoleon/__init__.py
+++ b/sphinx/ext/napoleon/__init__.py
@@ -430,15 +430,16 @@ def _skip_member(app: Sphinx, what: str, name: str, obj: Any,
             cls_path, _, _ = qualname.rpartition('.')
             if cls_path:
                 try:
-                    if '.' in cls_path:
-                        import importlib
-                        import functools
+                    import importlib
+                    import functools
 
-                        mod = importlib.import_module(obj.__module__)
+                    mod = importlib.import_module(obj.__module__)
+                    if '.' in cls_path:
                         mod_path = cls_path.split('.')
                         cls = functools.reduce(getattr, mod_path, mod)
                     else:
-                        cls = obj.__globals__[cls_path]
+                        # Fallback for decorated methods: obj.__globals__ may not contain the class
+                        cls = getattr(mod, cls_path)
                 except Exception:
                     cls_is_owner = False
                 else:
