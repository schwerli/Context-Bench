diff --git a/repro_hnf_flip.py b/repro_hnf_flip.py
new file mode 100644
index 0000000000..df705406f3
--- /dev/null
+++ b/repro_hnf_flip.py
@@ -0,0 +1,25 @@
+from sympy import Matrix
+from sympy.polys.matrices import DomainMatrix
+from sympy.polys.domains import ZZ
+from sympy.polys.matrices.normalforms import hermite_normal_form
+
+# Build the input without numpy
+A = [[5, 8, 12], [0, 0, 1]]
+# flip both axes: equivalent to reversed rows and reversed columns
+B = [list(reversed(row)) for row in reversed(A)]
+M = Matrix(B).T
+DM_M = DomainMatrix.from_Matrix(M, fmt='dense')
+hnf = hermite_normal_form(DM_M)
+res = hnf.transpose()
+# flip back both axes on the dense list
+res_list = res.to_list()
+res_list = [list(reversed(row)) for row in reversed(res_list)]
+
+print("Input A:")
+print(Matrix(A))
+print("Flipped/transposed input to HNF (M):")
+print(M)
+print("HNF(M):")
+print(hnf.to_Matrix())
+print("Final result after transpose/flip:")
+print(Matrix(res_list))
diff --git a/run_checks.py b/run_checks.py
new file mode 100644
index 0000000000..3cbfa5de57
--- /dev/null
+++ b/run_checks.py
@@ -0,0 +1,34 @@
+from sympy.polys.matrices.normalforms import hermite_normal_form
+from sympy.polys.domains import ZZ
+from sympy.polys.matrices import DM
+
+# Construct matrices over ZZ using DM helper
+m = DM([[2, 7, 17, 29, 41], [3, 11, 19, 31, 43], [5, 13, 23, 37, 47]], ZZ)
+hnf = DM([[1, 0, 0], [0, 2, 1], [0, 0, 1]], ZZ)
+assert hermite_normal_form(m) == hnf
+assert hermite_normal_form(m, D=ZZ(2)) == hnf
+assert hermite_normal_form(m, D=ZZ(2), check_rank=True) == hnf
+
+mT = m.transpose()
+hnfT = DM([[37, 0, 19], [222, -6, 113], [48, 0, 25], [0, 2, 1], [0, 0, 1]], ZZ)
+assert hermite_normal_form(mT) == hnfT
+
+m2 = DM([[8, 28, 68, 116, 164], [3, 11, 19, 31, 43], [5, 13, 23, 37, 47]], ZZ)
+hnf2 = DM([[4, 0, 0], [0, 2, 1], [0, 0, 1]], ZZ)
+assert hermite_normal_form(m2) == hnf2
+assert hermite_normal_form(m2, D=ZZ(8)) == hnf2
+assert hermite_normal_form(m2, D=ZZ(8), check_rank=True) == hnf2
+
+m3 = DM([[10, 8, 6, 30, 2], [45, 36, 27, 18, 9], [5, 4, 3, 2, 1]], ZZ)
+hnf3 = DM([[26, 2], [0, 9], [0, 1]], ZZ)
+assert hermite_normal_form(m3) == hnf3
+
+m4 = DM([[2, 7], [0, 0], [0, 0]], ZZ)
+hnf4 = DM([[], [], []], ZZ)
+assert hermite_normal_form(m4) == hnf4
+
+m5 = DM([[-2, 1], [0, 1]], ZZ)
+hnf5 = DM([[2, 1], [0, 1]], ZZ)
+assert hermite_normal_form(m5) == hnf5
+
+print("All checks passed.")
diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py
index 30f5534b08..25b865944f 100644
--- a/sympy/polys/matrices/normalforms.py
+++ b/sympy/polys/matrices/normalforms.py
@@ -208,13 +208,15 @@ def _hermite_normal_form(A):
     # way up. The total number of rows we will consider is min(m, n), where
     # A is an m x n matrix.
     m, n = A.shape
-    rows = min(m, n)
     A = A.to_dense().rep.copy()
     # Our goal is to put pivot entries in the rightmost columns.
     # Invariant: Before processing each row, k should be the index of the
     # leftmost column in which we have so far put a pivot.
     k = n
-    for i in range(m - 1, m - 1 - rows, -1):
+    for i in range(m - 1, -1, -1):
+        # If we have already positioned pivots in all columns then stop.
+        if k == 0:
+            break
         k -= 1
         # k now points to the column in which we want to put a pivot.
         # We want zeros in all entries to the left of the pivot column.
