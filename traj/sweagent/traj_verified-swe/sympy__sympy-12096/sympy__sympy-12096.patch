diff --git a/repro_evalf_imp.py b/repro_evalf_imp.py
new file mode 100644
index 000000000..013735224
--- /dev/null
+++ b/repro_evalf_imp.py
@@ -0,0 +1,9 @@
+from sympy.utilities.lambdify import implemented_function
+from sympy import Function
+
+f = implemented_function('f', lambda x: x ** 2)
+g = implemented_function('g', lambda x: 2 * x)
+
+print('f(2).evalf() ->', f(2).evalf())
+print('g(2).evalf() ->', g(2).evalf())
+print('f(g(2)).evalf() ->', f(g(2)).evalf())
diff --git a/sympy/core/function.py b/sympy/core/function.py
index 1b8005e1d..ff316c560 100644
--- a/sympy/core/function.py
+++ b/sympy/core/function.py
@@ -506,10 +506,39 @@ def _eval_evalf(self, prec):
                 fname = MPMATH_TRANSLATIONS[fname]
             func = getattr(mpmath, fname)
         except (AttributeError, KeyError):
+            # Fall back to numerical implementation provided by _imp_
+            # Evaluate arguments numerically first, so that nested implemented
+            # functions (e.g., f(g(2))) will be handled correctly.
             try:
-                return Float(self._imp_(*self.args), prec)
-            except (AttributeError, TypeError, ValueError):
+                imp = self._imp_
+            except AttributeError:
                 return
+            try:
+                # Evaluate each argument to the requested precision
+                evaled_args = [a.evalf(prec) if hasattr(a, 'evalf') else a for a in self.args]
+                v = imp(*evaled_args)
+            except TypeError:
+                # Some implementations may expect plain Python floats; try converting
+                # SymPy Floats to float and retry.
+                evaled_args = [float(a) if isinstance(a, Float) else a for a in evaled_args]
+                try:
+                    v = imp(*evaled_args)
+                except Exception:
+                    return
+            except ValueError:
+                return
+            # If the implementation returned a SymPy expression, evalf it; otherwise
+            # sympify and evalf to ensure the correct Precision/Type.
+            from sympy.core.sympify import sympify
+            try:
+                v_sym = sympify(v)
+                return v_sym.evalf(prec)
+            except Exception:
+                # As a last resort, try to wrap real Python numbers with Float
+                try:
+                    return Float(v, prec)
+                except (TypeError, ValueError):
+                    return
 
         # Convert all args to mpf or mpc
         # Convert the arguments to *higher* precision than requested for the
