diff --git a/repro.py b/repro.py
new file mode 100644
index 0000000000..4501ad26a1
--- /dev/null
+++ b/repro.py
@@ -0,0 +1,4 @@
+from sympy.parsing.latex import parse_latex
+s = "\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}"
+expr = parse_latex(s)
+print(expr)
diff --git a/repro_basic.py b/repro_basic.py
new file mode 100644
index 0000000000..27b6a67dd0
--- /dev/null
+++ b/repro_basic.py
@@ -0,0 +1,8 @@
+import sympy as sp
+from sympy.printing.str import StrPrinter
+
+a,c,x,y = sp.symbols('a c x y')
+expr1 = sp.Mul(a, sp.Pow(sp.Pow(c,2, evaluate=False), -1, evaluate=False), evaluate=False)
+expr2 = sp.Mul(a, sp.Pow(sp.Mul(x,y, evaluate=False), -1, evaluate=False), evaluate=False)
+print('expr1:', StrPrinter().doprint(expr1))
+print('expr2:', StrPrinter().doprint(expr2))
diff --git a/repro_no_antlr.py b/repro_no_antlr.py
new file mode 100644
index 0000000000..7818ce1e06
--- /dev/null
+++ b/repro_no_antlr.py
@@ -0,0 +1,9 @@
+import sympy as sp
+from sympy.printing.str import StrPrinter
+
+a,b,c = sp.symbols('a b c')
+expr_top = sp.Mul(sp.Add(sp.Pow(a,3, evaluate=False), b, evaluate=False), sp.Pow(c,-1, evaluate=False), evaluate=False)
+inner_frac = sp.Pow(sp.Pow(c,2, evaluate=False), -1, evaluate=False)  # 1/(c**2)
+outer_denom_inv = sp.Pow(inner_frac, -1, evaluate=False)  # (1/(c**2))**-1
+expr = sp.Mul(expr_top, outer_denom_inv, evaluate=False)
+print(StrPrinter().doprint(expr))
diff --git a/sympy/printing/str.py b/sympy/printing/str.py
index c3fdcdd435..2a1e6838f7 100644
--- a/sympy/printing/str.py
+++ b/sympy/printing/str.py
@@ -332,11 +332,25 @@ def apow(i):
                 if item.exp is not S.NegativeOne:
                     b.append(apow(item))
                 else:
-                    if (len(item.args[0].args) != 1 and
-                            isinstance(item.base, Mul)):
-                        # To avoid situations like #14160
-                        pow_paren.append(item)
-                    b.append(item.base)
+                    # If the base of the negative power is itself a power, keep the
+                    # whole inverse in the denominator to preserve the structure of
+                    # nested fractions like 1/(c**2).
+                    if isinstance(item.base, Pow):
+                        # Only preserve the whole inverse when the base is a power
+                        # with a positive exponent, so that printing the inverse
+                        # introduces a nested fraction like 1/(c**2). If the base is
+                        # already an inverse (negative exponent), use the base to avoid
+                        # creating 1/(1/(...)).
+                        if item.base.exp.is_Number and item.base.exp < 0:
+                            b.append(item.base)
+                        else:
+                            b.append(item)
+                    else:
+                        if (len(item.args[0].args) != 1 and
+                                isinstance(item.base, Mul)):
+                            # To avoid situations like #14160
+                            pow_paren.append(item)
+                        b.append(item.base)
             elif item.is_Rational and item is not S.Infinity:
                 if item.p != 1:
                     a.append(Rational(item.p))
@@ -358,6 +372,12 @@ def apow(i):
         if not b:
             return sign + '*'.join(a_str)
         elif len(b) == 1:
+            # If denominator is a negative power whose base is itself a power,
+            # then its printed form will contain a division (e.g. "1/(c**2)").
+            # Wrap it in parentheses to avoid ambiguity: a/(1/(c**2)).
+            denom = b[0]
+            if isinstance(denom, Pow) and denom.exp.is_Number and denom.exp < 0 and isinstance(denom.base, Pow):
+                return sign + '*'.join(a_str) + "/(" + self._print(denom) + ")"
             return sign + '*'.join(a_str) + "/" + b_str[0]
         else:
             return sign + '*'.join(a_str) + "/(%s)" % '*'.join(b_str)
