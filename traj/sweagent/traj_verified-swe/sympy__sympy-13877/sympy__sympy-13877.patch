diff --git a/repro_matrix_nan.py b/repro_matrix_nan.py
new file mode 100644
index 000000000..4600a28b2
--- /dev/null
+++ b/repro_matrix_nan.py
@@ -0,0 +1,12 @@
+from sympy import *
+from sympy.abc import a
+
+# Build the matrix and compute determinant using default method
+f = lambda n: det(Matrix([[i + a*j for i in range(n)] for j in range(n)]))
+
+for n in range(1, 7):
+    try:
+        d = f(n)
+        print("n=%d -> %s" % (n, sstr(d)))
+    except Exception as e:
+        print("n=%d -> ERROR: %s" % (n, e))
diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index 97cde62e2..03a7af240 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -208,12 +208,21 @@ def bareiss(mat, cumm=1):
             def entry(i, j):
                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm
                 if not ret.is_Atom:
-                    cancel(ret)
+                    try:
+                        ret = cancel(ret)
+                    except TypeError:
+                        # In some symbolic cases cancel() can raise due to NaN comparisons
+                        # Skip cancellation and let the algorithm proceed or fall back later
+                        pass
                 return ret
 
             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)
 
-        return cancel(bareiss(self))
+        try:
+            return cancel(bareiss(self))
+        except TypeError:
+            # Fall back to Berkowitz for symbolic matrices where Bareiss can fail
+            return self._eval_det_berkowitz()
 
     def _eval_det_berkowitz(self):
         """ Use the Berkowitz algorithm to compute the determinant."""
