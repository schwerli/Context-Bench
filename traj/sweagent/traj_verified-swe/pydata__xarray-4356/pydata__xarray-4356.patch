diff --git a/repro_min_count_multi_dim.py b/repro_min_count_multi_dim.py
new file mode 100644
index 00000000..17e50602
--- /dev/null
+++ b/repro_min_count_multi_dim.py
@@ -0,0 +1,11 @@
+import sys
+sys.path.insert(0, '/testbed')
+import xarray as xr
+
+da = xr.DataArray([[1., 2, 3], [4, 5, 6]])
+print('Original array:', da.values)
+try:
+    res = da.sum(["dim_0", "dim_1"], min_count=1)
+    print('Sum over both dims with min_count=1:', res.values)
+except Exception as e:
+    print('Error:', type(e).__name__, str(e))
diff --git a/xarray/core/nanops.py b/xarray/core/nanops.py
index 41c8d258..892a4bf9 100644
--- a/xarray/core/nanops.py
+++ b/xarray/core/nanops.py
@@ -26,22 +26,36 @@ def _maybe_null_out(result, axis, mask, min_count=1):
     """
     xarray version of pandas.core.nanops._maybe_null_out
     """
-    if hasattr(axis, "__len__"):  # if tuple or list
-        raise ValueError(
-            "min_count is not available for reduction with more than one dimensions."
-        )
+    # Compute the number of valid (non-NaN) elements contributing to each
+    # entry of the reduced result. Support reductions over one or multiple axes.
+    if axis is not None:
+        axes = tuple(int(a) for a in np.atleast_1d(axis))
+        total_count = int(np.prod(np.take(mask.shape, axes)))
+        valid_count = total_count - mask.sum(axis)
+    else:
+        valid_count = mask.size - mask.sum()
 
-    if axis is not None and getattr(result, "ndim", False):
-        null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0
+    # If result is an array (ndim > 0), create a boolean mask of where to null-out.
+    # If result is a scalar (ndim == 0 or no ndim attribute), handle separately.
+    ndim = getattr(result, "ndim", None)
+    if ndim:
+        null_mask = (valid_count - min_count) < 0
         if null_mask.any():
             dtype, fill_value = dtypes.maybe_promote(result.dtype)
             result = result.astype(dtype)
             result[null_mask] = fill_value
-
-    elif getattr(result, "dtype", None) not in dtypes.NAT_TYPES:
-        null_mask = mask.size - mask.sum()
-        if null_mask < min_count:
-            result = np.nan
+    else:
+        # scalar result
+        try:
+            # In scalar case, valid_count is a 0d array/scalar
+            if valid_count < min_count:
+                # promote dtype and return appropriate fill value
+                dtype, fill_value = dtypes.maybe_promote(np.asarray(result).dtype)
+                # ensure scalar of correct dtype
+                result = fill_value
+        except Exception:
+            # Fallback: if anything goes wrong, preserve original result
+            pass
 
     return result
 
