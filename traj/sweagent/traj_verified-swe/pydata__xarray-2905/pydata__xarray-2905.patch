diff --git a/repro_hasvalues.py b/repro_hasvalues.py
new file mode 100644
index 00000000..5dd4a463
--- /dev/null
+++ b/repro_hasvalues.py
@@ -0,0 +1,23 @@
+import sys
+import os
+# Ensure local xarray is used
+sys.path.insert(0, os.path.dirname(__file__))
+import xarray as xr
+
+class HasValues(object):
+    values = 5
+
+# Create two object dtype DataArrays with a None placeholder
+good_indexed = xr.DataArray([None])
+bad_indexed = xr.DataArray([None])
+
+# Assign set() and a HasValues instance into the first element via .loc
+good_indexed.loc[{good_indexed.dims[0]: 0}] = set()
+bad_indexed.loc[{bad_indexed.dims[0]: 0}] = HasValues()
+
+print('good_indexed.values:', good_indexed.values, good_indexed.values.dtype)
+print('bad_indexed.values:', bad_indexed.values, bad_indexed.values.dtype)
+
+# Check expected conditions
+print('good is set instance:', isinstance(good_indexed.values[0], set))
+print('bad is HasValues instance:', isinstance(bad_indexed.values[0], HasValues))
diff --git a/xarray/core/variable.py b/xarray/core/variable.py
index 45553eb9..2336ba3a 100644
--- a/xarray/core/variable.py
+++ b/xarray/core/variable.py
@@ -218,7 +218,19 @@ def as_compatible_data(data, fastpath=False):
         data = np.timedelta64(getattr(data, "value", data), "ns")
 
     # we don't want nested self-described arrays
-    data = getattr(data, "values", data)
+    # Only unwrap known array-like container types (pandas objects or xarray DataArray).
+    # Avoid blindly accessing a generic object's `.values` attribute to prevent
+    # coercing arbitrary Python objects that happen to define `.values`.
+    if isinstance(data, (pd.Series, pd.DataFrame, xr.DataArray)):
+        data = data.values
+    elif hasattr(data, "values"):
+        # Only unwrap if .values looks like an array (to preserve ability to store
+        # arbitrary Python objects that merely define a .values attribute)
+        v = data.values
+        if isinstance(v, np.ndarray) or (
+            hasattr(v, "shape") and hasattr(v, "dtype")
+        ):
+            data = v
 
     if isinstance(data, np.ma.MaskedArray):
         mask = np.ma.getmaskarray(data)
