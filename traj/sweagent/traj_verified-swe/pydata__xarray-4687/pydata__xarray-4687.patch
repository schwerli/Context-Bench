diff --git a/repro_where_attrs.py b/repro_where_attrs.py
new file mode 100644
index 00000000..4a990c5b
--- /dev/null
+++ b/repro_where_attrs.py
@@ -0,0 +1,27 @@
+import numpy as np
+import xarray as xr
+
+# DataArray method should preserve attrs
+
+da = xr.DataArray(1)
+da.attrs['foo'] = 'bar'
+print('DataArray.where attrs (method):', xr.DataArray.where.__doc__ is not None)
+print('Method attrs before:', da.attrs)
+print('Method attrs after:', da.where(da==0, -1).attrs)
+
+# Top-level xr.where currently drops attrs; reproduce
+
+da2 = xr.DataArray(1)
+da2.attrs['foo'] = 'bar'
+res = xr.where(da2==0, -1, da2)
+print('xr.where attrs after:', res.attrs)
+
+
+# Check dtype conservation and attrs on 2D int8 example
+import numpy as np
+data = xr.DataArray(np.ones([2,2], dtype=np.int8))
+data.attrs["attr_1"] = "test1"
+data.attrs["attr_2"] = "test2"
+res2 = xr.where(data == 1, 5, 0)
+print('dtype of res2:', res2.dtype)
+print('attrs of res2:', res2.attrs)
diff --git a/xarray/core/computation.py b/xarray/core/computation.py
index 9fe93c88..45069542 100644
--- a/xarray/core/computation.py
+++ b/xarray/core/computation.py
@@ -1727,7 +1727,7 @@ def dot(*arrays, dims=None, **kwargs):
     return result.transpose(*all_dims, missing_dims="ignore")
 
 
-def where(cond, x, y):
+def where(cond, x, y, keep_attrs: bool = True):
     """Return elements from `x` or `y` depending on `cond`.
 
     Performs xarray-like broadcasting across input arguments.
@@ -1744,6 +1744,9 @@ def where(cond, x, y):
     y : scalar, array, Variable, DataArray or Dataset
         values to choose from where `cond` is False
 
+    keep_attrs : bool, optional, default: True
+        Whether to preserve attrs from the first xarray argument. If False, attrs are dropped.
+
     Returns
     -------
     Dataset, DataArray, Variable or array
@@ -1809,7 +1812,8 @@ def where(cond, x, y):
         equivalent methods
     """
     # alignment for three arguments is complicated, so don't support it yet
-    return apply_ufunc(
+    # alignment for three arguments is complicated, so don't support it yet
+    result = apply_ufunc(
         duck_array_ops.where,
         cond,
         x,
@@ -1817,8 +1821,27 @@ def where(cond, x, y):
         join="exact",
         dataset_join="exact",
         dask="allowed",
+        keep_attrs=False,
     )
 
+    # Preserve attrs from x or y (prefer x) if requested and if result is xarray object
+    if keep_attrs:
+        try:
+            from .dataarray import DataArray
+            from .dataset import Dataset
+        except Exception:  # pragma: no cover - defensive
+            DataArray = Dataset = ()
+        src = None
+        if isinstance(x, (DataArray, Dataset)):
+            src = x
+        elif isinstance(y, (DataArray, Dataset)):
+            src = y
+        # Only set attrs on xarray objects
+        if src is not None and hasattr(result, "attrs"):
+            # copy to avoid referencing original dict
+            result.attrs = dict(getattr(src, "attrs", {}))
+    return result
+
 
 def polyval(coord, coeffs, degree_dim="degree"):
     """Evaluate a polynomial at specific values
