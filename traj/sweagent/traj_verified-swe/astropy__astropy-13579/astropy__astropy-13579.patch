diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
index d7605b078..a8e603985 100644
--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
@@ -243,7 +243,30 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
         return world_arrays
 
     def world_to_pixel_values(self, *world_arrays):
+        # Convert provided world arrays to numpy arrays
         world_arrays = tuple(map(np.asanyarray, world_arrays))
+
+        # Determine the broadcast shape of the provided world arrays for kept axes
+        if len(world_arrays) > 0:
+            bshape = np.broadcast(*world_arrays).shape
+        else:
+            # No kept world axes, but this should not happen as we enforce at least one
+            # world and pixel dimension in __init__. Still, be safe.
+            bshape = ()
+
+        # Compute default world values for dropped axes by evaluating the full WCS
+        # at the slice position and zero for the kept pixel axes. These values are
+        # independent of the provided kept world coordinates because dropped axes
+        # are uncorrelated with the kept pixel axes (per axis_correlation_matrix).
+        # Use arrays of zeros with the broadcast shape to preserve broadcasting.
+        if len(self._pixel_keep) > 0:
+            zero_pix = [np.zeros(bshape)] * len(self._pixel_keep)
+            default_world = self._pixel_to_world_values_all(*zero_pix)
+        else:
+            # Should not happen, but default to zeros
+            default_world = [0.0] * self._wcs.world_n_dim
+
+        # Build the full set of world arrays in the order expected by the underlying WCS
         world_arrays_new = []
         iworld_curr = -1
         for iworld in range(self._wcs.world_n_dim):
@@ -251,11 +274,21 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
                 iworld_curr += 1
                 world_arrays_new.append(world_arrays[iworld_curr])
             else:
-                world_arrays_new.append(1.)
+                # Use the world value corresponding to the slice for dropped axes
+                # Ensure we index correctly whether default_world is a tuple or ndarray
+                if isinstance(default_world, (tuple, list)):
+                    world_arrays_new.append(np.asanyarray(default_world[iworld]))
+                else:
+                    # Single world dimension case
+                    world_arrays_new.append(np.asanyarray(default_world))
 
+        # Broadcast all world arrays to a common shape
         world_arrays_new = np.broadcast_arrays(*world_arrays_new)
+
+        # Perform the transformation on the underlying WCS
         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))
 
+        # Adjust for slice offsets on pixel axes
         for ipixel in range(self._wcs.pixel_n_dim):
             if isinstance(self._slices_pixel[ipixel], slice) and self._slices_pixel[ipixel].start is not None:
                 pixel_arrays[ipixel] -= self._slices_pixel[ipixel].start
@@ -263,6 +296,8 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
         # Detect the case of a length 0 array
         if isinstance(pixel_arrays, np.ndarray) and not pixel_arrays.shape:
             return pixel_arrays
+
+        # Return only the kept pixel axes, and flatten tuple for 1D result
         pixel = tuple(pixel_arrays[ip] for ip in self._pixel_keep)
         if self.pixel_n_dim == 1 and self._wcs.pixel_n_dim > 1:
             pixel = pixel[0]
diff --git a/repro_sliced_wcs_bug.py b/repro_sliced_wcs_bug.py
new file mode 100644
index 000000000..d00590dfc
--- /dev/null
+++ b/repro_sliced_wcs_bug.py
@@ -0,0 +1,44 @@
+import numpy as np
+import astropy.wcs
+import astropy.units as u
+
+nx = 100
+ny = 25
+nz = 2
+wcs_header = {
+    'WCSAXES': 3,
+    'CRPIX1': (nx + 1)/2,
+    'CRPIX2': (ny + 1)/2,
+    'CRPIX3': 1.0,
+    'PC1_1': 0.0,
+    'PC1_2': -1.0,
+    'PC1_3': 0.0,
+    'PC2_1': 1.0,
+    'PC2_2': 0.0,
+    'PC2_3': -1.0,
+    'CDELT1': 5,
+    'CDELT2': 5,
+    'CDELT3': 0.055,
+    'CUNIT1': 'arcsec',
+    'CUNIT2': 'arcsec',
+    'CUNIT3': 'Angstrom',
+    'CTYPE1': 'HPLN-TAN',
+    'CTYPE2': 'HPLT-TAN',
+    'CTYPE3': 'WAVE',
+    'CRVAL1': 0.0,
+    'CRVAL2': 0.0,
+    'CRVAL3': 1.05,
+}
+fits_wcs = astropy.wcs.WCS(header=wcs_header)
+print('unsliced world_to_pixel_values (expect ~49.5, 12, ~0)')
+print(fits_wcs.world_to_pixel_values(0.0, 0.0, 1.05))
+
+ll_sliced_wcs = astropy.wcs.wcsapi.SlicedLowLevelWCS(fits_wcs, 0)
+print('sliced world_to_pixel_values (expect ~49.5, 12)')
+print(ll_sliced_wcs.world_to_pixel_values(0.0, 0.0))
+
+px, py, pz = fits_wcs.world_to_pixel_values(0.0, 0.0, 1.05)
+print('unsliced pixel_to_world_values roundtrip')
+print(fits_wcs.pixel_to_world_values(px, py, pz))
+print('sliced pixel_to_world_values roundtrip')
+print(ll_sliced_wcs.pixel_to_world_values(px, py))
