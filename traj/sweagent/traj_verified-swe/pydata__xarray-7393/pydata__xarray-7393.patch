diff --git a/repro_stack_dtype.py b/repro_stack_dtype.py
new file mode 100644
index 00000000..4bcd1695
--- /dev/null
+++ b/repro_stack_dtype.py
@@ -0,0 +1,37 @@
+import xarray as xr
+import numpy as np
+
+# Create Dataset with int32 coordinate 'a'
+ds = xr.Dataset(coords={'a': np.array([0], dtype='i4')})
+print('original dtype:', ds['a'].values.dtype)
+stacked = ds.stack(b=('a',))
+print('stacked a dtype:', stacked['a'].values.dtype)
+print('expect equal:', ds['a'].values.dtype == stacked['a'].values.dtype)
+
+# Additional checks: multiple values
+arr = np.array([0,1,2], dtype='i4')
+ds2 = xr.Dataset(coords={'a': arr})
+stacked2 = ds2.stack(b=('a',))
+print('original dtype2:', ds2['a'].values.dtype, 'stacked dtype2:', stacked2['a'].values.dtype)
+
+# check product stack with another coord int32
+arrb = np.array([5], dtype='i4')
+ds3 = xr.Dataset(coords={'a': arr, 'c': arrb})
+stacked3 = ds3.stack(b=('a','c'))
+print('stacked3 a dtype:', stacked3['a'].values.dtype, 'c dtype:', stacked3['c'].values.dtype)
+
+# float32
+arrf = np.array([0.5, 1.5], dtype='f4')
+ds4 = xr.Dataset(coords={'a': arrf})
+stacked4 = ds4.stack(b=('a',))
+print('float32 original:', ds4['a'].values.dtype, 'stacked:', stacked4['a'].values.dtype)
+
+# bool
+arrbool = np.array([True, False], dtype=bool)
+ds5 = xr.Dataset(coords={'a': arrbool})
+stacked5 = ds5.stack(b=('a',))
+print('bool original:', ds5['a'].values.dtype, 'stacked:', stacked5['a'].values.dtype)
+
+# unstack roundtrip preserves dtype
+rt = stacked2.unstack()
+print('roundtrip dtype equal:', rt['a'].values.dtype == ds2['a'].values.dtype)
diff --git a/xarray/core/indexing.py b/xarray/core/indexing.py
index ba937183..ac3bbf77 100644
--- a/xarray/core/indexing.py
+++ b/xarray/core/indexing.py
@@ -1532,7 +1532,15 @@ class PandasMultiIndexingAdapter(PandasIndexingAdapter):
 
     def __array__(self, dtype: DTypeLike = None) -> np.ndarray:
         if self.level is not None:
-            return self.array.get_level_values(self.level).values
+            # Preserve dtype for level coordinates; fallback to adapter's dtype
+            if dtype is None:
+                dtype = self.dtype
+            arr = self.array.get_level_values(self.level)
+            # Mirror PandasIndexingAdapter behavior for PeriodIndex
+            with suppress(AttributeError):
+                if isinstance(arr, pd.PeriodIndex):
+                    arr = arr.astype("object")
+            return np.asarray(arr.values, dtype=dtype)
         else:
             return super().__array__(dtype)
 
