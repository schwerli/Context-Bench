diff --git a/repro_where_scalar_keep_attrs.py b/repro_where_scalar_keep_attrs.py
new file mode 100644
index 00000000..70423a7c
--- /dev/null
+++ b/repro_where_scalar_keep_attrs.py
@@ -0,0 +1,32 @@
+import xarray as xr
+
+from xarray import set_options
+import xarray as xr
+
+# Set global keep_attrs=True to reproduce the issue scenario
+set_options(keep_attrs=True)
+
+# Reproduce failure case: x is scalar with keep_attrs=True
+try:
+    da = xr.DataArray([1, 2, 3])
+    res = xr.where(da > 0, 1, 0)
+    print("Case1 Success: ", res)
+except Exception as e:
+    print("Case1 Error:", type(e).__name__, e)
+
+# Test with x having attrs -> should keep x's attrs
+try:
+    da = xr.DataArray([1, 2, 3], attrs={"a": 1})
+    x = xr.DataArray([10, 20, 30], attrs={"keep": "x"})
+    res = xr.where(da > 0, x, 0)
+    print("Case2 Attrs kept?", res.attrs)
+except Exception as e:
+    print("Case2 Error:", type(e).__name__, e)
+
+# Test when cond is scalar and x is DataArray
+try:
+    x = xr.DataArray([10, 20, 30], attrs={"keep": "x"})
+    res = xr.where(True, x, 0)
+    print("Case3 Attrs kept when cond scalar and x DA:", res.attrs)
+except Exception as e:
+    print("Case3 Error:", type(e).__name__, e)
diff --git a/xarray/core/computation.py b/xarray/core/computation.py
index 7676d8e5..8407ea13 100644
--- a/xarray/core/computation.py
+++ b/xarray/core/computation.py
@@ -1827,9 +1827,15 @@ def where(cond, x, y, keep_attrs=None):
         keep_attrs = _get_keep_attrs(default=False)
 
     if keep_attrs is True:
-        # keep the attributes of x, the second parameter, by default to
-        # be consistent with the `where` method of `DataArray` and `Dataset`
-        keep_attrs = lambda attrs, context: attrs[1]
+        # keep the attributes of x (the second parameter) by default to
+        # be consistent with the `where` method of `DataArray` and `Dataset`.
+        # If `x` is a scalar (i.e., has no `attrs`), gracefully return an empty dict.
+        # We use a closure to reference `x` directly, rather than relying on
+        # the list of attrs passed to merge_attrs, which may not include `x` when it is scalar.
+        if hasattr(x, "attrs"):
+            keep_attrs = lambda attrs, context: x.attrs
+        else:
+            keep_attrs = lambda attrs, context: {}
 
     # alignment for three arguments is complicated, so don't support it yet
     return apply_ufunc(
