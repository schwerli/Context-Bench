diff --git a/lib/matplotlib/mlab.py b/lib/matplotlib/mlab.py
index 3552904c3d..efa2f84cae 100644
--- a/lib/matplotlib/mlab.py
+++ b/lib/matplotlib/mlab.py
@@ -395,12 +395,12 @@ def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,
     elif mode == 'psd':
         result = np.conj(result) * result
     elif mode == 'magnitude':
-        result = np.abs(result) / np.abs(window).sum()
+        result = np.abs(result) / window.sum()
     elif mode == 'angle' or mode == 'phase':
         # we unwrap the phase later to handle the onesided vs. twosided case
         result = np.angle(result)
     elif mode == 'complex':
-        result /= np.abs(window).sum()
+        result /= window.sum()
 
     if mode == 'psd':
 
@@ -424,10 +424,10 @@ def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,
             result /= Fs
             # Scale the spectrum by the norm of the window to compensate for
             # windowing loss; see Bendat & Piersol Sec 11.5.2.
-            result /= (np.abs(window)**2).sum()
+            result /= (window**2).sum()
         else:
             # In this case, preserve power in the segment, not amplitude
-            result /= np.abs(window).sum()**2
+            result /= window.sum()**2
 
     t = np.arange(NFFT/2, len(x) - NFFT/2 + 1, NFFT - noverlap)/Fs
 
diff --git a/tmp/repro.py b/tmp/repro.py
new file mode 100644
index 0000000000..8a85627061
--- /dev/null
+++ b/tmp/repro.py
@@ -0,0 +1,37 @@
+import numpy as np
+from matplotlib import mlab
+
+# Create a window with some negative values and nonzero sum
+N = 512
+n = np.arange(N)
+win = 0.1 + np.cos(2*np.pi*n/N)
+
+# Input signal: use the window itself so the DC of the FFT after windowing is sum(win**2)
+x = win.copy()
+
+Pxx, freqs = mlab.psd(x, NFFT=N, Fs=1.0, detrend=mlab.detrend_none, window=win,
+                      noverlap=0, pad_to=None, sides='default', scale_by_freq=False)
+
+# DC bin of the PSD
+dc_val = Pxx[0]
+
+# Expected DC values under different normalizations
+# |FFT_DC|^2 = (sum(win**2))**2
+numerator = (win**2).sum()**2
+expected_abs = numerator / (np.abs(win).sum()**2)
+expected_noabs = numerator / (win.sum()**2)
+
+print("DC PSD value:", dc_val)
+print("Expected with abs(window) in denominator:", expected_abs)
+print("Expected without abs(window) in denominator:", expected_noabs)
+
+# Show differences
+print("dc - expected_abs:", dc_val - expected_abs)
+print("dc - expected_noabs:", dc_val - expected_noabs)
+
+# Also test magnitude and complex spectrum scaling on DC bin
+mag, freqs_mag = mlab.magnitude_spectrum(x, Fs=1.0, window=win, pad_to=N, sides='default')
+comp, freqs_comp = mlab.complex_spectrum(x, Fs=1.0, window=win, pad_to=N, sides='default')
+print("Magnitude DC:", mag[0], "Expected:", (win**2).sum() / win.sum())
+print("Complex DC magnitude:", np.abs(comp[0]), "Expected:", (win**2).sum() / win.sum())
+
