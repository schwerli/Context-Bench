diff --git a/repro_point_mul.py b/repro_point_mul.py
new file mode 100644
index 0000000000..037102ab69
--- /dev/null
+++ b/repro_point_mul.py
@@ -0,0 +1,11 @@
+import sympy
+from sympy import geometry as ge
+
+point1 = ge.Point(0,0)
+point2 = ge.Point(1,1)
+
+print('Case A: point1 + point2 * sympy.sympify(2.0)')
+print(point1 + point2 * sympy.sympify(2.0))
+
+print('Case B: point1 + sympy.sympify(2.0) * point2')
+print(point1 + sympy.sympify(2.0) * point2)
diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py
index 7c978c47be..94883cc225 100644
--- a/sympy/geometry/point.py
+++ b/sympy/geometry/point.py
@@ -216,6 +216,25 @@ def __add__(self, other):
         try:
             s, o = Point._normalize_dimension(self, Point(other, evaluate=False))
         except TypeError:
+            # Handle cases like scalar*Point (e.g., 2.0*Point2D(1, 1))
+            # where `other` is a sympy Mul. Extract the Point and the scalar
+            # factor and perform the multiplication to obtain a Point.
+            p_in_mul = None
+            if getattr(other, 'is_Mul', False):
+                for arg in getattr(other, 'args', []):
+                    if isinstance(arg, Point):
+                        p_in_mul = arg
+                        break
+                if p_in_mul is not None:
+                    factor = S.One
+                    for arg in other.args:
+                        if arg is p_in_mul:
+                            continue
+                        factor = factor*arg
+                    scaled_point = p_in_mul * factor
+                    s, o = Point._normalize_dimension(self, scaled_point)
+                    coords = [simplify(a + b) for a, b in zip(s, o)]
+                    return Point(coords, evaluate=False)
             raise GeometryError("Don't know how to add {} and a Point object".format(other))
 
         coords = [simplify(a + b) for a, b in zip(s, o)]
@@ -278,6 +297,14 @@ def __mul__(self, factor):
         coords = [simplify(x*factor) for x in self.args]
         return Point(coords, evaluate=False)
 
+    def __rmul__(self, factor):
+        """Support right multiplication so that scalar*Point works.
+
+        This ensures that Python numbers (e.g., int, float) multiplied on the
+        left with a Point produce a Point with scaled coordinates.
+        """
+        return self.__mul__(factor)
+
     def __neg__(self):
         """Negate the point."""
         coords = [-x for x in self.args]
