diff --git a/django/db/migrations/recorder.py b/django/db/migrations/recorder.py
index 1a37c6b7d0..871615450e 100644
--- a/django/db/migrations/recorder.py
+++ b/django/db/migrations/recorder.py
@@ -1,5 +1,5 @@
 from django.apps.registry import Apps
-from django.db import DatabaseError, models
+from django.db import DatabaseError, models, router
 from django.utils.functional import classproperty
 from django.utils.timezone import now
 
@@ -50,6 +50,13 @@ class MigrationRecorder:
     def migration_qs(self):
         return self.Migration.objects.using(self.connection.alias)
 
+    def _router_allows_migrate(self):
+        """
+        Check router rules to see if migration recording is allowed on this
+        connection for the Migration model.
+        """
+        return router.allow_migrate_model(self.connection.alias, self.Migration)
+
     def has_table(self):
         """Return True if the django_migrations table exists."""
         with self.connection.cursor() as cursor:
@@ -58,6 +65,10 @@ class MigrationRecorder:
 
     def ensure_schema(self):
         """Ensure the table exists and has the correct schema."""
+        # Respect router's allow_migrate rules: don't create the table if
+        # migrations aren't allowed on this connection.
+        if not self._router_allows_migrate():
+            return
         # If the table's there, that's fine - we've never changed its schema
         # in the codebase.
         if self.has_table():
@@ -74,6 +85,10 @@ class MigrationRecorder:
         Return a dict mapping (app_name, migration_name) to Migration instances
         for all applied migrations.
         """
+        # Respect router: if migrations aren't allowed on this connection,
+        # treat as no applied migrations.
+        if not self._router_allows_migrate():
+            return {}
         if self.has_table():
             return {(migration.app, migration.name): migration for migration in self.migration_qs}
         else:
@@ -83,14 +98,20 @@ class MigrationRecorder:
 
     def record_applied(self, app, name):
         """Record that a migration was applied."""
+        if not self._router_allows_migrate():
+            return
         self.ensure_schema()
         self.migration_qs.create(app=app, name=name)
 
     def record_unapplied(self, app, name):
         """Record that a migration was unapplied."""
+        if not self._router_allows_migrate():
+            return
         self.ensure_schema()
         self.migration_qs.filter(app=app, name=name).delete()
 
     def flush(self):
         """Delete all migration records. Useful for testing migrations."""
+        if not self._router_allows_migrate():
+            return
         self.migration_qs.all().delete()
diff --git a/repro_recorder_router.py b/repro_recorder_router.py
new file mode 100644
index 0000000000..18f87b324d
--- /dev/null
+++ b/repro_recorder_router.py
@@ -0,0 +1,66 @@
+import sys
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+
+# Configure minimal settings with two DBs and a router that only allows default.
+if not settings.configured:
+    settings.configure(
+        SECRET_KEY='test',
+        INSTALLED_APPS=[],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            },
+            'other': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            },
+        },
+        DATABASE_ROUTERS=['repro_recorder_router.TestRouter'],
+        USE_TZ=True,
+    )
+
+# Define router in this module so import_string can resolve it.
+class TestRouter:
+    def allow_migrate(self, db, app_label, **hints):
+        # Only allow migrations on 'default'.
+        return db == 'default'
+
+from django import setup as django_setup
+
+django_setup()
+
+from django.db import connections
+from django.db.migrations.recorder import MigrationRecorder
+
+# Work with the 'other' connection that should disallow migrations according to the router.
+conn_other = connections['other']
+recorder_other = MigrationRecorder(conn_other)
+
+# Before fix, this will create the django_migrations table on 'other'. After fix, it should not.
+try:
+    recorder_other.record_applied('testapp', '0001_initial')
+    created = recorder_other.has_table()
+    print('Has django_migrations table on other:', created)
+except Exception as e:
+    print('Error during record_applied on other:', type(e).__name__, e)
+
+# Also test applied_migrations should be empty for disallowed DB.
+applied = recorder_other.applied_migrations()
+print('Applied migrations on other count:', len(applied))
+
+# Work with the 'default' connection that should allow migrations.
+conn_default = connections['default']
+recorder_default = MigrationRecorder(conn_default)
+
+try:
+    recorder_default.record_applied('testapp', '0001_initial')
+    created_def = recorder_default.has_table()
+    print('Has django_migrations table on default:', created_def)
+except Exception as e:
+    print('Error during record_applied on default:', type(e).__name__, e)
+
+applied_def = recorder_default.applied_migrations()
+print('Applied migrations on default count:', len(applied_def))
