diff --git a/repro b/repro
new file mode 100644
index 000000000..9d55e765b
--- /dev/null
+++ b/repro
@@ -0,0 +1 @@
+<dir>
\ No newline at end of file
diff --git a/repro_property_index.py b/repro_property_index.py
new file mode 100644
index 000000000..b57024626
--- /dev/null
+++ b/repro_property_index.py
@@ -0,0 +1,21 @@
+# Reproduction script for property index entry formatting
+from sphinx.domains.python import PyMethod, PyProperty
+
+class DummyEnv:
+    class Config:
+        add_module_names = True
+    config = Config()
+
+class Dummy:
+    env = DummyEnv()
+    options = {'property': True}
+
+# Test PyMethod with :property: option
+modname = 'mymod'
+name_cls = ('Foo.bar', '')
+text_method = PyMethod.get_index_text(Dummy(), modname, name_cls)
+print('PyMethod property index:', text_method)
+
+# Test PyProperty directive
+text_prop = PyProperty.get_index_text(Dummy(), modname, name_cls)
+print('PyProperty index:', text_prop)
diff --git a/repro_property_index_scanner.py b/repro_property_index_scanner.py
new file mode 100644
index 000000000..279a67474
--- /dev/null
+++ b/repro_property_index_scanner.py
@@ -0,0 +1,12 @@
+# Scanner to detect property index entry formatting in PyMethod.get_index_text
+from pathlib import Path
+
+p = Path('/testbed/sphinx/domains/python.py')
+text = p.read_text(encoding='utf-8')
+
+if "return _('%s() (%s property)')" in text:
+    print('Bug present: property index entry uses parens')
+elif "return _('%s (%s property)')" in text:
+    print('Bug fixed: property index entry has no parens')
+else:
+    print('Could not determine property index entry format')
diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py
index cd02eaad5..1ab12238e 100644
--- a/sphinx/domains/python.py
+++ b/sphinx/domains/python.py
@@ -788,15 +788,23 @@ class PyMethod(PyObject):
             if modname and self.env.config.add_module_names:
                 clsname = '.'.join([modname, clsname])
         except ValueError:
-            if modname:
-                return _('%s() (in module %s)') % (name, modname)
+            # If no classname could be determined (no dotted name), still respect :property:
+            if 'property' in self.options:
+                if modname:
+                    return _('%s (in module %s)') % (name, modname)
+                else:
+                    return '%s' % name
             else:
-                return '%s()' % name
+                if modname:
+                    return _('%s() (in module %s)') % (name, modname)
+                else:
+                    return '%s()' % name
 
         if 'classmethod' in self.options:
             return _('%s() (%s class method)') % (methname, clsname)
         elif 'property' in self.options:
-            return _('%s() (%s property)') % (methname, clsname)
+            # Properties should not have parens in index entries
+            return _('%s (%s property)') % (methname, clsname)
         elif 'staticmethod' in self.options:
             return _('%s() (%s static method)') % (methname, clsname)
         else:
