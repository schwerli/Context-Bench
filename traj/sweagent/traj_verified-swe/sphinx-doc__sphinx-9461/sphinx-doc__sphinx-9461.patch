diff --git a/repro_clsprop.py b/repro_clsprop.py
new file mode 100644
index 000000000..59fa4e65c
--- /dev/null
+++ b/repro_clsprop.py
@@ -0,0 +1,71 @@
+import os
+import sys
+import shutil
+
+# Ensure we import the local sphinx from /testbed
+sys.path.insert(0, "/testbed")
+
+from sphinx.application import Sphinx
+
+
+def write(path, text):
+    os.makedirs(os.path.dirname(path), exist_ok=True)
+    with open(path, 'w', encoding='utf-8') as f:
+        f.write(text)
+
+
+def main():
+    tmp = os.path.join('/tmp', 'sphinx_repro_clsprop')
+    if os.path.exists(tmp):
+        shutil.rmtree(tmp)
+    os.makedirs(tmp, exist_ok=True)
+    src = os.path.join(tmp, 'src')
+    out = os.path.join(tmp, 'out')
+    doctree = os.path.join(tmp, 'doctree')
+    os.makedirs(src, exist_ok=True)
+    os.makedirs(out, exist_ok=True)
+    os.makedirs(doctree, exist_ok=True)
+
+    write(os.path.join(src, 'conf.py'), """
+extensions = ['sphinx.ext.autodoc']
+master_doc = 'index'
+""")
+
+    write(os.path.join(src, 'index.rst'), """
+Testing class property
+======================
+
+.. autoclass:: mymod.A
+   :members:
+""")
+
+    write(os.path.join(src, 'mymod.py'), """
+class A:
+    @classmethod
+    @property
+    def f(cls):
+        """Some class property."""
+        return 42
+""")
+
+    app = Sphinx(srcdir=src, confdir=src, outdir=out, doctreedir=doctree,
+                 buildername='html', warningiserror=False, freshenv=True)
+    app.build(force_all=True)
+    print('Build status code:', app.statuscode)
+    index_html = os.path.join(out, 'index.html')
+    print('Index HTML exists:', os.path.exists(index_html))
+    if os.path.exists(index_html):
+        data = open(index_html, 'r', encoding='utf-8').read()
+        has_doc = 'Some class property' in data
+        print('Docstring for class property present:', has_doc)
+        # Show small snippet around the docstring if found
+        if has_doc:
+            pos = data.find('Some class property')
+            snippet = data[max(0, pos-120):pos+120]
+            print('Snippet around docstring:\n', snippet)
+        # Also check that the member name appears
+        has_member_name = '>f<' in data or 'f\xa0' in data or 'f ' in data
+        print('Member name f appears in HTML:', has_member_name)
+
+if __name__ == '__main__':
+    main()
diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index 1cecb1f79..514988a8a 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -2724,6 +2724,51 @@ def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
     return safe_getattr(obj, name, *defargs)
 
 
+
+def _class_attrgetter(obj: Any, name: str, *defargs: Any) -> Any:
+    """Specialized attrgetter for classes (type).
+
+    It returns descriptor objects for properties to avoid invoking them, and
+    also supports class-level properties implemented by combining
+    ``@classmethod`` and ``@property`` (Python 3.9+).
+
+    If the attribute is a classmethod wrapping a property, return the
+    underlying property object so that autodoc can treat it as a property and
+    extract its docstring and type information correctly.
+    """
+    try:
+        # Try to obtain the raw attribute from the class or its bases without
+        # triggering descriptor protocol.
+        attr = None
+        if hasattr(obj, '__dict__') and name in obj.__dict__:
+            attr = obj.__dict__[name]
+        else:
+            for base in getattr(obj, '__mro__', ()):
+                if name in getattr(base, '__dict__', {}):
+                    attr = base.__dict__[name]
+                    break
+
+        if attr is not None:
+            # Handle classmethod-wrapped properties
+            try:
+                from sphinx.util import inspect as _sphinx_inspect  # local import to avoid cycles
+                if isinstance(attr, classmethod) and _sphinx_inspect.isproperty(attr.__func__):
+                    return attr.__func__
+            except Exception:
+                pass
+
+            # Return property and cached_property descriptors as-is
+            from sphinx.util import inspect as _sphinx_inspect  # local import to avoid cycles
+            if _sphinx_inspect.isproperty(attr):
+                return attr
+    except Exception:
+        # Fall back to standard behavior if anything goes wrong
+        pass
+
+    # Default: use the safe_getattr which is aware of odd attribute access patterns
+    return safe_getattr(obj, name, *defargs)
+
+
 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
     if config.autodoc_member_order == 'alphabetic':
         # RemovedInSphinx50Warning
@@ -2781,4 +2826,8 @@ def setup(app: Sphinx) -> Dict[str, Any]:
     app.setup_extension('sphinx.ext.autodoc.type_comment')
     app.setup_extension('sphinx.ext.autodoc.typehints')
 
+    # Ensure autodoc attrgetter for classes preserves property descriptors and
+    # handles classmethod-wrapped properties (@classmethod @property)
+    app.registry.add_autodoc_attrgetter(type, _class_attrgetter)
+
     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}
