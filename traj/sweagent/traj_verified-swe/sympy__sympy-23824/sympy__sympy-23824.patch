diff --git a/repro_kahane.py b/repro_kahane.py
new file mode 100644
index 0000000000..d074907a02
--- /dev/null
+++ b/repro_kahane.py
@@ -0,0 +1,29 @@
+import sympy
+from sympy.physics.hep.gamma_matrices import GammaMatrix as G, gamma_trace, LorentzIndex
+from sympy.physics.hep.gamma_matrices import kahane_simplify
+from sympy.tensor.tensor import tensor_indices
+
+mu, nu, rho, sigma = tensor_indices("mu, nu, rho, sigma", LorentzIndex)
+
+print('Running reproduction of kahane_simplify leading gamma order bug:')
+
+# Case 1
+t = G(mu)*G(-mu)*G(rho)*G(sigma)
+r = kahane_simplify(t)
+print('Input 1:', t)
+print('Result 1:', r)
+print('Expected 1: 4*GammaMatrix(rho)*GammaMatrix(sigma)')
+
+# Case 2
+t2 = G(rho)*G(sigma)*G(mu)*G(-mu)
+r2 = kahane_simplify(t2)
+print('Input 2:', t2)
+print('Result 2:', r2)
+print('Expected 2: 4*GammaMatrix(rho)*GammaMatrix(sigma)')
+
+ok1 = r.equals(4*G(rho)*G(sigma))
+ok2 = r2.equals(4*G(rho)*G(sigma))
+print('Assertion 1 equals expected:', ok1)
+print('Assertion 2 equals expected:', ok2)
+if not (ok1 and ok2):
+    raise AssertionError('kahane_simplify leading gamma order bug still present')
diff --git a/sympy/physics/hep/gamma_matrices.py b/sympy/physics/hep/gamma_matrices.py
index 23284e4a92..28b94fca32 100644
--- a/sympy/physics/hep/gamma_matrices.py
+++ b/sympy/physics/hep/gamma_matrices.py
@@ -692,9 +692,11 @@ def kahane_simplify(expression):
     # power of two factor, as described in Kahane's paper:
     resulting_coeff *= 2**(number_of_contractions)
 
-    # If `first_dum_pos` is not zero, it means that there are trailing free gamma
-    # matrices in front of `expression`, so multiply by them:
-    for i in range(0, first_dum_pos):
+    # If `first_dum_pos` is not zero, it means that there are leading free gamma
+    # matrices in front of `expression`, so add them preserving order:
+    # Inserting at index 0 in ascending order reverses their relative order,
+    # so we insert in reverse index order.
+    for i in range(first_dum_pos - 1, -1, -1):
         [ri.insert(0, free_pos[i]) for ri in resulting_indices]
 
     resulting_expr = S.Zero
