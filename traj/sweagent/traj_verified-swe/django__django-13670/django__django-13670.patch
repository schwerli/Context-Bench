diff --git a/django/utils/dateformat.py b/django/utils/dateformat.py
index afd36d79e0..acf9b0c169 100644
--- a/django/utils/dateformat.py
+++ b/django/utils/dateformat.py
@@ -325,8 +325,9 @@ class DateFormat(TimeFormat):
         return self.data.isocalendar()[1]
 
     def y(self):
-        "Year, 2 digits; e.g. '99'"
-        return str(self.data.year)[2:]
+        "Year, 2 digits; zero-padded; e.g. '99', '09', '00'"
+        # Use modulo to get the last two digits and zero-pad to match Python's strftime("%y").
+        return "%02d" % (self.data.year % 100)
 
     def Y(self):
         "Year, 4 digits; e.g. '1999'"
diff --git a/repro_dateformat_y.py b/repro_dateformat_y.py
new file mode 100644
index 0000000000..4333ea1f40
--- /dev/null
+++ b/repro_dateformat_y.py
@@ -0,0 +1,24 @@
+import datetime
+from django.conf import settings
+
+# Configure minimal settings for timezone usage in dateformat
+if not settings.configured:
+    settings.configure(TIME_ZONE="UTC", USE_TZ=False)
+
+from django.utils import dateformat
+
+# Reproduce the issue: expecting last two digits with leading zeros
+cases = [
+    (datetime.datetime(123, 4, 5, 6, 7), "23"),
+    (datetime.datetime(9, 1, 1, 0, 0), "09"),
+    (datetime.datetime(99, 12, 31, 23, 59), "99"),
+    (datetime.datetime(100, 1, 1, 0, 0), "00"),
+    (datetime.datetime(2001, 1, 1, 0, 0), "01"),
+]
+
+for dt, expected in cases:
+    result = dateformat.format(dt, "y")
+    print(f"Year {dt.year} -> y: {result}")
+    assert result == expected, f"Expected {expected} for year {dt.year}, got {result}"
+
+print("All assertions passed for 'y' formatting.")
