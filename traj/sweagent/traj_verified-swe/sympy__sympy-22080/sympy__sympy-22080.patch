diff --git a/repro_mod_lambdify.py b/repro_mod_lambdify.py
new file mode 100644
index 0000000000..10151a84cc
--- /dev/null
+++ b/repro_mod_lambdify.py
@@ -0,0 +1,40 @@
+import sys, inspect
+sys.path.insert(0, '/testbed')
+from sympy import Mod, lambdify, symbols
+x, y = symbols('x y')
+expr = -Mod(x, y)
+print('expr:', expr)
+# default modules
+f = lambdify([x, y], expr)
+print('f(3,7)=', f(3,7))
+print('f source:')
+print(inspect.getsource(f))
+# modules=[] case
+g = lambdify([x, y], expr, modules=[])
+print('g(3,7)=', g(3,7))
+print('g source:')
+print(inspect.getsource(g))
+
+
+# Test multiplication wrapping case
+expr2 = (2) * Mod(x, y)
+print('expr2:', expr2)
+h = lambdify([x, y], expr2)
+print('h(3,7)=', h(3,7))
+print('h source:')
+print(inspect.getsource(h))
+i = lambdify([x, y], expr2, modules=[])
+print('i(3,7)=', i(3,7))
+print('i source:')
+print(inspect.getsource(i))
+
+
+# Test expr * Mod(a,b) case
+x2, y2, z2 = symbols('x2 y2 z2')
+expr3 = x2 * Mod(y2, z2)
+print('expr3:', expr3)
+fn = lambdify([x2, y2, z2], expr3, modules=[])
+print('fn source:')
+print(inspect.getsource(fn))
+print('fn(2,3,7)=', fn(2,3,7))
+# Expected: 2 * (3 % 7) = 2*3 = 6
diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index b669a2c783..f6d3ad90b6 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -234,7 +234,11 @@ def _print_ComplexInfinity(self, expr):
 
     def _print_Mod(self, expr):
         PREC = precedence(expr)
-        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))
+        # Wrap the modulo operation in parentheses to preserve grouping when used
+        # inside larger expressions (e.g., unary minus or multiplication).
+        # Without parentheses, expressions like -Mod(x, y) would print as
+        # "-x % y", which Python parses as ((-x) % y) rather than (-(x % y)).
+        return ('({} % {})'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))
 
     def _print_Piecewise(self, expr):
         result = []
